//     AdvancedSkeleton
//     Version 5.130
//
//
// AdvancedSkeleton is is a collection of Maya tools for doing character setup.
//
// INSTALLATION:
// drag`n`drop the "install.mel" file into Maya (drop in any viewport).
//
// For detailed instructions read the "install.txt" file
//
// Copyright (C)2016 Animation Studios
//
// email: support@animationstudios.com.au
// Last Modified 11/01/2016

global proc AdvancedSkeleton5 ()
{
global int $asBuilding;
global int $asRebuilding;
global int $asFaceIsResetting;
global string $gMainProgressBar;
global string $asDSAltPivot;
global int $asFitModeScriptJobNr4;
global int $asSkipConfirm;
string $evalManagerStats[];
string $m="EvaluationMode currently:"+$evalManagerStats[0]+"\nAdvancedSkeleton requires DG mode.\nClick OK to switch";
if (`asMayaVersionAsFloat`>=2016)
	{
	$evalManagerStats=`evaluationManager -q -m`;
	if ($evalManagerStats[0]!="off")
		if (`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`=="Ok")
			evaluationManager -m "off";			
	}
if (`manipMoveContext -q -ex Move`)
	if (!catchQuiet (`manipMoveContext -q -orientJointEnabled Move`))
		if (`manipMoveContext -q -orientJointEnabled Move`)
			manipMoveContext -e -orientJointEnabled 0 Move;
//asFitModeManualUpdate;
int $asDock=`optionVar -q asDock`;
if (`exists dockControl`)
	if (!`optionVar -ex asDock`)
		$asDock=1;
$asBuilding=0;
$asRebuilding=0;
$asFitModeSkip=0;
$asSkipConfirm=0;
$asDSAltPivot="";
int $csm=0;//CorrectiveShapeMode
string $boldFont="smallBoldLabelFont";
if (`asMayaVersionAsFloat`<2012)
	$boldFont="plainLabelFont";
string $asScriptLocation=`asGetScriptLocation`;
string $labels[]={"Root","Chest","Mid","Hip","Foot","Heel","Toes","ToesEnd","BigToe","PinkyToe","LegAim","Shoulder","Hand","0","1","2","3"};
string $attributes[]={"twist/bendy","inbetween","global","aim","wheel","freeOrient","worldOrient","flipOrient","noMirror","noFlip","noControl","ikLocal","centerBtwFeet","geoAttach"};
string $geometry,$allFaceGeoString,$eyeL,$eyeR,$upperTeeth,$lowerTeeth,$tongue,$label,
	$eyeBrowL,$eyeBrowR,$eyeLashL,$eyeLashR,$headJoint,$skinCluster;
if (`attributeExists geometry FaceFitSkeleton`)
	$geometry=`getAttr FaceFitSkeleton.geometry`;
if (`attributeExists AllFaceGeo FaceFitSkeleton`)
	$allFaceGeoString=`getAttr FaceFitSkeleton.AllFaceGeo`;
if (`attributeExists Eye_L FaceFitSkeleton`)
	$eyeL=`getAttr FaceFitSkeleton.Eye_L`;
if (`attributeExists Eye_R FaceFitSkeleton`)
	$eyeR=`getAttr FaceFitSkeleton.Eye_R`;
if (`attributeExists UpperTeeth FaceFitSkeleton`)
	$upperTeeth=`getAttr FaceFitSkeleton.UpperTeeth`;
if (`attributeExists LowerTeeth FaceFitSkeleton`)
	$lowerTeeth=`getAttr FaceFitSkeleton.LowerTeeth`;
if (`attributeExists Tongue FaceFitSkeleton`)
	$tongue=`getAttr FaceFitSkeleton.Tongue`;
if (`attributeExists HeadJoint FaceFitSkeleton`)
	$headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
if (`attributeExists "SkinCluster" FaceFitSkeleton`)
	$skinCluster=`getAttr FaceFitSkeleton.SkinCluster`;

string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		$csm=1;
int $dsm=0;//DrivingSystemMode
$rootLevelObjects=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists sdkDriverValue $rootLevelObjects[$i]`)
		$dsm=1;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
if ($asFitModeScriptJobNr4!=0)
	if (!`scriptJob -ex $asFitModeScriptJobNr4`)
		$asFitModeScriptJobNr4=0;
if ($asFitModeScriptJobNr4==0)
	$asFitModeScriptJobNr4=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;

if (`exists dockControl`)
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		deleteUI -control AdvancedSkeletonDockControl;
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
window -t AdvancedSkeleton5 AdvancedSkeletonWindow;
formLayout asFormLayout;
scrollLayout asScrollLayout;
columnLayout -adj 1 asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Pre" asPreFrameLayout;
columnLayout -adj 0;
	text -fn $boldFont -l "This \"Preparation\" section is optional,";
	text -fn $boldFont -l "but recommended for clean file and workflow";
	separator -h 10;
	text -l "Clean :";
	text -l "Group your model, so that you have 1 top node.";
	text -l "And name this group \"geo\"";
	text -l "Then use the model-cleaner tool:";
	rowLayout -nc 4 -cw4 60 114 51 15;
		separator;
		button -w 72 -l "Model Clean" -c asModelCleaner;
		separator;
		button -w 11 -l "?" -c "asHelpImage asPreModelCleaner";
		setParent..;
	separator -h 10;
	text -l "Then save your cleaned model.";
	separator -h 5;
	separator -w 262;
	separator -h 5;
	if (`asIsMayaLT`)
		{
		separator -w 262 -h 10	;
		text -fn $boldFont -l "Next is to reference model-file into rig-file.";
		text -fn $boldFont -l "But MayaLT does not have referencing.";
		text -fn $boldFont -l "So, just rig the model-file instead.";
		}
	else
		{
		text -l "Create rig file:";
		rowLayout -nc 4 -cw4 60 114 51 15;
			separator;
			button -w 72 -l "New Scene" -c NewScene;
			separator;
			button -w 11 -l "?" -c "asHelpImage asPreNewScene";
			setParent..;
		text -l "Reference-in the model:";
		rowLayout -nc 4 -cw4 60 114 51 15;
			separator;
			button -w 72 -l "Reference" -c asReferenceModelBrowser;
			separator;
			button -w 11 -l "?" -c "asHelpImage asPreReference";
			setParent..;
		}
	setParent..;
setParent..;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Body" asBodyFrameLayout;
columnLayout -adj 1;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asBodyFitFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 1;
				text -l "FitSkeletons:";
				setParent..;
			rowLayout -nc 4 -cw4 60 114 49 15;
				separator -st none;
				columnLayout;
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asFitFiles;
						button -l "Import" -c asFitSkeletonImport;
						button -w 11 -l "?" -c "asHelpImage asFitSkeletons";
						setParent..;
					text -l " extra limbs:";
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asLimbFiles;
						button -l "Import" -c asFitSkeletonLimbsImport;
						button -w 11 -l "?" -c "asHelpImage asFitLimbs";
						setParent..;
					separator -h 5;
					rowLayout -nc 3 -cw3 114 49 15;
						separator -st none;
						button -h 15 -l "Export" -c asFitSkeletonExport;
						button -h 15 -w 11 -l "?" -c "asHelpImage asFitExport";
						setParent..;
					setParent..;
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Create:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
 				$gBuffStr = `toolButton -style iconOnly -doubleClickCommand "toolPropertyWindow" -cl toolCluster `;
    		$gBuffStr1 = `jointCtx -image1 "kinJoint.png" -image2 "vacantCell.png" -image3 "vacantCell.png" -scaleCompensateJ 1
        -degreeOfFreedomJ "xyz" -jointOrientationJ 0 0 0 -scaleOrientationJ 0 0 0 -scaleJ 1 1 1 -autoJointOrient "xyz" 
        -secondaryAxisOrient "yup" -jointAutoLimits 0-createIKHandle 0-solverTypeH "ikSCsolver" -autoPriorityH 0
        -snapHandleH 1 -forceSolverH 1 -stickyH "off" -priorityH 1 -weightH 1 -poWeightH 1`;
				if (`asMayaVersionAsFloat`>=2012)
			    toolButton -edit -tool $gBuffStr1 -toolImage1 $gBuffStr1 "kinJoint.png" $gBuffStr;
		    toolButton -edit -tool $gBuffStr1 $gBuffStr;
		    button -w 72 -l "ReSample" -c asFitResample;
				button -w 11 -l "?" -c "asHelpImage asFitCreate";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "IK-Label:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				optionMenu -cc asUpdateLabelHelp asLabelType;
				for ($label in $labels)
					menuItem -l $label;
				separator;
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn $boldFont -en 0 asLabelHelp;
				button -w 11 -l "?" -c "asHelpImage asFitLabels";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointLabel;
				button -w 72 -l "Remove" -c asRemoveFitJointLabel;
				setParent..;
			separator -h 10;
			rowLayout -nc 1;
				text -l "Attribute:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
				optionMenu -cc asUpdateAttributeHelp asAttributeType;
				for ($attribute in $attributes)
					menuItem -l $attribute;
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn $boldFont -en 0 asAttributeHelp;
				button -w 11 -l "?" -c "asHelpImage asFitAttributes";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointAttribute;
				button -w 72 -l "Remove" -c asRemoveFitJointAttribute;
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Display:";
				setParent..;
			floatSliderGrp -cw3 85 35 20 -l "joint" -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			rowLayout -nc 4 -cw4 62 78 85 15;
				separator;
				checkBox -l "geometry" -cc asFitGeometry asVisGeo;
				optionMenu -en 0 -cc asChangeVisGeoType asVisGeoType;
					menuItem -l "cylinders" -data 0;
					menuItem -l "boxes" -data 1;
					menuItem -l "spheres" -data 2;
					menuItem -l "bones" -data 3;
				button -w 11 -l "?" -c "asHelpImage asFitDisplay";
				setParent..;
			floatSliderGrp -cw3 85 35 20 -l "gap" -field 1 -min 0.01 -max 1 -pre 2 -v 0.75 asVisGap;
			rowLayout -nc 3 -cw3 62 78 60;
				separator;
				checkBox -l "joint-axis" -onc "asFitDisplayAxis 1" -ofc "asFitDisplayAxis 0";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Placement:";
				setParent..;
			rowLayout -nc 5 -cw5 62 29 40 92 15;
				separator -st none;
				if (`asHaveMeshCenterSnap`)
					{
					text -l "Snap:";
					iconTextCheckBox -w 26 -h 26 -i "snapMeshCenter.png" -cc "snapMode -meshCenter #1" asMeshCenterSnapButton;
					}
				else
					{
					separator -st none;
					separator -st none;
					}
				checkBox -l "Lock middle" -cc asFitModeLockCenterJoints asLockCenterJoints;
				button -w 11 -l "?" -c "asHelpImage asFitPlacement";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Auto-Orient:";
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator -st none;
				button -w 156 -l FitMode -c asFitMode;
				button -w 11 -l "?" -c "asHelpImage asFitMode";
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 82 62 81 15;
				separator -st none;
				text -l "Or, manual:";
				button -w 72 -l "Update Now" -c asFitModeManualUpdate;
				button -w 11 -l "?" -c "asHelpImage asFitUpdateNow";
				setParent..;
			separator;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asBodyBuildFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2;
				separator -w 120 -st none;
				checkBox -l "ReBuild Connections" -v 1 asRebuildConnections;
				setParent..;
			rowLayout -nc 4 -cw4 5 85 5 100;
				separator -w 5 -st none;
				button -l "Toggle Fit/Adv" -c asToggleFitAdvancedSkeleton asToggleFitSkeletonButton;
				separator -w 5 -st none;
				button -l "Build AdvancedSkeleton" -c asReBuildAdvancedSkeleton asBuildAdvancedSkeletonButton;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option1)" asBodyDeform1FrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2 -cw2 229 15;
				text -l "Skinning:";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinning";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				columnLayout;
					text -l "Select objects to deform, then:";  
					separator -h 5 -st none;
					button -w 140 -l "+ Select DeformJoints" -c asSelectDeformJoints;
					separator -h 5 -st none;
					button -w 140 -l "Set Smooth Bind Options" -c asSetSmoothBindOptions;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option2)" asBodyDeform2FrameLayout;
		columnLayout -adj 1;
			text -l "SkinCage:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinCage;
				button -w 60 -l "Delete" -c asDeleteSkinCage;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCage";
				setParent..;
			separator -st "none";
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 SkinCageCurvesSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 SkinCageCurvesSet";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageMirror";
				setParent..;
			separator -h 5 -st "none";
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select objects to deform, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Copy weights" -c asCopySkin;
					button -w 11 -l "?" -c "asHelpImage asDeformSkinCageCopyWeights";
					setParent..;
				setParent..;
			text -l "advanced:";
			separator -h 5 -st none;
			rowLayout -nc 2 -cw2 228 15;
				button -l " Move red SkinCurves to \"DeformationWidth\"" -c asSkinCurvesToWidth;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDWidth";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Sliders:";
				button -w 60 -l "Create" -c asCreateSliders;
				button -w 60 -l "Delete" -c asDeleteSliders;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageSliders";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Delete SkinCurves" -c asDeleteSkinCurves;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDeleteCurves";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option3)" asBodyDeform3FrameLayout;
		columnLayout -adj 1;
			text -l "SubWrap:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinSub;
				button -w 60 -l "Delete" -c asDeleteSkinSub;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapCage";
				setParent..;
			separator -h 5 -st none;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				text -l "Select objects to deform, then:";  
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Wrap selected mesh" -c asWrapSkin;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapWrap";
				setParent..;
			separator;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Detach" -c asSkinSubDetach;
				button -w 60 -l "Attach" -c asSkinSubAttach;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapAttach";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Exclude selected vertices" -c asWrapExlude;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapExlude";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option4)" asBodyDeform4FrameLayout;
		columnLayout -adj 1;
			text -l "SkinLoops:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select EdgeLoop + FK control, then";
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				separator;
				checkBox -v 1 -l "mirror" asCreateSkinLoopCheckBox;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Create New SkinLoop" -c "asCreateSkinLoop 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCreate";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Select All SkinLoops" -c asSelectAllSkinLoops;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsSelectAll";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select objects to deform, then:"; 
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Bind" -c "asBindSkinLoops 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsBind";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "For cloth over skin, copy weighs.\nSelect cloth, then:"; 
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Copy" -c "asCopySkinLoopWeights";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCopy";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select objects to CutUp, then:"; 
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "CutUp:";
				button -w 60 -l "Create" -c "asBindSkinLoops 1";
				button -w 60 -l "Delete" -c asDeleteCutUp;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCutUp";
				setParent..;
			separator -w 242 -h 5;
			setParent..;
		setParent..;
		frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (DeltaMush)" asBodyDeformDeltaMushFrameLayout;
			columnLayout -adj 1;
				text -l "Delta-Mush:";
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select skinned objects, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Harden weights" -c asHardenWeights;
					button -w 11 -l "?" -c "asHelpImage asDeformDeltaMushHarden";
					setParent..;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Apply Delta Mush" -c asApplyDeltaMush;
					button -w 11 -l "?" -c "asHelpImage asDeformDeltaMushApply";
					setParent..;
			if (`asMayaVersionAsFloat`>=2016)
				{
				rowLayout -nc 3 -cw3 80 165 15;
					separator;
					checkBox -l "use wbDeltaMush" wbDeltaMush;
					setParent..;
				}
				rowLayout -nc 3 -cw3 80 165 15;
					separator;
					text -l "Plugin by: Webber Huang\n<xracz.fx@gmail.com>";
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Skeleton)" asBodyGeometrySkeletonFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateSkeleton;
				button -w 60 -l "Delete" -c asDeleteSkeleton;
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Skeleton 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Skeleton 0";
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonMirror";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (PolyBoxes)" asBodyGeometryPolyBoxesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreatePolyBoxes;
				button -w 60 -l "Delete" -c asDeletePolyBoxes;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Boxes 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Boxes 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Boolean:";
				button -w 60 -l "Create" -c asCreateBoolean;
				button -w 60 -l "Delete" -c asDeleteBoolean;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesBoolean";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Warp:";
				button -w 60 -l "Create" -c asCreateWarp;
				button -w 60 -l "Delete" -c asDeleteWarp;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesWarp";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Mannequin)" asBodyGeometryMannequinFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateMannequin;
				button -w 60 -l "Delete" -c asDeleteMannequin;
				button -w 11 -l "?" -c "asHelpImage asGeometryMannequinCreate";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Motion Capture" asBodyMotionCaptureFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Skeleton:";
				button -w 60 -l "Create" -c asCreateMoCap;
				button -w 60 -l "Delete" -c asDeleteMocap;
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "FK/IK:";
				button -w 60 -l "Set All FK" -c asSetAllFK;
				button -w 60 -l "Default" -c "asGoToBuildPose bodySetup";
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureAllFK";
				setParent..;
			rowLayout -nc 5 -cw5 60 60 38 64 15;
				text -l "Bvh file:";
				button -w 60 -l "Read" -c asReadBVH;
				floatField -w 38 -v 120 -pre 1 -ann "set frames per second (in bvh file)" asBVHfps;
				button -w 60 -l "Delete" -c asDeleteBHV;
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureReadBvh";
				setParent..;
			separator;
			rowLayout -nc 4 -cw4 60 60 38 100;
				separator -st none;
				columnLayout;
					text -l "Then constrain the Bvh skeleton,";
					text -l "to the MoCap skeleton.";
					separator -h 5 -st none;
					text -l "Or try auto-connect";
					setParent..;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st none;
				button -w 60 -l "Connect" -c asAutoMapMocap;
				button -w 60 -l "Disconnect" -c asDeleteMocapMap;
				button -w 11 -l "?" -c "asHelpImage asMotionCaptureConnect";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Curves" asBodyControlCurvesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 ControlSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 ControlSet";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Scale:";
				floatField -v 1 -ann "set scale-factor" ScaleCCFloatField;
				button -w 60 -l "Scale" -c "asScaleControlCurves";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesScale";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Swap:";
				text -l "First select Control(s) to replace,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then select (add) any custom curve,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st "none";
				button -w 162 -l "Swap Curve" -c asSwapCurve;
				button -w 11 -l "?" -c "asHelpImage asControlCurvesSwap";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Partial Joints" asBodyPartialJointsFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 3 -cw3 60 100 100;
				separator;
				button -w 60 -l "Create" -c asCreatePartialJoints;
				button -w 60 -l "Delete" -c asDeletePartialJoints;
				setParent..;
			setParent..;
		setParent..;

	setParent..;

setParent..;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Face" asFaceFrameLayout;
columnLayout -adj 1;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Pre" asFacePrepFrameLayout;
		columnLayout -adj 0;
			button -l "Create Face FitSkeleton Node" -c asCreateFaceFitSkeleton;
			rowLayout -nc 2 -cw2 130 15;
				text -l "Then move and scale this:";
				button -w 15 -l "?" -c "asHelpImage fitFaceSkeletonNode";
				setParent..;
			text -l "lower circle just under the character`s jaw";
			text -l "upper circle just above the character`s head";
			separator -h 10;
			text -l "Choose Geometry";
			text -l " * = Optional";
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "Face" -c "asChooseInput asFaceGeometryTextField";
				textField -w 100 -ed 0 -tx $geometry asFaceGeometryTextField;
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "All Head" -c "asChooseInput asFaceAllFaceGeoTextField";
				textField -w 100 -ed 0 -tx $allFaceGeoString asFaceAllFaceGeoTextField;
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "Left Eye" -c "asChooseInput asFaceEye_LTextField";
				textField -w 100 -ed 0 -tx $eyeL asFaceEye_LTextField;
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "Right Eye" -c "asChooseInput asFaceEye_RTextField";
				textField -w 100 -ed 0 -tx $eyeR asFaceEye_RTextField;
				setParent..;
			separator -h 7 -st none;
			rowLayout -nc 3 -cw3 120 100 10;
				button -w 120 -l "Upper Teeth" -c "asChooseInput asFaceUpperTeethTextField";
				textField -w 100 -ed 0 -tx $upperTeeth asFaceUpperTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw3 120 100 10;
				button -w 120 -l "Lower Teeth" -c "asChooseInput asFaceLowerTeethTextField";
				textField -w 100 -ed 0 -tx $lowerTeeth asFaceLowerTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw3 120 100 10;
				button -w 120 -l "Tongue" -c "asChooseInput asFaceTongueTextField";
				textField -w 100 -ed 0 -tx $tongue asFaceTongueTextField;
				text -l "*";
				setParent..;
			separator -h 10;
			checkBox -m 1 -l advanced -onc "columnLayout -e -m 1 asFaceAdvancedinputColumnLayout" -ofc "columnLayout -e -m 0 asFaceAdvancedinputColumnLayout";
			columnLayout -m 0 asFaceAdvancedinputColumnLayout;
				separator -h 15;
				text -l "This section is for using FaceSetup with\nrigs not generated with AdvancedSkeleton.";
				separator -h 5;
				rowLayout -nc 2 -cw 1 120;
					button -w 120 -l "Choose Head Joint" -c "asChooseInput asFaceHeadJointTextField";
				textField -w 100 -ed 0 -tx $headJoint asFaceHeadJointTextField;
					setParent..;
				text -l "SkinCluster found on Face Geo:";
				textField -w 150 -m 1 -tx $skinCluster asFaceSkinClusterTextField;
				setParent..;

			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asFaceFitFrameLayout;
		columnLayout -adj 0;
		$checkValue=`objExists FaceFitEyeBall`;
		rowLayout -nc 4 -cw4 100 5 20 15;
			button -w 100 -l EyeBall -c asBuildFitEyeBall;
			separator -w 5 -st none;
			checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc "asFaceDeleteFromCheckBox EyeBall" asFaceFitEyeBall;
			button -w 15 -l "?" -c ("asHelpImage fitFaceEyeBall");
			setParent..;
		separator -st none -h 10;
		text -l "Select edgeLoops, then:";
		string $sections[]={"EyeLid","Lip","EyeBrow","JawPivot","JawCorner","Jaw","Throat","cheek","cheekRaiser","Nose","NoseUnder","noseCorner","Tongue"};
		string $parts[]={"Outer","Main","Inner"};
		int $upAndLo[]={1,1,0,0,0,0,0,0,0,0,0,0,0};
		int $mainAndOuter[]={1,1,1,0,0,0,0,0,0,0,0,0,0};
//		float $radiuss[]={0.4,2.0,1.0,1.0,1.0,2.0,2.0,2.0,2.0,2.0,1.0};
		int $isSphere[]={0,0,0,1,1,1,1,1,1,1,1,1,0};
		int $place2D[]={1,1,1,1,1,1,1,1,1,1,1,1,0};
		for ($c=0;$c<size($sections);$c++)
			{
			if ($c==1)
				separator -st none -h 10;
			if ($c==2)
				{
				separator -st none -h 10;
				text -l "Select edges, then:";
				}
			if ($c==3)
				{
				separator -st none -h 10;
				text -l "Select vertex, then:";
				}
			if ($c==12)
				{
				separator -st none -h 10;
				text -l "*Optional";
				text -l "(No selection needed)";
				}
			for ($a=0;$a<size($parts);$a++)
				{
				if ($mainAndOuter[$c]==0) $parts[$a]="";
				else $parts={"Outer","Main","Inner"};
				if ($sections[$c]=="EyeBrow" && $parts[$a]=="Inner")
					continue;
				if ($mainAndOuter[$c]==0 && $a>0)
					continue;
				$checkValue=`objExists ("FaceFit"+$sections[$c]+$parts[$a])`;
				rowLayout -nc 6 -cw6 100 5 20 15 10 80;
					button -w 100 -l ($sections[$c]+$parts[$a]) -c ("asCreateFaceFit "+$sections[$c]+" \""+$parts[$a]+"\" "+$upAndLo[$c]+" "+$mainAndOuter[$c]+" "+$isSphere[$c]);
					popupMenu;
						menuItem -l "re-select" -c ("asFaceReSelect "+$sections[$c]+" \""+$parts[$a]+"\"");//since $parts can be blank
					separator -w 5 -st none;
					checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$sections[$c]+$parts[$a]) ("asFaceFit"+$sections[$c]+$parts[$a]);
					button -w 15 -l "?" -c ("asHelpImage fitFace"+$sections[$c]+$parts[$a]);
					separator -w 10 -st none;
					if ($parts[$a]=="Inner")
						button -l "assist" -c ("asFaceAssist "+$sections[$c]);
					setParent..;
				}
			}
		text -l "Then place the Tongue locators";
		separator -h 18 -w 242;
			columnLayout;
				optionMenu asFaceEyeBrowsStyleOptionMenu;
					menuItem -l "realistic EyeBrows(sliding)";
					menuItem -l "cartoony EyeBrows(free)";
				$checkValue=`objExists FaceFitAnimateFit`;
				rowLayout -nc 4 -cw4 100 5 20 15;
					button -w 100 -l "Animate Fit" -c asAnimateFaceFit;
					separator -w 5 -st none;
					checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc "asFaceDeleteFromCheckBox AnimateFit" asFaceFitAnimateFit;
					button -w 15 -l "?" -c "asHelpImage fitFaceAnimateFit";
					setParent..;
				rowLayout -nc 2 -cw2 129 15;
					text -l "Tweak locator animation";
					button -w 15 -l "?" -c "asHelpImage fitFaceAnimate";
					setParent..;
				setParent..;
			setParent..;

		separator -w 242;
			columnLayout;
				$checkValue=`objExists FaceFitJawCurves`;
				rowLayout -nc 4 -cw4 100 5 20 15;
					button -w 100 -l "Jaw Curves" -c asFaceFitJawCurves;
					separator -w 5 -st none;
					checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc "asFaceDeleteFromCheckBox JawCurves" asFaceFitJawCurves;
					button -w 15 -l "?" -c "asHelpImage fitFaceJawCurves";
					setParent..;
				rowLayout -nc 2 -cw2 129 15;
					text -l "Tweak curves";
					button -w 15 -l "?" -c "asHelpImage fitFaceJawCurvesTweak";
					setParent..;
			setParent..;

		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asFaceBuildFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 25 60 35 100 asFaceRebuildKeepBSRowLayout;
				separator -w 25 -st none;
				button -m 0 -w 60 -l "Delete Adv" -c asDeleteAdvancedFace asDelteAdvFaceButton;
				separator -w 35 -st none;
				checkBox -m 0 -l "Keep BlendShapes" -v 1 asFaceKeepBlendShapes;
				setParent..;
			rowLayout -nc 4 -cw4 5 85 20 100;
				separator -w 5 -st none;
				button -l "Toggle Fit/Adv" -c asToggleFitFace asToggleFitFaceButton;
				separator -w 20 -st none;
				button -l "Build AdvancedFace" -c "$stepBuild=0;asBuildAdvancedFace" asBuildAdvancedFaceButton;
				setParent..;
			setParent..;
		setParent..;

	string $stepBuildText[];
	$stepBuildText[size($stepBuildText)]="";
	$stepBuildText[size($stepBuildText)]="Prep";
	$stepBuildText[size($stepBuildText)]="CtrlBox";
	$stepBuildText[size($stepBuildText)]="FaceTargets";
	$stepBuildText[size($stepBuildText)]="EyeBall";
	$stepBuildText[size($stepBuildText)]="EyeLid";
	$stepBuildText[size($stepBuildText)]="EyeBrow - detect";
	$stepBuildText[size($stepBuildText)]="EyeBrow - Cutout";
	$stepBuildText[size($stepBuildText)]="EyeBrow - NCloth prep";
	$stepBuildText[size($stepBuildText)]="EyeBrow - NCloth Sim";
	$stepBuildText[size($stepBuildText)]="Lip - detect";
	$stepBuildText[size($stepBuildText)]="Lip";
	$stepBuildText[size($stepBuildText)]="Jaw";
	$stepBuildText[size($stepBuildText)]="StickyLips";
	$stepBuildText[size($stepBuildText)]="ZipperLips";
	$stepBuildText[size($stepBuildText)]="Chin";
	$stepBuildText[size($stepBuildText)]="EyeRegion";
	$stepBuildText[size($stepBuildText)]="Smile";
	$stepBuildText[size($stepBuildText)]="Frown";
	$stepBuildText[size($stepBuildText)]="CheekRaiser";
	$stepBuildText[size($stepBuildText)]="Cheek&Mouth shapes";
	$stepBuildText[size($stepBuildText)]="Tongue";
	$stepBuildText[size($stepBuildText)]="Squint";
	$stepBuildText[size($stepBuildText)]="ConnectBlendShapes";
	$stepBuildText[size($stepBuildText)]="BrowSetup";
	$stepBuildText[size($stepBuildText)]="Finish";

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build ..." asFaceStepBuildFrameLayout;
		columnLayout -adj 0;
			text -l "Step Build:";
			text -fn $boldFont -l "Use this section if normal Build had errors,";
			text -fn $boldFont -l "or to modify the build result.";
			separator -h 5;
			for ($i=1;$i<size($stepBuildText);$i++)
				{
				rowLayout -nc 2 -cw2 159 80 ("asStepBuildRowLayout"+$i);
					text -l ($i+" : "+$stepBuildText[$i]) ("stepBuild"+$i+"Text");
					button -w 80 -h 15 -l "Build" -c ("$stepBuild="+$i+";asBuildAdvancedFace;");
					setParent..;

				if ($stepBuildText[$i]=="EyeBall")
					text -l "   You can now test eye rotation.";

				if ($stepBuildText[$i]=="EyeLid")
					{
					rowLayout -nc 2 -cw2 200 80;
						text -l "   Now should have selection like this:";
						button -w 15 -h 12 -l "?" -c "asHelpImage asStepBuildEyeLid";
						setParent..;
					separator -h 5;
					rowLayout -nc 2 -cw2 180 80;
						text -l "   If not, make correct selection, then:";
						button -w 40 -h 12 -l "update" -c "sets -clear eyeLidVtxs;sets -add eyeLidVtxs `ls -sl`;print \"// Updated\\n\"";
						setParent..;
					text -l "   You can now also test blink & fleshy-eye.";
					}
				if ($i==6)
					{
					rowLayout -nc 2 -cw2 200 80;
						text -l "   Now should have curves like this:";
						button -w 15 -h 12 -l "?" -c "asHelpImage asStepBuildEyeBrowCurves";
						setParent..;
					}
				if ($i==7)
					{
					rowLayout -nc 2 -cw2 200 80;
						text -l "   Now should have object like this:";
						button -w 15 -h 12 -l "?" -c "asHelpImage asStepBuildEyeBrowObject";
						setParent..;
					separator -h 5;
					rowLayout -nc 2 -cw2 180 80;
						text -l "   If not, adjust the curves, and run this step again";
						setParent..;
					}
				if ($i==8)
					{
//					separator -w 240;
					text -l "   You can now test the NCloth (foreHead).";
					text -l "   And tweak any nCloth settings, if needed.";
					}
				if ($i==10)
					{
					text -l "   Lip vertices should now be selected.";
					text -l "   If selection is not correct,";
					rowLayout -nc 2 -cw2 180 80;
						text -l "          then select Lip vertices, and:";
						button -w 40 -h 12 -l "update" -c "sets -clear lipArea;sets -add lipArea `ls -sl`;print \"// Updated\\n\"";
						setParent..;
					}
				if ($i==11)
					text -l "   You can now test lip controllers.";
				if ($i==12)
					{
					text -l "   Scrub time-slider to check Jaw.";
					text -l "      Edit curves to define Jaw-deformation";
					rowLayout -nc 2 -cw2 200 80;
						text -l "      Edit softMod to define MouthShape";
						button -w 15 -h 12 -l "?" -c "asHelpImage asStepBuildLipShape";
						setParent..;
					rowLayout -nc 2 -cw2 180 80;
//						separator;
						text -l "                                       After edit:";
						button -w 40 -h 12 -l "update" -c "asWeightLips JawOpenRegion;asFaceUpdateJawWeightsFromCurves JawOpenRegion;print \"// Updated\\n\"";
						setParent..;
					}
				if ($i==14)
					{
					text -l "      You can edit the SofMod,";
					text -l "      to design the zipperLips";
					}
				if ($i==16)
					{
					text -l "      You can design Smile, with the controllers";
					}
				separator -w 240;
				}
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeBrows" asFaceBrowsFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 2 -cw2 20 100;
				separator -st none -w 15;
				columnLayout;
					text -l "Select EyeBrows, then:";
					separator -h 5;
					button -w 150 -l "WireDeform to face" -c "asFaceWireDeformToFace";
					text -l "or:";
					button -w 150 -l "WrapDeform to face" -c "asFaceWrapDeformToFace";
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeLashes" asFaceLashesFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 2 -cw2 20 100;
				separator -st none -w 15;
				text -l "Select EyeLashes, then:";
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "SkinBind" -c "asFaceSkinEyeLashes";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " HeadSquash" asFaceSquashFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Create HeadSquash" -c "asAdvancedSquash";
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Optimize HeadSquash" -c "asOptimizeSquash";
				setParent..;
			text -fn $boldFont -l "To make sure only head";
			text -fn $boldFont -l "and no other parts of body gets squashed";
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Rubber-Face" asFaceRubberFaceFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2 -cw2 20 100;
				text -w 15 -l "1:";
				button -w 150 -l "Create Placement Locator" -c "asFaceCreatePlacementLocator 0 \"\"";
				setParent..;
			rowLayout -nc 2 -cw2 20 100;
				text -w 15 -l "2:";
				text -l "Place the locator";
				setParent..;
			rowLayout -nc 2 -cw2 20 100;
				text -w 15 -l "3:";
				button -w 150 -l "Create Rubber Control" -c asFaceCreateRubberControl;
				setParent..;
			rowLayout -nc 2 -cw2 20 100;
				text -w 15 -l "4:";
				text -w 211 -l "Test control and \"Falloff-Radius\" attribute";
				setParent..;
			rowLayout -nc 2 -cw2 20 100;
				text -w 15 -l "5:";
				button -w 150 -l "Save \"Falloff-Radius\" value" -c asFaceSaveRubberFalloff;
				setParent..;
			separator -h 5;
			rowLayout -nc 2 -cw2 20 100;
				separator -st none -w 15;
				button -w 150 -l "Mirror Rubber Control" -c asFaceMirrorRubberControl;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Edit-Regions" asFaceEditRegionsFrameLayout;
		rowLayout -nc 2 -cw2 15 500;
			separator;
		columnLayout;
			rowLayout -nc 2 -cw2 209 18;
				text -l "  Show Region:";
				button -w 11 -l "?" -c "asHelpImage asShowRegion";
				setParent..;
			button -w 100 -l "Normal" -c "showRegion Normal";
			separator -h 5;
			button -w 100 -l "EyeLid" -c "showRegion EyeLid";
			button -w 100 -l "Lip" -c "showRegion Lip";
			button -w 100 -l "LipRotate" -c "showRegion LipRotate";
			button -w 100 -l "LipScale" -c "showRegion LipScale";
			button -w 100 -l "JawOpen" -c "showRegion JawOpen";
			button -w 100 -l "JawStickyLip" -c "showRegion JawOpenStickyLip";
			button -w 100 -l "Lips" -c "showRegion Lips";
			rowLayout -nc 2;
				separator -w 30 -st none;
				shelfButton -w 34 -h 34 -ann "Paint weights on smooth bound skins." -l "Paint Skin Weights Tool" 
	        -image "paintSkinWeights.png" 
	        -image1 "paintSkinWeights.png" 
	        -style "iconOnly" 
	        -c "ArtPaintSkinWeightsTool" ;
	       setParent..;

//			button -w 100 -l "Clusters" -c "showRegion Clusters";
			separator -w 220;
			separator -h 5;
			button -w 100 -l "Create Region" -c "asCreateRegion";
			setParent..;
		setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EditBlendShapes" asFaceEditBlendShapesFrameLayout;
		columnLayout -adj 1;
			text -l "Set controls to the shape for adjustment, then:";
			floatFieldGrp -v1 1.0 -cw2 65 50 -l "multiplier" asCreateTargetShapeMultiplier;
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "create blendShape target" -c "asBSAdjustTarget";
				separator -st none;
				button -h 18 -w 40 -l "reset" -c "asBSResetTarget";
				button -w 11 -l "?" -c "asHelpImage asEditBlendShapesCreate";
				setParent..;
			rowLayout -nc 2;
				separator -w 15 -st none;
				floatSlider -en 0 -w 130 -min 0 -max 1 -value 0 -step 0.1 asFaceBSFloatSlider;
				setParent..;
			rowLayout -nc 3 -cw3 15 162 18;
				separator -st none;
				text -l "Delete the targets when finished:";
				button -h 18 -w 40 -l delete -c "delete deleteThis";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				columnLayout -adj 0;
					text -l "Or step through ALL the BlendShape targets,";
					text -l "with the blendShapes wizard:";
					setParent..;
				setParent..;
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "start blendShapes wizard" -c "asBSWizard";
				separator -st none;
				button -en 0 -w 40 -l "next.." -c "asBSWizardNext" asBSWizardNextButton;
				button -w 11 -en 0 -l "?" -c "asHelpImage asBSWizardStep0" asBSWizardHelpButton;
				setParent..;
			rowLayout -nc 4 -cw4 15 30 140 50;
				separator -st none;
				text -en 0 -w 30 -l "0/37" asBSWizardStepText;
				text -en 0 -w 140 -l "..." asBSWizardObjAttrText;
				text -en 0 -w 50 -l "..." asBSWizardValueText;
				setParent..;
			rowLayout -nc 2 -cw2 15 200;
				separator -st none;
				button -w 150 -l "stop blendShapes wizard" -c "asBSWizardStop";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				text -l "Or extract All targets:";
				setParent..;
			rowLayout -nc 3 -cw3 15 211 15;
				separator;
				button -w 150 -l "extract All targets" -c "asBSExtractAll";
				button -w 11 -l "?" -c "asHelpImage asEditBlendShapesExtractAll";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				text -l "Or smooth all targets using DeltaMush:";
				setParent..;
			floatFieldGrp -v1 1.3 -cw2 65 50 -l "multiplier" asDeltaMushShapeMultiplier;
			rowLayout -nc 3 -cw3 15 211 15;
				separator;
				button -w 150 -l "DeltaMush All targets" -c "asBSDeltaMushAll";
				button -w 11 -l "?" -c "asHelpImage asDeltaMushAll";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " NewBlendShapes" asFaceNewBlendShapesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "Create New BlendShape" -c "asBSNewTarget";
				separator -st none;
				separator -st none;
				button -w 11 -l "?" -c "asHelpImage asCreateNewBlendShape";
				setParent..;
			setParent..;
			rowLayout -nc 3 -cw3 15 162 18;
				separator -st none;
				text -l "Delete the targets when finished:";
				button -h 18 -w 40 -l delete -c "delete deleteThis";
				setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " TweakControllers" asFaceTweakControlsFrameLayout;
		columnLayout -adj 0;

			rowLayout -nc 2;
				separator -w 25 -st none;
				button -w 190 -l "Toggle ClusterSetup" -c "asFaceToggleClusterSetup";
				setParent..;

			rowLayout;
				text -l "Create:";
				setParent..;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					if (`asMayaVersionAsFloat`>=2012)
						iconTextButton -w 35 -h 35 -i "softMod.png" -c SoftModTool;
					text -l "Create a softmod, then:";
					rowLayout -nc 2 -cw2 40 100;
						separator;
						checkBox -l "Middle Controller" asFaceIsMiddleControlCheckBox;
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Create Control from selected SoftMod" -c "asFaceConvertSoftModToControl 0";
						button -w 11 -l "?" -c "asHelpImage asTweakControllersCreate";
						setParent..;
					setParent..;
				setParent..;
			separator;
			rowLayout;
				text -l "Edit:";
				setParent..;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Paint weights for selected Control" -c asFacePaintControllerWeights;
						button -w 11 -l "?" -c "asHelpImage asTweakControllersPaint";
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Convert selected Control to SoftMod" -c asFaceConvertControlToSoftMod;
						button -w 11 -l "?" -c "asHelpImage asTweakControllersConvertToSoftMod";
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Convert SoftMod Back to Control" -c "asFaceConvertSoftModToControl 1";
						button -w 11 -l "?" -c "asHelpImage asTweakControllersConvertBackToControl";
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Mirror weights for selected Control" -c asFaceMirrorControllerWeights;
						button -w 11 -l "?" -c "asHelpImage asTweakControllersMirrorWeights";
						setParent..;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
/*
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " GameEngineSetup" asFaceGameEngineSetupFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Bake EyeSetup to BlendShapes";
						button -w 11 -l "?" -c "asHelpImage asNotYet";
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Convert ClusterDeformers to joints";
						button -w 11 -l "?" -c "asHelpImage asNotYet";
						setParent..;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
*/
		setParent..;
	setParent..;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Pose" asPoseFrameLayout;
columnLayout -adj 1;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Driving Systems" asBodyDrivingSystemsFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				columnLayout -adj 0;
					text -l "First make the pose to be driven";
					text -l "(e.g. folded wings, hand guesture..)";
					text -l "Then:";
					setParent..;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st none;
				button -w 162 -l"Create Driving System" -c asCreateDrivingSystem;
				button -w 11 -l "?" -c "asHelpImage asDrivingSystemsCreate";
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Right Click on any of these buttons,\nto access existing Driving Systems.";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15;
				separator -st none;
				button -w 50 -en (!$dsm) -l "Edit" -c asAutoFindAndEditDrivingSystem asEditDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Edit" asEditDrivingSystemsPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDeleteDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Delete" asDeleteDrivingSystemsPopupMenu;
				button -w 50 -en (!$dsm) -l "Graph" asGraphDrivingSystemsButton;
				popupMenu -pmc "asPopulateDrivingSystemsPopupMenu Graph" asGraphDrivingSystemsPopupMenu;
				button -w 11 -l "?" -c "asHelpImage asDrivingSystemsEdit";
				setParent..;
			separator -st none -h 20;
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				text -l "After editing pose, then:";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15 asDSEditChoicesRowLayout;
				separator -st none;
				button -w 50 -l "Apply" -c asDrivingSystemEditApply;
//				separator;
//				checkBox -v 1 -l "mirror" asDrivingSystemMirrorCheckBox;
				button -w 50 -l "Cancel" -c asDrivingSystemEditCancel;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Corrective Shapes" asBodyCorrectiveFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				columnLayout -adj 0;
					text -l "Go to pose to correct, then:";
					text -l "Select mesh to correct, then:";
					setParent..;
				setParent..;
			rowLayout -nc 2 -cw2 80 100;
				separator -st none;
				checkBox -v 1 -l "Angle Rotations" asCorrectiveAngleCheckBox;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st none;
				button -w 162 -en (!$csm) -l "Create Corrective Shape" -c asCreateCorrectiveShape asCreateCorrectiveButton;
				button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesCreate";
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				text -l "Right Click on any of these buttons,\nto access existing Corrective Shapes.";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15;
				separator -st none;
				button -w 50 -en (!$csm) -l "Edit" asEditCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Edit" asEditCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDeleteCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Delete" asDeleteCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Graph" asGraphCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Graph" asGraphCorrectiveShapesPopupMenu;
				button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesEdit";
				setParent..;
			separator -st none -h 20;
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				text -l "After sculpted shape, then:";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15 asCorrectiveEditChoicesRowLayout;
				separator -st none;
				button -l "Apply" -c asConnectCorrectiveShape;
				checkBox -v 1 -l "mirror" asCorrectiveMirrorCheckBox;
				button -l "Cancel" -c asCancelCorrectiveShape;
				setParent..;
			checkBox -l advanced -onc "columnLayout -e -m 1 asCorrectiveAdvancedColumnLayout" -ofc "columnLayout -e -m 0 asCorrectiveAdvancedColumnLayout";
			columnLayout -m 0 asCorrectiveAdvancedColumnLayout;
				separator -h 15 -st none;
				rowLayout -nc 2 -cw2 227 100;
					text -l "Bake Deformations to Corrective Shapes:";
					button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesBake";
					setParent..;
				rowLayout -nc 2;
					button -w 120 -l "Source" -c "textField -e -tx `ls -sl` asBakeToCorrective1TextField";
					textField -w 100 -ed 0 asBakeToCorrective1TextField;
					setParent..;
				rowLayout -nc 2;
					button -w 120 -l "Destination" -c "textField -e -tx `ls -sl` asBakeToCorrective2TextField";
					textField -w 100 -ed 0 asBakeToCorrective2TextField;
					setParent..;
				text -l "rotations:";
				rowLayout -nc 6;
					checkBox -l "+x" -v 1 asBakeX1CheckBox;
					checkBox -l "+y" -v 1 asBakeY1CheckBox;
					checkBox -l "+z" -v 1 asBakeZ1CheckBox;
					checkBox -l "-x" -v 1 asBakeX2CheckBox;
					checkBox -l "-y" -v 1 asBakeY2CheckBox;
					checkBox -l "-z" -v 1 asBakeZ2CheckBox;
					setParent..;
				text -l "Select FK controller, then:";
				button -w 120 -l "Bake" -c asBakeIntoCorrectiveShapes;
				setParent..;
			setParent..;
		setParent..;
	setParent..;
setParent..;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Tools" asToolsFrameLayout;
columnLayout -adj 1;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "SelectorDesigner" -c asSelectorDesigner;
		button -w 11 -l "?" -c "asHelpImage asSelectorDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "PoserDesigner" -c asPoserDesigner;
		button -w 11 -l "?" -c "asHelpImage asPoserDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "WalkDesigner" -c asWalkDesigner;
		button -w 11 -l "?" -c "asHelpImage asWalkDesigner";
		setParent..;
	setParent..;
setParent..;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Display" asDisplayFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "MotionSystem:";
			button -w 60 -l "Hide" -c "setAttr MotionSystem.v 0";
			button -w 60 -l "Show" -c "setAttr MotionSystem.v 1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joints:";
			button -w 60 -l "Hide" -c "asJointsVisibility 0";
			button -w 60 -l "Show" -c "asJointsVisibility 1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joint axis:";
			button -w 60 -l "Hide" -c "asDisplayRigRLA 0";
			button -w 60 -l "Show" -c "asDisplayRigRLA 1";
			setParent..;
		rowLayout -nc 2 -cw2 73 100;
			text "Joint Size:";
			floatSliderGrp -cw2 35 130 -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			separator;
			button -w 150 -l "Select jointLayer" -c "select jointLayer;AttributeEditor";
			setParent..;
		setParent..;
	setParent..;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Optimize" asOptimizeFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete Unused Nodes" -c "hyperShadePanelMenuCommand(\"\", \"deleteUnusedNodes\");print \"// Unused nodes deleted.\\n\"";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Remove Unused Influences" -c asRemoveAllUnusedInfluences;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Prune Clusters" -c asPrunAllClusters;
			setParent..;
		setParent..;
	setParent..;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Publish" asPublishFrameLayout;
	columnLayout -adj 0;
		rowLayout -nc 3 -cw3 73 165 15;
			separator -st none;
			button -w 140 -l "Set DisplayLayers to \"R\"" -c asSetDisplayLayersToR;
			setParent..;
		rowLayout -nc 3 -cw3 73 165 15;
			separator -st none;
			button -w 140 -l "Set Joints to hidden" -c "asJointsVisibility 0";
			setParent..;
		rowLayout -nc 3 -cw3 73 165 15;
			separator -st none;
			button -w 140 -l "Go to Build Pose" -c "asGoToBuildPose bodySetup;if (`objExists FaceControlSet`)asGoToBuildPose faceSetup;";
			setParent..;
		separator -st none -h 10;
		rowLayout -nc 3 -cw3 73 165 15;
			separator -st none;
			button -w 140 -l "Publish" -c asPublish;
			button -w 11 -l "?" -c "asHelpImage asPublish";
			setParent..;
		setParent..;
	setParent..;

frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Demo" asDemoFrameLayout;
	rowLayout -nc 2;
		separator -w 15 -st none;
		columnLayout;
			text -l "Open a AdvancedSkeleton Example Rig:";
			rowLayout -nc 3;
				optionMenu asDemoOptionMenu;
				separator -w 15 -st none;
				button -l "Open" -c asOpenDemoFile;
				setParent..;
			setParent..;
		setParent..;
	setParent..;

frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "About" asAboutFrameLayout;
columnLayout -adj 1;
	image -h 83 -i ($asScriptLocation+"/AdvancedSkeleton5Files/icons/asLogo.png") asHelpImage;
	if (`asIsMayaLT`)
		text -l "\nNote:\nRunning Maya LT,\n so not all AdvancedSkeleton features enabled.\n";
	button -l "visit AdvancedSkeleton website" -c "showHelp -a \"http://www.animationstudios.com.au/advancedskeleton\"";
	separator -h 15;
	if (`asMayaVersionAsFloat`>=2012)
		{
		rowLayout -nc 3 -cw3 60 50 100;
			text -l " Window:";
			button -c "asDockWindow 1" -l " Dock ";
			button -c "asDockWindow 0" -l " UnDock ";
			setParent..;
		}
	separator -h 15;
	rowLayout -nc 5 -cw5 110 30 40 54 15;
		button -l "Check For Updates" -c asCheckForUpdates;
		text -l "found:";
		text -m 1 -l "x.xxx" asUpdateFoundVersion;
		button -en 0 -l "Update" -c asUpdateVersion asUpdateVersionButton;
		button -w 11 -l "?" -c "asHelpImage asAboutUpdate";
		setParent..;
	checkBox -m 0 -v 0 asBetaCheckBox;
	separator -h 15;
	rowLayout -nc 3 -cw3 80 158 15;
		text -l "current version:";
		button -l `asGetScriptVersionAsString` -c "print \"// right click on button to change version\"";
			popupMenu asVersionsPopupMenu;
		button -w 11 -l "?" -c "asHelpImage asAboutCurrentVersion";
		setParent..;
	separator -h 5;
	columnLayout -adj 0;
		text -l "For support, go to:\nwww.facebook.com/AdvancedSkeleton\nOr email: support@animationstudios.com.au\n\nFor license information, read the eula.txt file.";
		setParent..;
	setParent..;
setParent..;
setParent..;
setParent..;
rowLayout -nc 2 -cw2 120 100 asRowLayout;
columnLayout;
	rowLayout -nc 5 -cw5 30 90 10 30 90;
		text -l "body:" asBodyText;
		button -c "asGoToBuildPose bodySetup" -l "Go to Build Pose";
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose bodySetup";
		separator -w 10 -st none;
		text -l "face:" asFaceText;
		button -c "asGoToBuildPose faceSetup" -l "Go to Build Pose" asGoToBuildPoseFaceButton;
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose faceSetup";
		setParent..;
	setParent..;
formLayout -e
	-af asScrollLayout "right" 0
	-af asScrollLayout "left" 0
	-af asScrollLayout "top" 0
	-ac asScrollLayout "bottom" 0 asRowLayout
	-af asRowLayout "bottom" 0
	asFormLayout;
if($asDock)
	{
	dockControl -l AdvancedSkeleton -w 296 -fl 0 -floatChangeCommand asDockWindowChangeFloatingState -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
	evalDeferred "dockControl -e -r AdvancedSkeletonDockControl;";
	}
else
	showWindow;
asUpdateLabelHelp;
asUpdateAttributeHelp;
asFitSkeletonConnectControl;
asUpdateButtonEnables;
if (`window -q -ex AdvancedSkeletonWindow`)
	{
	window -e -w 296 AdvancedSkeletonWindow;
	if (`asMayaVersionAsFloat`<2012)
		window -e -w 309 AdvancedSkeletonWindow;
	if (!`windowPref -q -ex AdvancedSkeletonWindow`)
		window -e -h 500 AdvancedSkeletonWindow;
	}
if ($asFaceIsResetting)
	$asFaceIsResetting=0;
else
	asFaceUpdateInfo 1;

//update UI from optionVars
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
    if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
        if (`optionVar -ex $framLayouts[$i]`)
            frameLayout -e -cl `optionVar -q $framLayouts[$i]` $framLayouts[$i];

//populate fitSkeletonFiles optionMenu
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletons/";
string $fitSkeletonFiles[]=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asFitFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}

//populate Demo optionMenu
string $exampleFoldersDir=$asScriptLocation+"/AdvancedSkeleton5Files/exampleFiles/";
string $exampleFolders[]=`getFileList -fld $exampleFoldersDir`;
setParent -menu asDemoOptionMenu;
for ($i=0;$i<size($exampleFolders);$i++)
	{
	string $exampleFile=$exampleFoldersDir+$exampleFolders[$i]+"/"+$exampleFolders[$i]+".mb";
	if (`file -q -ex $exampleFile`)
		menuItem -l $exampleFolders[$i];
	}

$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
$fitSkeletonFiles=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asLimbFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}

//Exist EditDrivingSystemMode (if stuck)
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;

//Set 0.2 jointDisplayScale if first run of AdvancedSkeleton
if (!`optionVar -ex asBodyFrameLayout`)
	jointDisplayScale 0.2;

//populate asVersionsPopupMenu
string $oldVersionsDir=$asScriptLocation+"/AdvancedSkeleton5Files/oldVersions/";
int $latestLocal;
setParent -menu asVersionsPopupMenu;
string $oldVersions[];
if (`file -q -ex $oldVersionsDir`)
	$oldVersions=`getFileList -fld $oldVersionsDir`;
$oldVersions=`sort $oldVersions`;
for ($i=size($oldVersions);$i>-1;$i--)
	{
	if ($i==size($oldVersions))
		{
		$label=`asGetLatestLocalVersionAsString`;
		$latestLocal=1;
		}
	else
		{
		$label=$oldVersions[$i];
		$latestLocal=0;
		}
	$label=`substitute "AdvancedSkeleton_v" $label ""`;
	menuItem -l $label -c ("asSourceVersion \""+$label+"\" "+$latestLocal);
	}

//Maya less than2012 limitations
if (`asMayaVersionAsFloat`<2012)
	frameLayout -e -m 0 asFaceTweakControlsFrameLayout;

//Maya LT limitations
if (`asIsMayaLT`)
	{
	frameLayout -e -en 0 asBodyDeform2FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDeform3FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDrivingSystemsFrameLayout;//no sdk
	frameLayout -e -en 0 asFaceFrameLayout;//no nCloth
	}
progressBar -e -ep $gMainProgressBar;
}

global proc asScriptLocatorProc (){}

global proc string asGetScriptLocation ()
{
string $whatIs=`whatIs asScriptLocatorProc`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder-1)`;
return $scriptLocation;
}

global proc float asGetScriptVersion ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton5.mel";
float $version=`asGetScriptVersionFromFile $file`;
return $version;
}

global proc string asGetScriptVersionAsString ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton5.mel";
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
return $versionAsString;
}

global proc float asGetScriptVersionFromFile (string $file)
{
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
float $version=$versionAsString;
return $version;
}

global proc string asGetScriptVersionFromFileAsString (string $file)
{
string $versionString;
string $tempString[];
int $lineNr;
if (`file -q -ex $file`)
	{
	int $fileId=`fopen $file "r"`;
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$lineNr++;
		$nextLine = `fgetline $fileId`;
		if (`gmatch $nextLine "*Version*"`)
			{
			tokenize $nextLine $tempString;
			tokenize $tempString[2] "[.]" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				$versionString+=$tempString[$i];
				if ($i==0)
					$versionString+=".";
				}
//			$version=$versionString;
			}
		if($lineNr>10)
			break;
		}
	fclose $fileId;
	}
else
	warning "Unable to determine AdvancedSkeleton version number";
return $versionString;
}

global proc asSourceVersion (string $versionAsString, int $latestLocal)
{
global string $gShelfTopLevel;
int $sucess;
string $buttons[];

string $asFile,$iol,$image;
string $latestLocalScriptLocation=`asGetLatestLocalScriptLocation`;
if ($latestLocal)
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton5.mel";
else
	{
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton5Files/oldVersions/AdvancedSkeleton_v"+$versionAsString+"/AdvancedSkeleton5.mel";
	$iol=$versionAsString;
	if (!`file -q -ex $asFile`)
		{
		warning ("attempted to source version: "+$versionAsString+", but could not find file:\""+$asFile+"\", so using latest installed version instead");
		optionVar -iv asUseVersionLatestLocal 1;
		return;
		}
	}

string $cmd="source \""+$asFile+"\";AdvancedSkeleton5;";
string $shelves[]=`tabLayout -q -ca $gShelfTopLevel`;
for ($i=0;$i<size($shelves);$i++)
	{
	$buttons=`layout -q -ca $shelves[$i]`;
	for ($y=0;$y<size($buttons);$y++)
		{
		string $ann=`shelfButton -q -ann $buttons[$y]`;
		if ($ann=="AdvancedSkeleton5")
			{
			$image=`shelfButton -q -i $buttons[$y]`;
			if ($iol=="")
				$image=`substitute "AS4version" $image "AS4"`;
			else
				$image=`substitute "AS4" $image "AS4version"`;
			shelfButton -e -c $cmd -iol $iol -i $image -i1 $image $buttons[$y];
			$sucess=1;
			}
		}
	}
if ($sucess)
	{
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		evalDeferred -lp ("deleteUI -control AdvancedSkeletonDockControl");
	else if (`window -q -ex AdvancedSkeletonWindow`)
	    evalDeferred -lp ("deleteUI AdvancedSkeletonWindow");
	print ("// Shelf button updated, Click on the button to launch choosen version of AdvancedSkeleton\n");
	}
}

global proc int asIsMayaLT ()
{
int $isMayaLT=0;
if (!`exists CreateWrap`)
	$isMayaLT=1;
return $isMayaLT;
}

global proc int asHaveMeshCenterSnap ()
{
int $haveSnap;
string $helpString=`help snapMode`;
string $tempString[];
tokenize $helpString $tempString;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]=="-meshCenter")
		$haveSnap=1;
return $haveSnap;
}

global proc asUpdateLabelHelp ()
{
string $type=`optionMenu -q -v asLabelType`;
string $help="";
if ($type=="Hand" || $type=="Shoulder")
	$help="Hand + Shoulder = Arm IK";
if ($type=="Hip" || $type=="Foot")
	$help="Hip + Foot = Leg IK";
if ($type=="LegAim")
	$help="LegAim + Hip + Foot = 3 bone Leg IK";
if ($type=="Heel" || $type=="Toes" || $type=="ToesEnd")
	$help="Ball + Heel + Toe = FootRoll";
if ($type=="BigToe" || $type=="PinkyToe")
	$help="BigToe + PinkyToe = FootRock";
if ($type=="Root" || $type=="Chest" || $type=="Mid")
	$help="Root + Chest (+ Mid) = Spine IK";
if ($type=="0" || $type=="1" || $type=="2" || $type=="3")
	$help="0,1,2, etc.. = Spline IK (tail)";


text -e -l $help asLabelHelp;
}

global proc asUpdateAttributeHelp ()
{
string $type=`optionMenu -q -v asAttributeType`;
string $help="";
if ($type=="twist/bendy")
	$help="TwistJoints & Bendy-limbs";
if ($type=="inbetween")
	$help="Creates extra inbetween joints";
if ($type=="global")
	$help="Keeps limbs orientation fixed";
if ($type=="aim")
	$help="LookAt (AimConstraint)";
if ($type=="wheel")
	$help="Wheel Roller";
if ($type=="freeOrient")
	$help="Free limb orientation";
if ($type=="worldOrient")
	$help="Orient limb to world-space";
if ($type=="flipOrient")
	$help="Reverse up-vector";
if ($type=="noMirror")
	$help="For non-symmetrical limbs";
if ($type=="noControl")
	$help="Skips creating FK-control";
if ($type=="geoAttach")
	$help="Controller sticks to geometry";

text -e -l $help asAttributeHelp;
}

global proc asFitResample ()
{
if (`window -q -ex asFitResample`)
	deleteUI asFitResample;
window -t Resample asFitResample;

int $numJoints=2;
string $allDescendents[],$tempString[];
string $selJoints[]=`ls -sl -type joint`;
string $startJoint=$endJoint="none";
if (size($selJoints)==1)
	{
	string $asFitJointIKInfo[]=`asFitJointIKInfo $selJoints[0]`;
	if ($asFitJointIKInfo[1]!="")
		$startJoint=$asFitJointIKInfo[1];
	if ($asFitJointIKInfo[3]!="")
		$endJoint=$asFitJointIKInfo[3];
	}
if (size($selJoints)==2)
	{
	$allDescendents=`listRelatives -ad $selJoints[0]`;
	if (`stringArrayCount $selJoints[1] $allDescendents`)
		{
		$startJoint=$selJoints[0];
		$endJoint=$selJoints[1];
		}
	$allDescendents=`listRelatives -ad $selJoints[1]`;
	if (`stringArrayCount $selJoints[0] $allDescendents`)
		{
		$startJoint=$selJoints[1];
		$endJoint=$selJoints[0];
		}
	}
//Find current $numJoints
if (`objExists $startJoint` && `objExists $endJoint` )
	{
	string $countJoint=$endJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`listRelatives -p $countJoint`;
		$countJoint=$tempString[0];
		if ($countJoint=="" || $countJoint==$startJoint)
			break;
		$numJoints++;
		}
	}

columnLayout -adj 1;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "StartJoint:" -ed 0 -tx $startJoint asFitResampleStartJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleStartJointtextFieldGrp";
	setParent..;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "EndJoint" -ed 0 -tx $endJoint asFitResampleEndJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleEndJointtextFieldGrp";
	setParent..;
intFieldGrp -v1 $numJoints -cw2 60 50 -l "joints" asFitResampleNumJoints;
button -l "ReSample" -c asFitResampleJoints;
showWindow asFitResample;
}

global proc asFitResampleJoints ()
{
global string $gSelect;
setToolTo $gSelect;
string $sel[]=`ls -sl`;
string $tempString[],$joints[],$parentJoints[];
string $newJoint;
string $startJoint=`textFieldGrp -q -tx asFitResampleStartJointtextFieldGrp`;
string $endJoint=`textFieldGrp -q -tx asFitResampleEndJointtextFieldGrp`;
int $numJoints=`intFieldGrp -q -v1 asFitResampleNumJoints`;
$tempString=`ls -l $endJoint`;
tokenize $tempString[0] "|" $parentJoints;
int $reachedStart=0;
for ($i=0;$i<size($parentJoints);$i++)
	{
	if ($parentJoints[$i]==$startJoint)
		$reachedStart=1;
	if ($reachedStart)
		$joints[size($joints)]=$parentJoints[$i];	
	}
if (!`objExists $startJoint`)
	error ("startJoint :\""+$startJoint+"\" does not exists");
if (!`objExists $endJoint`)
	error ("endJoint :\""+$endJoint+"\" does not exists");
if ($numJoints<2)
	error "Can not ReSample to less than 2";
if (!`stringArrayCount $startJoint $joints`)
	error ("endJoint:\""+$endJoint+"\" is not a child of startJoint:\""+$startJoint+"\"");
if ($startJoint==$endJoint)
	error "StartJoint and EndJoint can not be the same";

select $startJoint $endJoint;
$tempString=`ikHandle -sol ikSplineSolver -scv false -pcv false`;
duplicate -n tempIKCurve $tempString[2];
delete $tempString[0] $tempString[2];
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempIKCurveShape.worldSpace[0] tempPointOnCurveInfo.inputCurve;
select tempIKCurve;refresh;

int $startJointLocks[]=`asUnLockAttrs $startJoint`;
int $endJointLocks[]=`asUnLockAttrs $endJoint`;

float $startJointFat=1;
float $startJointFatY=1;
float $startJointFatZ=1;
float $endJointFat=1;
float $endJointFatY=1;
float $endJointFatZ=1;
if (`attributeExists fat $startJoint`) $startJointFat=`getAttr ($startJoint+".fat")`;
if (`attributeExists fatY $startJoint`) $startJointFatY=`getAttr ($startJoint+".fatY")`;
if (`attributeExists fatZ $startJoint`) $startJointFatZ=`getAttr ($startJoint+".fatZ")`;
if (`attributeExists fat $endJoint`) $endJointFat=`getAttr ($endJoint+".fat")`;
if (`attributeExists fatY $endJoint`) $endJointFatY=`getAttr ($endJoint+".fatY")`;
if (`attributeExists fatZ $endJoint`) $endJointFatZ=`getAttr ($endJoint+".fatZ")`;

$tempString=`listRelatives -p $startJoint`;
string $startJointParent=$tempString[0];
if ($startJointParent!="")
	parent -w $startJoint;
parent -w $endJoint;
float $radius=`getAttr ($startJoint+".radius")`;
rename $endJoint tempRename;
if (`objExists $joints[1]`) delete $joints[1];
string $parent=$startJoint;
string $newJointName=$joints[0];
if ($joints[0]=="Root")
	{
	createNode -n Spine transform;
	$newJointName="Spine";
	}
for ($i=1;$i<$numJoints-1;$i++)
	{
	select -cl;
	$newJoint=`joint -n $newJointName -rad $radius`;
	setAttr tempPointOnCurveInfo.parameter ((1.0/($numJoints-1))*$i);
	$pos=`getAttr tempPointOnCurveInfo.position`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $newJoint;
	parent $newJoint $parent;
	$parent=$newJoint;
	asEnsureFitJointAttrs $newJoint;
	setAttr ($newJoint+".fat") ($startJointFat+(($i/($numJoints-1.0))*($endJointFat-$startJointFat)));
	setAttr ($newJoint+".fatY") ($startJointFatY+(($i/($numJoints-1.0))*($endJointFatY-$startJointFatY)));
	setAttr ($newJoint+".fatZ") ($startJointFatZ+(($i/($numJoints-1.0))*($endJointFatZ-$startJointFatZ)));
	asFitModeUpdateJoints $newJoint 0;
	refresh;
	}
if ($joints[0]=="Root" && `objExists |Spine`) delete |Spine;
if (`objExists $endJoint`)
	rename $endJoint ($endJoint+"_2");
rename tempRename $endJoint;
parent $endJoint $parent;
if ($startJointParent!="")
	parent $startJoint $startJointParent;

asReLockAttrs $startJoint $startJointLocks;
asReLockAttrs $endJoint $endJointLocks;

asFitModeUpdateJoints $endJoint 0;
delete tempIKCurve;
if (`checkBox -q -ex asLockCenterJoints`)
	if (`checkBox -q -v asLockCenterJoints`)
		asFitModeLockCenterJoints;

print ("// Joints Resampled\n");
catchQuiet (`select $sel`);
}

global proc int[] asUnLockAttrs (string $obj)
{
int $lockedAttrs[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		$lockedAttrs[size($lockedAttrs)]=`getAttr -l ($obj+"."+$trs[$y]+$xyz[$z])`;
		setAttr -l 0 ($obj+"."+$trs[$y]+$xyz[$z]);
		}
return $lockedAttrs;
}

global proc asReLockAttrs (string $obj, int $lockedAttrs[])
{
int $attrNr=0;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		setAttr -l $lockedAttrs[$attrNr] ($obj+"."+$trs[$y]+$xyz[$z]);
		$attrNr++;
		}
}

global proc asFitResamplePick (string $textFieldGrp)
{
string $selJoints[]=`ls -sl -type joint`;
if (!size($selJoints))
	error "No joint selected";
textFieldGrp -e -tx $selJoints[0] $textFieldGrp;
}

global proc asAddFitJointLabel ()
{
string $labelType=`optionMenu -q -v asLabelType`;
string $sel[]=`ls -sl -type joint`;
int $labelCode;
for ($i=0;$i<size($sel);$i++)
	{
	setAttr ($sel[$i]+".drawLabel") 1;
	$labelCode=`asLabelCodeLookup $labelType 1`;
	setAttr ($sel[$i]+".type") $labelCode;
	if ($labelCode==18)
		setAttr -type "string" ($sel[$i]+".otherType") $labelType;
	}
}

global proc asRemoveFitJointLabel ()
{
string $sel[]=`ls -sl -type joint`;
for ($i=0;$i<size($sel);$i++)
	setAttr ($sel[$i]+".drawLabel") 0;
}

global proc string asLabelCodeLookup (string $labelCode, int $labelToCode)
{

string $result;
int $codes[]={0,1,2,4,18,10,12,15,16,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18};
string $labels[]={"None","Root","Hip","Foot","ToesEnd","Shoulder","Hand","PropA","PropB","PropC","Other","Chest","Mid","Toes","Heel","BigToe","PinkyToe","LegAim","Eye","Wheel","0","1","2","3"};

for ($i=0;$i<size($labels);$i++)
	{
	if ($labelToCode)
		if ($labels[$i]==$labelCode)
			return $codes[$i];
	if (!$labelToCode)
		if ($codes[$i]==$labelCode)
			return $labels[$i];
	}
return "";
}

global proc string asLabel (string $obj)
{
string $label;
if (size(`ls -ap $obj`)>1)
	error ("More than one object matches name: "+$obj+"\n");
if (!`objExists $obj`)
	return "AA";
if (!`attributeExists "type" $obj`)
	return "BB";
int $labelNum=`getAttr ($obj+".type")`;
if (!`getAttr ($obj+".drawLabel")`)
	return "";

$label=`asLabelCodeLookup $labelNum 0`;
if ($labelNum==18)
	{
	$label=`getAttr ($obj+".otherType")`;
	}

return $label;
}

global proc asAddFitJointAttribute ()
{
string $attr=`optionMenu -q -v asAttributeType`;
string $sel[]=`ls -sl`;
float $dv=1;
string $meshObject;
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]`)
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}
	if ($attr=="twist/bendy" && `attributeExists twistJoints $sel[$i]`)
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}

	if ($attr=="twist/bendy")
		{
		if (`attributeExists inbetweenJoints $sel[$i]`) error "\"inbetweenJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		addAttr -k 1 -ln "twistJoints" -at long -min 0 -max 10 -dv 2 $sel[$i];
		addAttr -k 1 -ln "bendyJoints" -at bool -dv 0 $sel[$i];
		//Update geo, if in FitMode
		global int $asFitModeScriptJobNr1;
		if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
			if (`checkBox -q -ex asVisGeo`)
				if (`checkBox -q -v asVisGeo`)
					asFitModeUpdateAllGeometry;
		}
	else if ($attr=="inbetween")
		{
		if (`attributeExists twistJoints $sel[$i]`) error "\"twistJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		if (`attributeExists bendyJoints $sel[$i]`) error "\"bendyJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		addAttr -k 1 -ln "inbetweenJoints" -at long -min 0 -dv 2 $sel[$i]; 
		addAttr -k 1 -ln "unTwister" -at bool -dv 0 $sel[$i];
		}
	else if ($attr=="global")
		addAttr -k 1 -ln $attr -at double -min 0 -max 10 -dv 0 $sel[$i];
	else if ($attr=="worldOrient")
		addAttr -k 1 -ln $attr -at "enum" -en "xUp:yUp:zUp:xDown:yDown:zDown:" -dv 0 $sel[$i];
	else if ($attr=="geoAttach")
		{
		for ($y=0;$y<size($sel);$y++)
			{
			string $tempString[]=`listRelatives -s $sel[$y]`;
			if ($tempString[0]!="")
				if (`objectType $tempString[0]`=="mesh")
					$meshObject=$sel[$y];
			}
		if (size($sel)<2 || $meshObject=="")
			error "Select both FitJoint AND Geometry to attach to";
		addAttr -k 1 -ln $attr -at "enum" -en `substituteAllString $meshObject ":" "__"` $sel[$i];
		select $sel[$i];
		}
	else
		addAttr -k 1 -ln $attr -at bool -dv $dv $sel[$i];
	}
}

global proc asRemoveFitJointAttribute ()
{
string $sel[]=`ls -sl -type joint`;
string $attr=`optionMenu -q -v asAttributeType`;
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]`)
		deleteAttr ($sel[$i]+"."+$attr);
	if ($attr=="twist/bendy" && `attributeExists "twistJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".twistJoints");
	if ($attr=="twist/bendy" && `attributeExists "bendyJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".bendyJoints");
	if ($attr=="inbetween" && `attributeExists "inbetweenJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".inbetweenJoints");
	if ($attr=="inbetween" && `attributeExists "unTwister" $sel[$i]`)
		deleteAttr ($sel[$i]+".unTwister");
	}
}

global proc asFitDisplayAxis (int $onOff)
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
string $tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $fitJoints[$i]`;
	string $child=$tempString[0];
	if ($child=="")
		continue;
	setAttr ($fitJoints[$i]+".displayLocalAxis") $onOff;
	}
}

global proc asFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr3;
string $sel[]=`ls -sl`;
int $onOff=1;
if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
	$onOff=0;
//asByPassSDK $onOff;
select -cl;
if ($onOff)
	{
	asFitModeManualUpdate;
	$asFitModeScriptJobNr1=`scriptJob -cu 1 -killWithScene -e SelectionChanged asFitModeSelectionChanged`;
	if (`objExists FitSkeleton`)
		$asFitModeScriptJobNr3=`scriptJob -cu 1 -killWithScene -ac FitSkeleton.s asFitModeUpdateScale`;
	headsUpDisplay -s 2 -b 0 -bs "medium" -l "FitMode" -lfs "large" HUDFitMode;
	print "// Entered FitMode\n";
	}
else
	{
	if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr1;
		$asFitModeScriptJobNr1=0;
		}
	if (`scriptJob -ex $asFitModeScriptJobNr3`  && $asFitModeScriptJobNr3!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr3;
		$asFitModeScriptJobNr3=0;
		}
	asFitModeSelectionChanged;
	if (`headsUpDisplay -ex HUDFitMode`)
		headsUpDisplay -rem HUDFitMode;
	print "// Exited FitMode\n";
	}
select $sel;
}

global proc asToggleFitAdvancedSkeleton  ()
{
int $fitSkeletonVis=`getAttr FitSkeleton.visibility`;
setAttr -l 0 FitSkeleton.visibility;
setAttr -l 1 FitSkeleton.visibility (!$fitSkeletonVis);
setAttr MotionSystem.visibility $fitSkeletonVis;
setAttr DeformationSystem.visibility $fitSkeletonVis;
if (!$fitSkeletonVis)
	asDrivingSystemToFitSkeleton;
}

global proc asDrivingSystemToFitSkeleton ()
{
if (!`objExists DrivingSystem`)
	return;

if (`attributeExists drivingSystem FitSkeleton`)
	deleteAttr FitSkeleton.drivingSystem;
addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;

string $userAttrs[]=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	if (`gmatch $userAttrs[$i] "drivingSystem_*"`)
		deleteAttr ("FitSkeleton."+$userAttrs[$i]);

string $tempString[];	
string $drivingSystems[]=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	addAttr -k 0 -ln ("drivingSystem_"+$drivingSystems[$i]) -at bool -dv true -multi FitSkeleton;
	int $attrNr=0;
	string $userAttrs[]=`listAttr -ud -s -k $drivingSystems[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		string $sdks[]=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$userAttrs[$y])`;
		for ($z=0;$z<size($sdks);$z++)
			{
			if (!`attributeExists drivingSystemOut $sdks[$z]`) addAttr -k 0 -ln drivingSystemOut -at message $sdks[$z];
			if (`attributeExists $userAttrs[$y] $sdks[$z]`)
				deleteAttr ($sdks[$z]+"."+$userAttrs[$y]);
			string $addAttrCmd="addAttr -k 0 -ln "+$userAttrs[$y]+" -at \"float\" ";
			if (`addAttr -q -hasMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasSoftMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasSoftMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			$addAttrCmd+=$sdks[$z];
			eval ($addAttrCmd);

			connectAttr -f ("FitSkeleton.drivingSystem_"+$drivingSystems[$i]+"["+$attrNr+"]") ($sdks[$z]+"."+$userAttrs[$y]);
			$tempString=`listConnections ($sdks[$z]+".drivingSystemOut")`;
			if ($tempString[0]!="FitSkeleton")
				connectAttr -na ($sdks[$z]+".drivingSystemOut") FitSkeleton.drivingSystem;
			$attrNr++;
			}
		}
	}
}

global proc string asUniqueName (string $obj)
{
string $newName=$obj;
string $tempString[]=`ls $obj`;
if (size($tempString)>1)
	for ($i=1;$i<99;$i++)
		if (!`objExists ($obj+$i)`)
			{
			$newName=$obj+$i;
			rename $tempString[0] $newName;
			break;
			}
return $newName;
}

global proc asFitModeManualUpdate ()
{
string $sel[]=`ls -sl`;
//asByPassSDK 1;
if (!`objExists FitSkeleton`)
	return;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	$fitJoints[$i]=`asUniqueName $fitJoints[$i]`;

//Also ensure uniqueLabel
string $labelArray[];
for ($i=0;$i<size($fitJoints);$i++)
	{
	string $label=`asLabel $fitJoints[$i]`;
	if ($label=="")
		continue;
	if (!`gmatch $label "*Shoulder*"` && !`gmatch $label "*Hip*"` && !`gmatch $label "*Root*"` && !`gmatch $label "0*"`)
		continue;
	for ($y=0;$y<size($fitJoints);$y++)
		{
		if ($i==$y)
			continue;
		string $otherLabel=`asLabel $fitJoints[$y]`;
		if ($otherLabel==$label)
			{
			string $newLabel;
			for ($a=1;$a<99;$a++)
				{
				$newLabel=$label+$a;
				if (!`stringArrayCount $newLabel $labelArray`)
					break;
				}
			setAttr ($fitJoints[$i]+".type") 18;
			setAttr -type "string" ($fitJoints[$i]+".otherType") $newLabel;
			$labelArray[size($labelArray)]=$newLabel;
			}
		}
	}

for ($i=0;$i<size($fitJoints);$i++)
	{
	asFitModeUpdateJoints $fitJoints[$i] 0;
	asFitModeUpdateFat $fitJoints[$i];
	}
catchQuiet (`select $sel`);
//asByPassSDK 0;
print "// Updated Orientations\n";
}

global proc asFitModeSelectionChanged ()
{
global int $asFitModeScriptJobNr2[];
global string $asFitModeOffRLA[];
for ($i=0;$i<size($asFitModeOffRLA);$i++)
	if (`objExists $asFitModeOffRLA[$i]`)
		setAttr ($asFitModeOffRLA[$i]+".displayLocalAxis") 0;

clear $asFitModeOffRLA;
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
string $sel[]=`ls -sl -type joint`;
string $tempString[];
string $rlaParent,$rlaChild;
float $pos[];
string $aimParents;
for ($i=0;$i<size($sel);$i++)
	{
	//Parent
//	if (size(`ls -ap $sel[$i]`)>1)
//		continue;
	$rlaParent=`asRlaParent $sel[$i]`;
	if (!`objExists $rlaParent`)
		continue;
//	string $parentOtherChildren[]=`listRelatives -c -type joint $rlaParent`;
//	$parentOtherChildren=`stringArrayRemove {$sel[$i]} $parentOtherChildren`;
//	if (size($parentOtherChildren) && $sel[$i]!="BackA")
//		continue;

	if (!`getAttr ($rlaParent+".displayLocalAxis")`)
		$asFitModeOffRLA[$i]=$rlaParent;
	setAttr ($rlaParent+".displayLocalAxis") 1;
	if ($aimParents!="")
		$aimParents+="@";
	$aimParents+=$sel[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	//Child
	$rlaChild=`asRlaChild $sel[$i]`;
//	if (size(`ls -ap $rlaChild`)!=1)
//		continue;
	$aimParents+="@"+$rlaChild;
	if (`attributeExists fatYabs $sel[$i]`)
		$asFitModeScriptJobNr2[2]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".fatYabs") ("asFitModeUpdateFat \""+$sel[$i]+"\"")`;
	if (`attributeExists fatZabs $sel[$i]`)
		$asFitModeScriptJobNr2[3]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".fatZabs") ("asFitModeUpdateFat \""+$sel[$i]+"\"")`;
	if (`attributeExists twistJoints $sel[$i]`)
		$asFitModeScriptJobNr2[3]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".twistJoints") ("asFitModeUpdateAllGeometry")`;

	}
if ($aimParents!="")
	{
	$asFitModeScriptJobNr2[0]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".translate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	$asFitModeScriptJobNr2[1]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".rotate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	}
}

global proc asFitModeLockCenterJoints ()
{
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`)
	return;
int $lock=`getAttr FitSkeleton.lockCenterJoints`;
float $scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
float $pos[],$pos2[];
string $fitSkeletonJoints[]=`listRelatives -f -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitSkeletonJoints);$i++)
	{
	$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
	if ($lock)
		if ($pos[0]<-$centerTolerance || $pos[0]>$centerTolerance)
			continue;

	$tempString=`listRelatives -p $fitSkeletonJoints[$i]`;
	$parent=$tempString[0];
	createNode -n transformSampler -p $parent transform;

	setAttr -type float3 transformSampler.t 1 0 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".tx");

	setAttr -type float3 transformSampler.t 0 1 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".ty");

	setAttr -type float3 transformSampler.t 0 0 1;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".tz");

	delete transformSampler;
	setAttr -l $lock ($fitSkeletonJoints[$i]+".rx");
	setAttr -l $lock ($fitSkeletonJoints[$i]+".ry");
	}
select $sel;
}

global proc asFitModeUpdateFat (string $joint)
{
string $rlaParent=`asRlaParent $joint`;
//update flare
if (`objExists ($rlaParent+"GapBlenderA")`)
	if (`attributeExists dummyInput1 ($rlaParent+"GapBlenderA")`)
		{
		setAttr ($rlaParent+"GapBlenderA"+".input[1]") `getAttr ($rlaParent+"GapBlenderA"+".dummyInput1")`;
		setAttr ($rlaParent+"GapBlenderB"+".input[1]") `getAttr ($rlaParent+"GapBlenderB"+".dummyInput1")`;
		}
}

global proc asFitModeUpdateAllGeometry ()
{
checkBox -e -v 0 asVisGeo;
asFitGeometry;
checkBox -e -v 1 asVisGeo;
asFitGeometry;
}

global proc asFitModeUpdateScale ()
{
if (!`objExists FitSkeleton`)
	return;
float $fitSkeletonScale[3]=`getAttr FitSkeleton.s`;
if ($fitSkeletonScale[0]==1 && $fitSkeletonScale[1]==1 && $fitSkeletonScale[2]==1)
	return;
string $sel[]=`ls -sl`;
int $lockTxs[],$lockTys[],$lockTzs[];
string $fitJointsParent[],$tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
setAttr -type float3 FitSkeleton.s 1 1 1;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$lockTxs[$i]=`getAttr -l ($fitJoints[$i]+".tx")`;$lockTys[$i]=`getAttr -l ($fitJoints[$i]+".ty")`;$lockTzs[$i]=`getAttr -l ($fitJoints[$i]+".tz")`;
	setAttr -l 0 ($fitJoints[$i]+".tx");setAttr -l 0 ($fitJoints[$i]+".ty");setAttr -l 0 ($fitJoints[$i]+".tz");
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -p $fitJoints[$i]`;
	$fitJointsParent[$i]=$tempString[0];
	parent -w $fitJoints[$i];
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	float $pos[]=`xform -q -ws -t $fitJoints[$i]`;
	xform -ws -t ($pos[0]*$fitSkeletonScale[0]) ($pos[1]*$fitSkeletonScale[1]) ($pos[2]*$fitSkeletonScale[2]) $fitJoints[$i];
	if (`attributeExists fat $fitJoints[$i]`) setAttr ($fitJoints[$i]+".fat") (`getAttr ($fitJoints[$i]+".fat")`*$fitSkeletonScale[1]);
	}
for ($i=0;$i<size($fitJoints);$i++)
	if (`objExists $fitJointsParent[$i]`)
		parent $fitJoints[$i] $fitJointsParent[$i];
for ($i=0;$i<size($fitJoints);$i++)
	{
	setAttr -l $lockTxs[$i] ($fitJoints[$i]+".tx");setAttr -l $lockTys[$i] ($fitJoints[$i]+".ty");setAttr -l $lockTzs[$i] ($fitJoints[$i]+".tz");
	}
scale -r -p 0 0 0 $fitSkeletonScale[1] $fitSkeletonScale[1] $fitSkeletonScale[1] FitSkeletonShape.cv[0:7] ;
asFitModeManualUpdate;
select $sel;
}

global proc asFitModeUpdateJoints (string $jointsString, int $recursive)
{
int $upV[3]={0,1,0};
int $childNr,$newChildNr;
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
asFitModeUpdateScale;
string $sel[]=`ls -sl`;
string $tempString[],$joints[],$jointAllDescendents[],$otherJointsInIK[],$connectCmds[],$rlaParentChildren[],$newRlaParentChildren[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $generatedTransform1,$generatedTransform2,$IKParentJoint,$IKChildJoint,$jointLongName,$worldOrient;
string $rlaParent,$rlaChild,$rlaParentRlaChild;
tokenize $jointsString "@" $joints;
for ($joint in $joints)
	{
	if (size(`ls -ap $joint`)!=1)
		continue;
	string $rlaParent=`asRlaParent $joint`;
	$rlaParent=`asUniqueName $rlaParent`;
	string $rlaChild=`asRlaChild $joint`;
	$rlaChild=`asUniqueName $rlaChild`;

	int $childNr=0;
	clear $rlaParentChildren;
	if ($rlaParent!="")
		{
		$rlaParentRlaChild=`asRlaChild $rlaParent`;
		$rlaParentChildren=`listRelatives -type joint -c $rlaParent`;
		if (size($rlaParentChildren)>1)
			for ($i=0;$i<size($rlaParentChildren);$i++)
				{
				if ($joint==$rlaParentChildren[$i])
					$childNr=$i;
				}
		}

	if (!`objExists $rlaParent`)
		continue;
	if (`attributeExists freeOrient $rlaParent`)
		continue;
	if (`asRlaChild $rlaParent`!=$joint && $rlaParent!="Cup")
		continue;
	$worldOrient="";
	if (`attributeExists worldOrient $rlaParent`)
		$worldOrient=`getAttr ($rlaParent+".worldOrient")`;
	$flipOrient=0;
	if (`attributeExists flipOrient $joint`)
		if (`getAttr ($joint+".flipOrient")`)
			$flipOrient=!$flipOrient;
	string $rlaParentParent=`asRlaParent $rlaParent`;
	clear $otherJointsInIK;
	$tempString=`ls -l $joint`;
	$jointLongName=$tempString[0];
	$jointAllDescendents=`listRelatives -allDescendents -type joint $joint`;
	$jointAllDescendents[size($jointAllDescendents)]=$joint;
	string $parentOtherChildren[]=`listRelatives -c $rlaParent`;
	$parentOtherChildren=`stringArrayRemove {$joint} $parentOtherChildren`;
	int $center=0;
	$pos=`xform -q -ws -t $joint`;
	if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;

	//IK-plane ($flip)
	tokenize $jointLongName "|" $tempString;
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		if (!$recursive)
			if (!`stringArrayCount $tempString[$i] $joints`)
				$otherJointsInIK[size($otherJointsInIK)]=$tempString[$i];
		if (`attributeExists flipOrient $tempString[$i]`)
			if (`getAttr ($tempString[$i]+".flipOrient")`)
				$flipOrient=!$flipOrient;
		$label=`asLabel $tempString[$i]`;
		if (`gmatch $label "*Shoulder*"` || `gmatch $label "*Hip*"`)
			{
			$IKParentJoint=$tempString[$i];
			break;
			}
		}
	for ($i=size($jointAllDescendents)-1;$i>-1;$i--)
		{
		if (!$recursive)
			if (!`stringArrayCount $jointAllDescendents[$i] $joints`)
				$otherJointsInIK[size($otherJointsInIK)]=$jointAllDescendents[$i];
		$label=`asLabel $jointAllDescendents[$i]`;
		if (`gmatch $label "*Hand*"` || `gmatch $label "*Foot*"`)
			{$IKChildJoint=$jointAllDescendents[$i];break;}
		}

	int $lockTX=`getAttr -l ($joint+".tx")`;int $lockTY=`getAttr -l ($joint+".ty")`;int $lockTZ=`getAttr -l ($joint+".tz")`;
	int $lockRX=`getAttr -l ($joint+".rx")`;int $lockRY=`getAttr -l ($joint+".ry")`;int $lockRZ=`getAttr -l ($joint+".rz")`;
	int $lockPTX=`getAttr -l ($rlaParent+".tx")`;int $lockPTY=`getAttr -l ($rlaParent+".ty")`;int $lockPTZ=`getAttr -l ($rlaParent+".tz")`;
	int $lockPRX=`getAttr -l ($rlaParent+".rx")`;int $lockPRY=`getAttr -l ($rlaParent+".ry")`;int $lockPRZ=`getAttr -l ($rlaParent+".rz")`;
	setAttr -l 0 ($joint+".tx");setAttr -l 0 ($joint+".ty");setAttr -l 0 ($joint+".tz");
	setAttr -l 0 ($joint+".rx");setAttr -l 0 ($joint+".ry");setAttr -l 0 ($joint+".rz");
	setAttr -l 0 ($rlaParent+".tx");setAttr -l 0 ($rlaParent+".ty");setAttr -l 0 ($rlaParent+".tz");
	setAttr -l 0 ($rlaParent+".rx");setAttr -l 0 ($rlaParent+".ry");setAttr -l 0 ($rlaParent+".rz");

	if (size($parentOtherChildren))
		{
		createNode -n otherChildrenPlaceHolder -p $rlaParent transform;
		parent -w otherChildrenPlaceHolder;
		}
	for ($i=0;$i<size($parentOtherChildren);$i++)
		{
		$tempString=`parent $parentOtherChildren[$i] otherChildrenPlaceHolder`;
		$parentOtherChildren[$i]=$tempString[0];
		}
		
	$tempString=`parent -w $joint`;
	$joint=$tempString[0];
	$tempString=`listRelatives -p $joint`;
	if (size($tempString))
		$generatedTransform1=$tempString[0];

	//disconnect connections
	clear $connectCmds;
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$tempString=`listConnections -p 1 ($rlaParent+"."+$trs[$y]+$xyz[$z])`;
			if ($tempString[0]!="")
				{
				$connectCmds[size($connectCmds)]="connectAttr -f "+$tempString[0]+" "+$rlaParent+"."+$trs[$y]+$xyz[$z]+";";
				disconnectAttr $tempString[0] ($rlaParent+"."+$trs[$y]+$xyz[$z]);
				}
			}

	if ($center && $joint==$rlaParentRlaChild) // Center
		{
//print ("$joint="+$joint+", $rlaParent="+$rlaParent+", $rlaParentRlaChild="+$rlaParentRlaChild+"\n");
		$upV={0,0,1}; if ($flipOrient) $upV={0,0,-1};
		$tempString=`aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "vector" -worldUpVector 1 0 0 $joint $rlaParent`;
		delete $tempString[0];
		}
	if (($IKParentJoint=="" || $IKChildJoint=="") && !$center) // Non-IK (side)
		{
		$upV={0,1,0}; // if ($flipOrient) $upV={0,-1,0}; These are free oriented, so no flip
		string $upVecObj=`createNode joint`;
		parent -r $upVecObj $rlaParent;
		setAttr ($upVecObj+".translate") 0 3 0;
		parent -w $upVecObj;
		$tempString=`listRelatives -p $upVecObj`;
		if (size($tempString))
			$generatedTransform2=$tempString[0];
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0] $upVecObj;
		}

	if (($IKParentJoint!="" && $IKChildJoint!="") && !$center) // IK
		{
		$upV={0,1,0}; if ($flipOrient) $upV={0,-1,0};
		$label=`asLabel $IKParentJoint`;
		if (`gmatch $label "*Hip*"`)
			$upV={0,-1,0};
		string $upVecObj=`createNode joint`;
		parent -r $upVecObj $rlaParent;
		setAttr ($upVecObj+".translate") 0 3 0;
		parent -w $upVecObj;
		$tempString=`listRelatives -p $upVecObj`;
		if (size($tempString))
			$generatedTransform2=$tempString[0];
		pointConstraint $IKParentJoint $IKChildJoint $upVecObj;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0] $upVecObj;
		}
	else
		clear $otherJointsInIK;

	//Special case, $worldOrient
	if ($worldOrient!="" && `objExists $rlaParentParent`)
		{
		$upVecObj=$rlaParentParent;
		$upVecObj=`createNode -n tempUpVector -p $joint transform`;
		parent -w $upVecObj;
		move -r -ws 0 1 0 $upVecObj;
		float $upVec=1;
		parent $upVecObj $rlaParentParent;
		//Could be `reverse-knee`
//		if (`getAttr ($upVecObj+".ty")`<0)
//			$upVec=-1;
		createNode -n tempAimAt -p $rlaParent transform;
		parent -w tempAimAt;
		move -r -ws 0 -1 0 tempAimAt;
		if ($worldOrient==0) $tempString=`aimConstraint -aimVector -1 0 0 -upVector 0 $upVec 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==1) $tempString=`aimConstraint -aimVector 0 -1 0 -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==2) $tempString=`aimConstraint -aimVector 0 0 -1 -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==3) $tempString=`aimConstraint -aimVector 1 0 0  -upVector 0 $upVec 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==4) $tempString=`aimConstraint -aimVector 0 1 0  -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==5) $tempString=`aimConstraint -aimVector 0 0 1  -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;

		delete $tempString[0] $upVecObj tempAimAt;
		}
	//Special case, Ball
	$label=`asLabel $rlaParent`;
	if (`gmatch $label "*Ball*"`)
		{
		//Could be `reverse-knee`
		float $upVec=1;
		createNode -n tempAimAt -p $rlaParentParent transform;
		asAlign tempAimAt $joint 1 0 0 0;
		if (`getAttr tempAimAt.ty`<0)
			$upVec=-1;
		delete tempAimAt;
		$tempString=`aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 $upVec 0 -worldUpType "vector" -worldUpVector 0 1 0 $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Scapula
	if (`gmatch $rlaParent "Scapula*"` && $IKParentJoint!="")
		{
		$upVecObj=$IKParentJoint;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, LegAim
	if (`gmatch $label "LegAim*"`)
		{
		$upVecObj=$IKParentJoint;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Cup
	if ($rlaParent=="Cup" && `objExists RingFinger1` && `objExists MiddleFinger1`)
		{
		$upVecObj=`asRlaParent $rlaParent`;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj RingFinger1 MiddleFinger1 $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Eyes
	if (`gmatch $rlaParent "Eye*"`)
		{
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "vector" -worldUpVector 0 1 0 $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Root with no centered child
	if ($rlaParent=="Root" && !$center)
		{
		setAttr -type float3 ($rlaParent+".rotate") 0 0 0;
		setAttr -type float3 ($rlaParent+".jointOrient") 90 0 90;
		}

	makeIdentity -a 1 -t 0 -r 1 -s 0 $rlaParent;

	if (size($parentOtherChildren))
		{
		parent $parentOtherChildren $rlaParent;
		delete otherChildrenPlaceHolder;
		}

	parent $joint $rlaParent;
	//restore sibiling order
	if (size($rlaParentChildren)>1)
		{
		$newRlaParentChildren=`listRelatives -type joint -c $rlaParent`;
		for ($i=0;$i<size($newRlaParentChildren);$i++)
			{
			if ($joint==$newRlaParentChildren[$i])
				$newChildNr=$i;
			}
		if ($newChildNr!=$childNr)
			{
//			print ($joint+":"+$childNr+"\n");
//			print ("reorder -relative ("+$childNr+"-"+$newChildNr+")="+($childNr-$newChildNr)+" "+$joint+";\n");
			reorder -relative ($childNr-$newChildNr) $joint;
			}
		}
	if (`objExists $generatedTransform1`) delete $generatedTransform1;
	if (`objExists $generatedTransform2`) delete $generatedTransform2;

	//restore connections
	for ($i=0;$i<size($connectCmds);$i++)
		if (catchQuiet (`eval ($connectCmds[$i])`)) 
			warning ("Failed: "+$connectCmds[$i]+"\n");

	//update lenght
	if (`objExists ($rlaParent+"ScaleYMultiDiv1")`)
		setAttr ($rlaParent+"ScaleYMultiDiv1.input1Y") (`getAttr ($rlaParent+"ScaleYMultiDiv1.dummyInput1Y")`*(1.0/$scale));

	//update skeleton scale
	if (`objExists ($rlaParent+"Bone")` && `objExists ($rlaParent+"Distance")`)
		{
		float $lenght=`getAttr ($rlaParent+"Distance.distance")`*(1.0/$scale);
		setAttr ($rlaParent+"Bone.sx") $lenght;
		}

	//update scale from FitSkeleton
//	if (`objExists ($joint+"Aim")`)
//		setAttr ($joint+"Aim.sx") (1.0/$scale);

	setAttr -l $lockTX ($joint+".tx");setAttr -l $lockTY ($joint+".ty");setAttr -l $lockTZ ($joint+".tz");
	setAttr -l $lockRX ($joint+".rx");setAttr -l $lockRY ($joint+".ry");setAttr -l $lockRZ ($joint+".rz");
	setAttr -l $lockPTX ($rlaParent+".tx");setAttr -l $lockPTY ($rlaParent+".ty");setAttr -l $lockPTZ ($rlaParent+".tz");
	setAttr -l $lockPRX ($rlaParent+".rx");setAttr -l $lockPRY ($rlaParent+".ry");setAttr -l $lockPRZ ($rlaParent+".rz");
	}

//Update the other joints in the same IK to ensure IK-plane
for ($i=0;$i<size($otherJointsInIK);$i++)
	asFitModeUpdateJoints $otherJointsInIK[$i] 1;

select $sel;
}

global proc string[] asFitJointIKInfo (string $joint)
{
int $IKNumCtrls=2;
string $ik,$IKParentJoint,$IKMiddleJoint,$IKChildJoint,$IKSolver,$IKParentJointLabel;
string $asFitJointIKInfo[],$tempString[];
$tempString=`ls -l $joint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$label=`asLabel $tempString[$i]`;
	if ($i<size($tempString)-1)
		if (`gmatch $label "*Hand*"` || `gmatch $label "*Foot*"` || `gmatch $label "*Chest*"`)
			break;
	if (`gmatch $label "*Shoulder*"` || `gmatch $label "*Hip*"` || `gmatch $label "*Root*"` || `gmatch $label "0*"`)
		{
		$IKParentJoint=$tempString[$i];
		$IKParentJointLabel=$label;
		break;
		}
	}

string $jointAllDescendents[]=`listRelatives -allDescendents -type joint $joint`;
$jointAllDescendents[size($jointAllDescendents)]=$joint;
for ($i=size($jointAllDescendents)-1;$i>-1;$i--)
	{
	$label=`asLabel $jointAllDescendents[$i]`;
	int $validLabelHit=0;
	if (`gmatch $label "*Hand*"` && `gmatch $IKParentJointLabel "*Shoulder*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Foot*"` && `gmatch $IKParentJointLabel "*Hip*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Chest*"` && `gmatch $IKParentJointLabel "*Root*"`)
		$validLabelHit=1;
	if ($validLabelHit)
		{
		$IKChildJoint=$jointAllDescendents[$i];
		break;
		}
	if (`gmatch $label "*[0-9]*"` && `gmatch $IKParentJointLabel "*0*"`)
		$IKChildJoint=$jointAllDescendents[$i];
	}

if ($IKParentJoint!= "" && $IKChildJoint!="")
	{
	//Find $IKMiddleJoint
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	int $numIkJoints=0;
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		$numIkJoints++;
		if ($tempString[$i]==$IKParentJoint)
		break;
		}
	int $middleNr=$numIkJoints/2;
	$IKMiddleJoint=$tempString[size($tempString)-1-$middleNr];
	//Find $IKNumCtrls
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	for ($i=size($tempString)-2;$i>-1;$i--)
		{
		if ($tempString[$i]==$IKParentJoint)
		break;
		$label=`asLabel $tempString[$i]`;
		if (`gmatch $label "*Mid*"` || `gmatch $label "[0-9]*"`)
			$IKNumCtrls++;
		}

	$IKSolver="ikRPsolver";
	$label=`asLabel $IKParentJoint`;
	if (`gmatch $label "*Shoulder*"`)
		$ik="Arm"+`substitute "Shoulder" $label ""`;
	if (`gmatch $label "*Hip*"`)
		$ik="Leg"+`substitute "Hip" $label ""`;
	if (`gmatch $label "*Root*"`)
		{
		$ik="Spine"+`substitute "Root" $label ""`;
		$IKSolver="ikSplineSolver";
		}
	if (`gmatch $label "*0*"`)
		{
		$ik="Spline"+`substitute "[0-9]*" $label ""`;
		$IKSolver="ikSplineSolver";
		}
	$asFitJointIKInfo[0]=$ik;
	$asFitJointIKInfo[1]=$IKParentJoint;
	$asFitJointIKInfo[2]=$IKMiddleJoint;	
	$asFitJointIKInfo[3]=$IKChildJoint;	
	$asFitJointIKInfo[4]=$IKSolver;
	$asFitJointIKInfo[5]=$IKNumCtrls;
	}
return $asFitJointIKInfo;
}

global proc string[] asGetIKJoints (string $IKStartJoint, string $IKEndJoint)
{
string $IKJoints[];
string $tempString[]=`ls -l $IKEndJoint`;
tokenize $tempString[0] "|" $tempString;
int $foundStartJoint=0;
for ($i=0;$i<size($tempString);$i++)
	{
    if ($tempString[$i]==$IKStartJoint)
        $foundStartJoint=1;
    if ($foundStartJoint)
    	$IKJoints[size($IKJoints)]=$tempString[$i];
	}
return $IKJoints;
}

global proc asFitSDKCreateAttribute ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$drivenObjs[],$drivenAttrs[];
float $drivenDefaultValue[],$drivenValue[];
if (!size($sel))
	warning "Nothing selected, you should select a SDK Object first\n";
else
	$tempString=`listRelatives -c $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not a nurbsCurve\n";
if (`objectType $tempString[0]`!="nurbsCurve")
	error "Selected Object is not a nurbsCurve\n";
$existingDefaultPoseCmdString=`getAttr ($sel[0]+".defaultPose")`;
$existingDefaultPoseCmds=`stringToStringArray $existingDefaultPoseCmdString ";"`;

string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $cmd;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
		{
		$objAttr=$fitJoints[$i]+"."+$trs[$y]+$xyz[$z];
		float $value=`getAttr $objAttr`;
		for ($a=0;$a<size($existingDefaultPoseCmds);$a++)
			if (`gmatch $existingDefaultPoseCmds[$a] ("setAttr "+$objAttr+" *")`)
				{
				tokenize $existingDefaultPoseCmds[$a] $tempString;
				float $defaultValue=$tempString[2];
				if ($value>$defaultValue+0.001 || $value<$defaultValue-0.001)
					{
					tokenize $tempString[1] "." $tempString2;
					$drivenObjs[size($drivenObjs)]=$tempString2[0];
					$drivenAttrs[size($drivenAttrs)]=$tempString2[1];
					$drivenDefaultValue[size($drivenDefaultValue)]=$defaultValue;
					$drivenValue[size($drivenValue)]=$value;
					}
				}
		}
if (!size($drivenObjs))
	error "Found No attributes changed from Default Pose";

string $suggestAttrName;
if (`gmatch $drivenObjs[0] "*Finger*"` || `gmatch $drivenObjs[0] "*Toe*"`)
	{
	$suggestAttrName=`substitute "[0-9]" $drivenObjs[0] ""`;
	$suggestAttrName=`substitute "Finger" $suggestAttrName ""`;
	$suggestAttrName=`substitute "Toe" $suggestAttrName ""`;
	$suggestAttrNameFirstLetter=`substring $suggestAttrName 1 1`;
	$suggestAttrName=`tolower $suggestAttrNameFirstLetter`+`substring $suggestAttrName 2 99`+"Curl";
	}

$asFitSDKMessage="Create Set-Driven-Key for these ?\n\n";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $value=`getAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i])`;
	float $roundFactor=0.5;
	if ($value<0) $roundFactor=-0.5;
	$value=(trunc($value*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
	$asFitSDKMessage+=$drivenObjs[$i]+"."+$drivenAttrs[$i]+" = "+$value+"\n";
	}
$asFitSDKAttrName=$suggestAttrName;
$asFitSDKObjName=$sel[0];
$asFitSDKDriverValue=10;

string $dialogResult=`layoutDialog -t "Confirm" -ui asFitSDKCreateAttributeLayout`;
if ($dialogResult!="OK")
	return;

string $attrName=$asFitSDKAttrName;
if ($attrName=="" || `gmatch $attrName "* *"`)
	error "Not a valid attribute name";	
if (`attributeExists $attrName $sel[0]`)
	deleteAttr ($sel[0]+"."+$attrName);
addAttr -k 1 -ln $attrName -at double $sel[0];
if ($asFitSDKDriverHasMin) addAttr -e -softMinValue $asFitSDKDriverMin ($sel[0]+"."+$attrName);
if ($asFitSDKDriverHasMax) addAttr -e -softMaxValue $asFitSDKDriverMax ($sel[0]+"."+$attrName);

for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $driverValue=10;
	$objAttr=$drivenObjs[$i]+"."+$drivenAttrs[$i];
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenDefaultValue[$i] -dv 0 -cd ($sel[0]+"."+$attrName) $objAttr;
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValue[$i] -dv $asFitSDKDriverValue -cd ($sel[0]+"."+$attrName) $objAttr;
//	setAttr ($sel[0]+"."+$attrName) $driverValue;
	}
select $drivenObjs;
setInfinity -pri cycleRelative -poi cycleRelative;

select $sel;
}

global proc asFitSDKCreateAttributeLayout ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $tempString[];
tokenize $asFitSDKMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asFitSDKMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asFitSDKMessage+=$tempString[$i]+"\n";
	$asFitSDKMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout;
	text -l $asFitSDKMessage;
	separator -h 10 -st none;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 -tx $asFitSDKAttrName asFitSDKAttrNameTextField;
		setParent..;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Value:";
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverValueFloatField;
		setParent..;
	separator -st none -h 3;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		checkBox -l "Min" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMinFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMinFloatField" asFitSDKDriverHasMinCheckBox;
		checkBox -l "Max" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMaxFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMaxFloatField" asFitSDKDriverHasMaxCheckBox;
		setParent..;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		floatField -w 50 -v 0 -pre 1 asFitSDKDriverMinFloatField;
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverMaxFloatField;
		setParent..;
	separator -h 10 -st none;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asFitSDKCreateAttributeGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;
}

global proc asFitSDKCreateAttributeGetName ()
{
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
$asFitSDKAttrName=`textField -q -tx asFitSDKAttrNameTextField`;
$asFitSDKDriverValue=`textField -q -tx asFitSDKDriverValueFloatField`;
$asFitSDKDriverHasMin=`checkBox -q -v asFitSDKDriverHasMinCheckBox`;
$asFitSDKDriverHasMax=`checkBox -q -v asFitSDKDriverHasMaxCheckBox`;
$asFitSDKDriverMin=`floatField -q -v asFitSDKDriverMinFloatField`;
$asFitSDKDriverMax=`floatField -q -v asFitSDKDriverMaxFloatField`;
}

global proc string asRlaParent (string $joint)
{
string $tempString[]=`listRelatives -p -type joint $joint`;
string $rlaParent=$tempString[0];
return $rlaParent;
}

global proc string asRlaChild (string $joint)
{
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
string $children[]=`listRelatives -type joint -c $joint`;
string $rlaChild="";
float $pos[3]=`xform -q -ws -t $joint`;
int $center=0;
if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;
for ($y=0;$y<size($children);$y++)
	{
	float $childPos[3]=`xform -q -ws -t $children[$y]`;
	int $childCenter=0;
	if ($childPos[0]>-$centerTolerance && $childPos[0]<$centerTolerance) $childCenter=1;
	if ($center && $childCenter) $rlaChild=$children[$y];
	if (!$center && !$childCenter) $rlaChild=$children[$y];
	//Use `first` child as $rlaChild
	if ($rlaChild!="")
	 break;
	}

if (!$center && size($children)>1)
	$rlaChild="";

//Preferred $rlaChild
if (`gmatch $joint "*Head*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Head*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Ankle*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Toes*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Root*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Spine*"`)
			$rlaChild=$children[$y];

return $rlaChild;
}

global proc asFitGeometry ()
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $sel[]=`ls -sl`;
int $displayGeometry=`checkBox -q -v asVisGeo`;
if (`objExists FitSkeletonVisualizers`) delete FitSkeletonVisualizers;
if (`objExists Mannequin_Geometry`) delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`) delete Skeleton_Geometry;
if ($displayGeometry==0)
	{
	asUpdateButtonEnables;
	return;
	}
asFitModeEnsureShaders;
int $twistJoints,$inbetweenJoints;
float $aimV[3]={1,0,0};
float $upV[3]={0,1,0};
string $part;

createNode -n FitSkeletonVisualizers transform;
connectAttr FitSkeleton.s FitSkeletonVisualizers.s;
createNode -n Aims -p FitSkeletonVisualizers transform;
string $tempString[],$geoObjs[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
string $templateBones[]=`listRelatives -c Skeleton_Geometry`;
for ($i=0;$i<size($templateBones);$i++)
	rename $templateBones[$i] ($templateBones[$i]+"_template");

for ($i=size($fitJoints)-1;$i>-1;$i--) // Reverse order, so endJoints can copy `fat` value from parent
	asEnsureFitJointAttrs $fitJoints[$i];

for ($i=0;$i<size($fitJoints);$i++)
	{
	clear $geoObjs;
	string $rlaChild=`asRlaChild $fitJoints[$i]`;
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($rlaChild=="" && $fitJoints[$i]=="Root" && $tempString[0]!="") // Root to use sideChild, if no middleChild
		$rlaChild=$tempString[0];
	if ($rlaChild=="")
		continue;
	if (`attributeExists worldOrient $fitJoints[$i]`)
		continue;
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	if ($fitJoints[$i]=="*Jaw*" || `gmatch $fitJoints[$i] "*Eye*"`)
		continue;	

	createNode -n ($fitJoints[$i]+"Aim") -p Aims transform;
	$twistJoints=0;
	if (`attributeExists twistJoints  $fitJoints[$i]`)
		$twistJoints=`getAttr ($fitJoints[$i]+".twistJoints")`;
	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints  $fitJoints[$i]`)
		$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+$part+"Geo") -p ($fitJoints[$i]+"Aim") transform;
	
		//box
		$tempString=`polyCube -n ($fitJoints[$i]+$part+"Box") -w 1.75 -h 1 -d 1.75 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
		$box=$tempString[0];
		$geoObjs[size($geoObjs)]=$box;
		move -r 0 0.5 0 ($box+".vtx[0:7] ");
		sets -e -forceElement asRedSG ($box+".f[1]");
		sets -e -forceElement asRed2SG ($box+".f[3]");
		sets -e -forceElement asGreenSG ($box+".f[0]");
		sets -e -forceElement asGreen2SG ($box+".f[2]");
		sets -e -forceElement asBlueSG ($box+".f[4]");
		sets -e -forceElement asBlue2SG ($box+".f[5]");
		connectAttr FitSkeleton.visBoxes ($box+".v");
		setAttr ($box+"Shape.overrideEnabled") 1;
		setAttr ($box+"Shape.overrideDisplayType") 2;
		parent $box ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($box+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($box+".vtx[0:7]");
	
		
		//cylinder
		$tempString=`cylinder -n ($fitJoints[$i]+$part+"Cyl") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -hr 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 0`;
		$cyl=$tempString[0];
		$geoObjs[size($geoObjs)]=$cyl;
		move -r 0 0.5 0 ($cyl+".cv[0:3][0:7]");
		sets -e -forceElement asBlueSG ($cyl+".sf[0][7]") ($cyl+".sf[0][0]");//sf[0][1:2]
		sets -e -forceElement asGreenSG ($cyl+".sf[0][1:2]");//sf[0][3:4]
		sets -e -forceElement asBlue2SG ($cyl+".sf[0][3:4]");//sf[0][5:6]
		sets -e -forceElement asGreen2SG ($cyl+".sf[0][5:6]");//sf[0][7]
		connectAttr FitSkeleton.visCylinders ($cyl+".v");
		setAttr ($cyl+"Shape.overrideEnabled") 1;
		setAttr ($cyl+"Shape.overrideDisplayType") 2;
		parent $cyl ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($cyl+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($cyl+".cv[0:3][0:7]");	
		}

	//sphere
	$tempString=`polyCube -n ($fitJoints[$i]+"Sphere") -w 2.5 -h 2.5 -d 2.5 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
	$sphere=$tempString[0];
	sets -e -forceElement asRedSG ($sphere+".f[1]");
	sets -e -forceElement asRed2SG ($sphere+".f[3]");
	sets -e -forceElement asGreenSG ($sphere+".f[0]");
	sets -e -forceElement asGreen2SG ($sphere+".f[2]");
	sets -e -forceElement asBlueSG ($sphere+".f[4]");
	sets -e -forceElement asBlue2SG ($sphere+".f[5]");
	polySmooth  -mth 0 -dv 2 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 0 $sphere;
	connectAttr FitSkeleton.visSpheres ($sphere+".v");
	setAttr ($sphere+"Shape.overrideEnabled") 1;
	setAttr ($sphere+"Shape.overrideDisplayType") 2;
	parent $sphere ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($sphere+".s") 1 1 1;
	rotate -r -p 0 0 0 -os 0 -90 -90 ($sphere+".vtx[0:999]");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sy");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sz");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sx");

	//bones
	$bone=$fitJoints[$i]+"Bone";
	if (`objExists ($fitJoints[$i]+"Bone_template")`)
		duplicate -n $bone ($fitJoints[$i]+"Bone_template");
	else if ($fitJoints[$i]=="Root" || $fitJoints[$i]=="Chest" || `gmatch $fitJoints[$i] "Neck*"` || `gmatch $fitJoints[$i] "Spine*"`)
		duplicate -n $bone SpineBone_template;
	else if (`gmatch $fitJoints[$i] "*Finger*"`)
		duplicate -n $bone DigitBone_template;
	else
		duplicate -n $bone GenericBone_template;
	sets -e -forceElement asBonesSG $bone;
	parent $bone ($fitJoints[$i]+"Aim");
	connectAttr FitSkeleton.visBones ($bone+".v");
	connectAttr ($fitJoints[$i]+".fat") ($bone+".sy");
	connectAttr ($fitJoints[$i]+".fat") ($bone+".sz");

	//Flare
	select $geoObjs;
	$tempString=`nonLinear -type flare  -lowBound 0 -highBound 1 -startFlareX 1 -startFlareZ 1 -endFlareX 1 -endFlareZ 1 -curve 0`;
	string $flare=`rename $tempString[0] ($fitJoints[$i]+"Flare")`;
	string $flareHandle=`rename $tempString[1]  ($fitJoints[$i]+"FlareHandle")`;
	parent $flareHandle ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($flareHandle+".s") 1 1 1;
	setAttr -type float3 ($flareHandle+".t") 0 0 0;
	setAttr -type float3 ($flareHandle+".r") 0 0 -90;
	setAttr -l 1 ($flareHandle+".v") 0;
	
	connectAttr ($fitJoints[$i]+".fatYabs") ($flare+".startFlareX");
	connectAttr ($fitJoints[$i]+".fatZabs") ($flare+".startFlareZ");
	
	//Gap
	if (`objExists ($fitJoints[$i]+"GapBlenderA")`) delete ($fitJoints[$i]+"GapBlenderA");
	if (`objExists ($fitJoints[$i]+"GapBlenderB")`) delete ($fitJoints[$i]+"GapBlenderB");
	string $gapBlenderA=`createNode -n ($fitJoints[$i]+"GapBlenderA") blendTwoAttr`;
	string $gapBlenderB=`createNode -n ($fitJoints[$i]+"GapBlenderB") blendTwoAttr`;
	connectAttr FitSkeleton.visGap ($gapBlenderA+".attributesBlender");
	connectAttr FitSkeleton.visGap ($gapBlenderB+".attributesBlender");
	connectAttr ($fitJoints[$i]+".fatYabs") ($gapBlenderA+".input[0]");
	connectAttr ($fitJoints[$i]+".fatZabs") ($gapBlenderB+".input[0]");
	addAttr -k 0 -ln dummyInput1 -at double $gapBlenderA;
	addAttr -k 0 -ln dummyInput1 -at double $gapBlenderB;
	connectAttr ($rlaChild+".fatYabs") ($gapBlenderA+".dummyInput1");
	connectAttr ($rlaChild+".fatZabs") ($gapBlenderB+".dummyInput1");
	setAttr ($gapBlenderA+".input[1]") `getAttr ($rlaChild+".fatYabs")`;
	setAttr ($gapBlenderB+".input[1]") `getAttr ($rlaChild+".fatZabs")`;

	connectAttr ($gapBlenderA+".output") ($flare+".endFlareX");
	connectAttr ($gapBlenderB+".output") ($flare+".endFlareZ");

	//Distance
	if (`objExists ($fitJoints[$i]+"Distance")`) delete ($fitJoints[$i]+"Distance");
	createNode -n ($fitJoints[$i]+"Distance") distanceBetween;
	connectAttr ($fitJoints[$i]+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix1");
	connectAttr ($rlaChild+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix2");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv1")`) delete ($fitJoints[$i]+"ScaleYMultiDiv1");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv1") multiplyDivide;
	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.operation") 2;
//	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y");

	addAttr -ln dummyInput1Y -at double ($fitJoints[$i]+"ScaleYMultiDiv1");
	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.dummyInput1Y");
	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y") `getAttr ($fitJoints[$i]+"Distance.distance")`;

//	connectAttr FitSkeleton.sx ($fitJoints[$i]+"ScaleYMultiDiv1.input2Y");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv2")`) delete ($fitJoints[$i]+"ScaleYMultiDiv2");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv2") multiplyDivide;
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv2.input1Y");
	connectAttr FitSkeleton.visGap ($fitJoints[$i]+"ScaleYMultiDiv2.input2Y");
	
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($flareHandle+".sy");

	parentConstraint $fitJoints[$i] ($fitJoints[$i]+"Aim");

	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y) multiplyDivide;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input2Y") ($y*(1.0/($twistJoints+$inbetweenJoints+1)));
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo.tx");

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y) multiplyDivide;
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".operation") 2;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv2.outputY") ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input2Y") ($twistJoints+$inbetweenJoints+1);
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo"+".sx");
		}
	}

if (`objExists PelvisBone`)
	{
	parent PelvisBone FitSkeletonVisualizers;
	setAttr PelvisBone.tx 0;
	setAttr -type float3 PelvisBone.r 0 0 0;
	pointConstraint -skip x Hip PelvisBone;
	}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
asFitModeManualUpdate;
asUpdateButtonEnables;
asChangeVisGeoType;
catchQuiet (`select $sel`);
}

global proc asChangeVisGeoType ()
{
string $geoType=`optionMenu -q -v asVisGeoType`;
setAttr FitSkeleton.visCylinders 0;
setAttr FitSkeleton.visBoxes 0;
setAttr FitSkeleton.visSpheres 0;
setAttr FitSkeleton.visBones 0;
if ($geoType=="cylinders")
	setAttr FitSkeleton.visCylinders 1;
if ($geoType=="boxes")
	setAttr FitSkeleton.visBoxes 1;
if ($geoType=="spheres")
	setAttr FitSkeleton.visSpheres 1;
if ($geoType=="bones")
	setAttr FitSkeleton.visBones 1;
}

global proc asEnsureFitJointAttrs (string $fitJoint)
{
if (!`attributeExists fat $fitJoint`)
	{
	float $dv=1;
	string $rlaChild=`asRlaChild $fitJoint`;
	if ($rlaChild!="")
		{
		$dv=`getAttr ($rlaChild+".tx")`;
		$dv=`abs($dv)`;
		}
	else
		{
		string $tempString[]=`listRelatives -p -type joint $fitJoint`;
		if ($tempString[0]!="" && `attributeExists fat $tempString[0]`)
			$dv=`getAttr ($tempString[0]+".fat")`;
		}
	addAttr -k 1 -min 0 -dv $dv -ln fat -at double $fitJoint;
	}
if (!`attributeExists fatY $fitJoint`)
	addAttr -k 1 -min 0 -dv 1 -ln fatY -at double $fitJoint;
if (!`attributeExists fatZ $fitJoint`)
	addAttr -k 1 -min 0 -dv 1 -ln fatZ -at double $fitJoint;
if (!`attributeExists fatYabs $fitJoint`)
	addAttr -k 0 -ln fatYabs -at double $fitJoint;
if (!`attributeExists fatZabs $fitJoint`)
	addAttr -k 0 -ln fatZabs -at double $fitJoint;
if (`objExists ($fitJoint+"Fat")`) delete ($fitJoint+"Fat");
createNode -n ($fitJoint+"Fat") multiplyDivide;
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Y");
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Z");
connectAttr -f ($fitJoint+".fatY") ($fitJoint+"Fat.input2Y");
connectAttr -f ($fitJoint+".fatZ") ($fitJoint+"Fat.input2Z");
connectAttr -f ($fitJoint+"Fat.outputY") ($fitJoint+".fatYabs");
connectAttr -f ($fitJoint+"Fat.outputZ") ($fitJoint+".fatZabs");
}

global proc asRemoveUnusedfromBuildPose (string $uiName)
{
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	$buildPose="faceBuildPose";
string $newBuildPoseCmd;
string $cmds[],$tempString[];
string $buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
tokenize $buildPoseCmd ";" $cmds;
for ($i=0;$i<size( $cmds);$i++)
	{
	tokenize $cmds[$i] $tempString;
	string $ctrl=$tempString[size($tempString)-1];
	if (`gmatch $cmds[$i] "*[.]*"`)
		$ctrl=$tempString[size($tempString)-2];
	if (`objExists $ctrl`)
		$newBuildPoseCmd+=$cmds[$i]+";";
	}
setAttr -type "string" ($buildPose+".udAttr") $newBuildPoseCmd;
}

global proc asUpdateASToolsProcsInSelectors ()
{
string $AdvancedSkeleton5File=`asGetScriptLocation`+"/AdvancedSkeleton5.mel";
string $fDet,$fDet2;
int $fileId=`fopen $AdvancedSkeleton5File "r"`;
string $nextLine = `fgetline $fileId`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId;

string $selectorsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/Selector/";
string $selectorFiles[]=`getFileList -fs "*.mel" -fld $selectorsDir`;
for ($i=0;$i<size($selectorFiles);$i++)
	{
	string $selectorFile=$selectorsDir+$selectorFiles[$i];
	int $fileId=`fopen $selectorFile "r"`;
	string $nextLine = `fgetline $fileId`;
	int $copyLines=0;
	$fDet2="";
	while (size($nextLine)>0)
		{
		$fDet2+=$nextLine;
		$nextLine=`fgetline $fileId`;
		if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
			break;
		}
	fclose $fileId;

	int $fileId2=`fopen $selectorFile "w"`;
	fprint $fileId2 ($fDet2+$fDet);
	fclose $fileId2;
print ("// Updated:"+$selectorFiles[$i]+"\n");
	}
}

global proc float asRoundOff (float $value, int $decimals)
{
float $rounded;
if ($value>=0) $rounded=(trunc($value*`pow 10 $decimals`+0.5)/`pow 10 $decimals`);
else $rounded=(trunc(abs($value)*`pow 10 $decimals`+0.5)/`pow 10 $decimals`)*-1;
return $rounded;
}

global proc asSetFixedWrapOptions ()
{
optionVar -intValue autoWeightThreshold 1;
optionVar -intValue exclusiveBind 0;
optionVar -intValue renderInfl 1;
optionVar -stringValue falloffMode "volume";
}

global proc asSwapCurve ()
{
string $side,$oppositeSide;
string $tempString[];
string $sel[]=`ls -sl`;
int $last=`size($sel)`-1;
string $selShapes[];
if (size($sel)<2)
	error "Selected both controls to replace, and the new curve to use";
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	$selShapes[$i]=$tempString[0];
	if (!`objExists $selShapes[$i]`)
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objectType $selShapes[$i]`!="nurbsCurve" && `objectType $selShapes[$i]`!="nurbsSurface")
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	if ($i==$last && `sets -im ControlSet $sel[$i]`)
		error ("\""+$sel[$i]+"\" is a control. The new curve must be select last, and must not be a existing control");
	}
select $sel[$last];
DeleteHistory;
//flip around the replacememnt curve, to make the orientation more intuitive
string $offset=$sel[$last]+"Offset";
if(!(`gmatch $sel[0] "IK*"` || `gmatch $sel[0] "Pole*"`))
	if (!`objExists $offset`)
		{
		$tempString=`listRelatives -s $sel[$last]`;
		for ($y=0;$y<size($tempString);$y++)
			if(!(`gmatch $sel[0] "IK*"` || `gmatch $sel[0] "Pole*"`))
				rotate -r -os -90 -90 0 ($tempString[$y]+".cv[0:99]");
		createNode -n $offset transform;
		asAlign $offset $sel[$last] 1 1 0 0;
		parent $sel[$last] $offset;
		rotate -r -os 90 0 90 $offset;
		}
		
for ($i=0;$i<size($sel)-1;$i++)
	{
	$tempString=`listRelatives -s $sel[$last]`;
	for ($y=0;$y<size($tempString);$y++)
		parent -add -s $tempString[$y] $sel[$i];
	delete $selShapes[$i];
	if (`gmatch $sel[$i] "*_R"` || `gmatch $sel[$i] "*_L"`)
		{
		if (!`objExists ($sel[$last]+"Mirrored")`)
			{
			duplicate -n ($sel[$last]+"Mirrored") $sel[$last];
			setAttr ($sel[$last]+"Mirrored.v") 0;
			int $numCv;
			$form=`getAttr ($sel[$last]+".form")`;
			$spans=`getAttr ($sel[$last]+".spans")`;
			$degrees=`getAttr ($sel[$last]+".degree")`;
			if ($form==2)
				$numCv=$spans;
			else
				$numCv=$spans+$degrees;
			for ($y=0;$y<$numCv;$y++)
				{
				createNode -n ($sel[$last]+"MirroredMultiplyDivide"+$y) multiplyDivide;
				connectAttr ($sel[$last]+".cv["+$y+"]")  ($sel[$last]+"MirroredMultiplyDivide"+$y+".input1");
				setAttr -type float3 ($sel[$last]+"MirroredMultiplyDivide"+$y+".input2") -1 -1 -1;
				connectAttr ($sel[$last]+"MirroredMultiplyDivide"+$y+".output") ($sel[$last]+"Mirrored.cv["+$y+"]");
				}
			}

		if (`gmatch $sel[$i] "*_R"`) {$side="_R";$oppositeSide="_L";}
		if (`gmatch $sel[$i] "*_L"`) {$side="_L";$oppositeSide="_R";}
		if(`gmatch $sel[$i] "IK*"` || `gmatch $sel[$i] "Pole*"`)
			$tempString=`listRelatives -s $sel[$last]`;
		else
			$tempString=`listRelatives -s ($sel[$last]+"Mirrored")`;
		for ($y=0;$y<size($tempString);$y++)
			parent -add -s $tempString[$y] `substitute $side $sel[$i] $oppositeSide`;
		delete `substitute $side $selShapes[$i] $oppositeSide`;
		}
	}
	dgdirty -a;
}

global proc asSetBuildPose (string $uiName)
{
string $controlsSet="ControlSet";
string $fitSkeleton="FitSkeleton";
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	{
	$controlsSet="FaceControlSet";
	$fitSkeleton="FaceFitSkeleton";
	$buildPose="faceBuildPose";
	}
string $controlSetMembers[]=`sets -q $controlsSet`;
string $objAttr,$runCmd,$buildPoseCmd,$newRunCmds;
float $poseValue,$currentValue;
float $runValues[];
string $tempString[],$tempString2[],$runObjAttrs[],$checkObjAttr[];
if (`objExists $fitSkeleton`)
	if (`attributeExists run $fitSkeleton`)
		{
		$runCmd=`getAttr ($fitSkeleton+".run")`;
		$runCmd=`substituteAllString $runCmd "\"" ""`;
		}
if ($runCmd!="")
	tokenize $runCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
	$runValues[size($runValues)]=$tempString2[2];
	}

$buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
tokenize $buildPoseCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	int $loopTimes=0;
	if ($tempString2[0]=="setAttr")
		{
		$objAttr=$tempString2[1];
		$poseValue=$tempString2[2];
		$loopTimes=1;
		$checkObjAttr[0]=$objAttr;
		}
	else if ($tempString2[0]=="xform")
		{
		$loopTimes=9;
		$obj=$tempString2[size($tempString2)-1];
		$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
		$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
		$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
		$poseValue=0;
		}
	for ($z=0;$z<$loopTimes;$z++)
		{
		$currentValue=`getAttr $checkObjAttr[$z]`;
		if($z>5) $poseValue=1;//scale
		//actual poseValue might come from the run attribute//
		for ($y=0;$y<size($runObjAttrs);$y++)
			if ($checkObjAttr[$z]==$runObjAttrs[$y])
				$poseValue=$runValues[$y];

		if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
			$newRunCmds+="setAttr "+$checkObjAttr[$z]+" "+$currentValue+";";
		}
	}

if ($newRunCmds=="")
	{
	print "// No changes to the build pose detected\n";
	return;
	}

string $m="Set the following as default values ?\n\n"+`substituteAllString $newRunCmds ";" "\n"`;
string $confirmResult=`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`;
if ($confirmResult!="Ok")
	return;
if (!`attributeExists run $fitSkeleton`)
	addAttr -ln run -dt "string" $fitSkeleton;
setAttr -type "string" ($fitSkeleton+".run") ($runCmd+";"+$newRunCmds);
}

global proc asfileBrowse (string $tool, string $action)
{
string $fc,$ft;
int $mode=0;
if ($action=="Open")
	{
	$fc="asOpen "+$tool;
	$ft="mel";
	}
if ($action=="SaveAs")
	{
	$fc="asSaveAs "+$tool;
	$ft="mel";
	$mode=1;
	}
if ($action=="Import")
	{
	$fc="as"+$tool+"BackgroundImport";
	$ft="*";
	}
if (`asMayaVersionAsFloat`>=2011)
	eval ($fc+" \""+`fileDialog -dm ("*."+$ft) -m $mode`+"\" "+"fileType");
else
	{
	if (`about -win`)
		fileBrowserDialog -m $mode -fc $fc -ft $ft -an $action;
	else
		fileBrowser $fc $action $ft $mode;
	}
}

global proc astoShelf (string $tool)
{
global string $gShelfTopLevel;
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
if ($projectName=="untitled")
	error "Can not put \"untitled\" on shelf, save your project first\n";

string $cmd="source \""+$projectPath+$projectName+".mel\";";
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
if (`about -mac`)
	$ext=".iff";
$icon=$projectPath+$projectName+"/"+$projectName+"_background32"+$ext;
string $setParent=`setParent -q`;
if (`tabLayout -exists $gShelfTopLevel`)
	{
	string $currentShelf=`tabLayout -query -selectTab $gShelfTopLevel`;
	setParent $currentShelf;
	shelfButton -c $cmd -ann ($tool+":"+$projectName) -label ($tool+":"+$projectName) -i1 $icon
		-st`shelfLayout -query -style $currentShelf`
		-width `shelfLayout -query -cellWidth $currentShelf`
		-height `shelfLayout -query -cellHeight $currentShelf`;
	}
setParent $setParent;
}

global proc string asUniqueFile (string $file)
{
// Copies given file to a random named file, to avoid fileNode cache
string $buffer[];
int $numTok=`tokenize $file "/" $buffer`;
string $path="";
if (`gmatch $file "/*"`)
	$path="/";
for ($i=0;$i<($numTok-1);$i++)
	$path+=$buffer[$i]+"/";
$numTok=`tokenize $file "." $buffer`;
string $ext=$buffer[$numTok-1];
string $randNumber=`rand 42`;
string $uniqueFile=$path+"unique"+`substituteAllString $randNumber "." ""`+"."+$ext;
sysFile -cp $uniqueFile $file;
return $uniqueFile;
}

global proc string[] asGetControlSets ()
{
string $controlSets[];
string $sets[]=`ls -type objectSet`;
for ($i=0;$i<size($sets);$i++)
	{
	if (!`sets -q -r $sets[$i]` && !`sets -q -v $sets[$i]` && !`sets -q -eg $sets[$i]` && !`sets -q -fc $sets[$i]` && !`sets -q -ep $sets[$i]`)
		if (`gmatch $sets[$i] "*[c-C]ontrol[s-S]et*"`)
			$controlSets[size($controlSets)]=$sets[$i];
	}
return $controlSets;
}

//-- AS IO Procedures (for tools) Starts Here --//
global proc int asOpen (string $tool, string $fileName, string $fileType)
{
global int $asfileLoading;
string $sel[]=`ls -sl`;
select -cl;
string $projectName=`basename $fileName ".mel"`;
string $projectPath=`dirname $fileName`+"/";
string $asIconLocation=$projectPath+$projectName+"/";
int $anim;
string $bgExt=".tga";
if (`about -mac`)
	$bgExt=".iff";

if ($tool=="Poser")
	asPoserDesigner;

evalEcho ("source \""+$fileName+"\";\n"
	+"as"+$tool+$projectName);
window -e -i 1 ("as"+$tool+$projectName);

if ($tool=="Poser")
	{
	$asfileLoading=1;
	string $gridOrder[]=`gridLayout -q -go ("asPoser"+$projectName+"GridLayout")`;
	int $nc=`gridLayout -q -nc ("asPoser"+$projectName+"GridLayout")`;
	int $nr=`gridLayout -q -nr ("asPoser"+$projectName+"GridLayout")`;
	intField -e -v $nc asPoserNc;
	intField -e -v $nr asPoserNr;
	asPoserUpdateGrid;
	int $childNum,$lenght;
	string $uiName="asPoserDefault";
	string $loadData[];
	$loadData[0]=$uiName;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] ("asPoser"+$projectName+"ColumnLayout*")`)
			{
			$image=`iconTextButton -q -i ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$loadData[1]=$image;
//			$label=`iconTextButton -q -l ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$label=`text -q -l ("asPoser"+$projectName+"Text"+$childNum)`;
			$loadData[2]=$label;
			$cmd=`iconTextButton -q -c ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$cmd=`substitute ("asPoser"+$projectName)  ("\""+$cmd+"\"") $uiName`;
			$lenght=size($cmd);
			$loadData[3]=`substring $cmd 2 ($lenght-1)`;
			$loadData[4]=$childNum;
			$anim=0;
			if (!`gmatch $cmd "*asSetAttrs *"`)
				$anim=1;
			$loadData[5]=$anim;
			asNewPose $loadData $anim;
			}
		}
	}
if ($tool=="Selector")
	{
	asSelectorDesigner;
	$asfileLoading=1;
	
	window -e -w `window -q -w ("asSelector"+$projectName)` -h `window -q -h ("asSelector"+$projectName)` asSelectorDefault;
	asSelectorBackgroundImport ($asIconLocation+$projectName+"_background"+$bgExt) "image";
	
	int $width,$height,$msg0AsInt,$msg1AsInt;
	string $iol;
	string $buffer[],$msgs[];
	//restore controlSets
	string $controlSetsText,$controlSets[];
	if (`text -q -ex ("asSelector"+$projectName+"ControlSetsText")`)
		{
		$controlSetsText=`text -q -l ("asSelector"+$projectName+"ControlSetsText")`;
		$controlSets=`stringToStringArray $controlSetsText " "`;
		if (`menuItem -q -ex ControlSet`)
			menuItem -e -cb 0 ControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if (`menuItem -q -ex $controlSets[$i]`)
				menuItem -e -cb 1 $controlSets[$i];
		}

	string $ctls[]=`formLayout -q -ca ("asSelector"+$projectName+"FormLayout")`;
	int $mirrorButtons=`optionVar -q asSelectorMirrorButtons`;
	optionVar -iv asSelectorMirrorButtons 0;
	for ($ctl in $ctls)
		if (`iconTextButton -q -ex $ctl` && !`gmatch $ctl "*BGPicture"`)
			{
			tokenize $ctl ":" $buffer;
			$msg0AsInt=$msgs[0]=$buffer[size($buffer)-2];
			$msg1AsInt=$msgs[1]=$buffer[size($buffer)-1];
			$width=`iconTextButton -q -w $ctl`;
			$height=`iconTextButton -q -h $ctl`;
			$iol=`iconTextButton -q -iol $ctl`;
			$cmd=`iconTextButton -q -c $ctl`;
			$cmd=`substitute ("\""+$projectName+"\"") (""+$cmd) "\"Default\""`;
			$buttonName=`substitute $projectName $ctl ""`;
			$ann=`iconTextButton -q -ann $ctl`;
			$msgs[2]=$iol;
			$msgs[3]=$cmd;
			$msgs[4]=$buttonName;
			$msgs[6]=$ann;
			renameUI $ctl ("deleteMeUI"+$ctl);
			asSelectorDpc "asSelectorBGImage"  "asSelectorBGImage" $msgs ($msg0AsInt+$width-4) ($msg1AsInt+$height-5) 2;
			}
	optionVar -iv asSelectorMirrorButtons $mirrorButtons;
	evalDeferred -lp asSelectorRefresh;
	}

//evalDeferred ("deleteUI as"+$tool+$projectName);
text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");
$asfileLoading=0;
select $sel;

return 1;
}

global proc int asSaveAs (string $tool, string $fileName, string $fileType)
{
if ($fileName=="")
	return 0;
string $sel[]=`ls -sl`;
string $projectName;
string $buffer[];
int $numFileNameChar=size ($fileName);
tokenize $fileName "/" $buffer;
string $file=$buffer[size($buffer)-1];
int $numFileChar=size ($file);
tokenize $file "." $buffer;
$projectName=$buffer[0];
string $tempTrn=`createNode transform`;
$projectName=`createNode -p $tempTrn -n $projectName transform`;
delete $tempTrn;
tokenize $projectName "|" $buffer;
$projectName=$buffer[size($buffer)-1];
string $projectPath=`substring $fileName 1 ($numFileNameChar-$numFileChar)`;

string $previousProjectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $previousProjectName=`text -q -l ("as"+$tool+"ProjectName")`;

text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
asSave $tool;

select $sel;
return 1;
}

global proc asSave (string $tool)
{
if (`text -q -l ("as"+$tool+"ProjectName")`=="untitled")
	{
	asfileBrowse $tool "SaveAs";
	return;
	}
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
string $projectFile=$projectPath+$projectName+".mel";
string $installFile=$projectPath+$projectName+"/install.mel";
string $asIconLocation=$projectPath+$projectName+"/";
string $ext=".xpm";
string $bgExt=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=$bgExt=".png";
if (`about -linux`)
	$ext=".xpm";
string $tmpDir=`internalVar -utd`;
string $tmpIconDir=$tmpDir+"AdvancedSkeleton/"+$tool+"/untitled/";
string $uiName="as"+$tool+$projectName;
string $bgc;
string $buffer[];
string $fDet="";
$fDet+="//This file has been generated by AdvancedSkeleton"+$tool+"//\n";
$fDet+="//Using AdvancedSkeleton Version: "+`asGetScriptVersion`+"//\n";
$fDet+="\n";
$fDet+="global proc "+$uiName+" ()\n";
$fDet+="{\n";
$fDet+="if (`window -q -ex "+$uiName+"`)\n";
$fDet+="\tdeleteUI "+$uiName+";\n";
$fDet+="\n";
$fDet+="string $asSelectorScriptLocation=`asSelectorScriptLocation`;\n";
$fDet+="string $asIconLocation=$asSelectorScriptLocation+\""+$projectName+"/\";\n";
$fDet+="window -rtf 1 -mb 1 -t "+$projectName+" "+$uiName+";\n";
$fDet+="menu -l Edit;\n";
$fDet+="\tmenuItem -l Refresh -c \"asPopulateNameSpaceMenu "+$uiName+"\";\n";
$fDet+="\tmenuItem -l Filter -c \"asFilterNameSpaceMenuUI "+$uiName+"\";\n";
$fDet+="\tsetParent..;\n";
if ($tool=="Selector")
	{
	$fDet+="menu -l Display;\n";
	$fDet+="\tmenuItem -l Controls -c asControlsVisibilityToggle;\n";
	$fDet+="\tmenuItem -l \"Set HotKey\" -c asSetupControlVisibilityHotKeyDialog;\n";
	$fDet+="\tmenuItem -l Joints -c asJointsVisibilityToggle;\n";
	$fDet+="\tmenuItem -l GimbalLock -c \"asVisualizeGimbalLock "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Pose -aob 1;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"PosePaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Reset -c \"asGoToBuildPose "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l Mirror -c \"asMirror "+$uiName+"\";\n";
	$fDet+="\tmenuItem -optionBox 1 -c \"asMirrorOptions "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Anim;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 1\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"AnimPaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Clean -c \"asDeleteStaticChannels "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asAnimBake "+$uiName+"\";\n";
	$fDet+="menu -l Dynamics;\n";
	$fDet+="\tmenuItem -l \"Add to selected\" -c \"asDynAdd "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Remove from selected\" -c \"asDynRemove "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Set Initial State\" -c \"evalEcho saveInitialState -all\";\n";
	$fDet+="\tmenuItem -l \"Interactive Playback\" -c \"evalEcho InteractivePlayback\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asDynBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l UnBake -c \"asDynUnBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	}
$fDet+="\n";

//controlsets
string $controlSetsText;
string $menuItems[];
if (`menu -q -ex ("as"+$tool+"ControlSetsMenu")`)
	{
	$menuItems=`menu -q -ia ("as"+$tool+"ControlSetsMenu")`;
	for ($i=0;$i<size($menuItems);$i++)
		if (`menuItem -q -cb $menuItems[$i]`)
			$controlSetsText+=$menuItems[$i]+" ";
	}

//remove old files & copy files from `untitled`
string $fileList[];
if (`file -q -ex ($projectPath+$projectName)`)
	{
	$fileList=`getFileList -fld ($projectPath+$projectName+"/")`;
	for ($file in $fileList)
		sysFile -del ($projectPath+$projectName+"/"+$file);
	}
else
	sysFile -md ($projectPath+$projectName);
$fileList=`getFileList -fld $tmpIconDir`;
for ($file in $fileList)
	if (!`gmatch $file "*.tif"`)
		sysFile -cp ($projectPath+$projectName+"/"+`substitute ("untitled_") $file ($projectName+"_")`) ($tmpIconDir+$file);

window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");

if ($tool=="Poser")
	{
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="optionMenu -cc \"asCharChange "+$uiName+"\" "+$uiName+"OptionMenu;\n";
	$fDet+="scrollLayout "+$uiName+"ScrollLayout;\n";
	int $cw=`gridLayout -q -cw asPoserDefaultGridLayout`;
	int $ch=`gridLayout -q -ch asPoserDefaultGridLayout`;
	int $nc=`intField -q -v asPoserNc`;
	int $nr=`intField -q -v asPoserNr`;
	$fDet+="gridLayout -cw "+$cw+" -ch "+$ch+" -nc "+$nc+" -nr "+$nr+" "+$uiName+"GridLayout;\n";


	$fDet+="formLayout -e\n";
	$fDet+="	-af "+$uiName+"OptionMenu \"top\" 0\n";
	$fDet+="	-ac "+$uiName+"ScrollLayout \"top\" 0 "+$uiName+"OptionMenu\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"bottom\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"left\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"right\" 0\n";
	$fDet+="	"+$uiName+"FormLayout;\n";
	$fDet+="\n";
	$fDet+="\n";

	string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
	int $childNum,$doConnectControl;
	string $cmd,$label,$ann,$animAnn;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] "asPoser*"`)
			{
			$iconTextButton=("asPoserDefaultIconTextButton"+$childNum);
			$floatSlider=("asPoserDefaultFloatSlider"+$childNum);
			$text=("asPoserDefaultText"+$childNum);
			$label=`text -q -l $text`;
			$doConnectControl=`floatSlider -q -m $floatSlider`;
			$ann=`floatSlider -q -ann $floatSlider`;
			$cmd=`iconTextButton -q -c $iconTextButton`;
			$cmd=`substitute  "asPoserDefault" $cmd $uiName`;
			$cmd=`substitute  "untitled_" $cmd ($projectName+"_")`;
			$cmd=`encodeString $cmd`;
			$bgc="";
			if (!`gmatch $cmd "asSetAttrs *"`)
				$bgc=" -bgc 1 0 0";
			$fDet+="string $cmd=\""+$cmd+"\";\n";
			$image=`iconTextButton -q -i $iconTextButton`;
			tokenize ("\""+$image+"\"") "/" $buffer;
			tokenize $buffer[size($buffer)-1] "." $buffer;
			$imageNr=`match "[0-9]+$" $buffer[0]`;
			$animAnn=`rowColumnLayout -q -ann ("asPoserDefaultRowColumnLayout"+$childNum)`;

			$fDet+="setParent "+$uiName+"GridLayout;\n";
			$fDet+="columnLayout "+$uiName+"ColumnLayout"+$childNum+";\n";
			$fDet+="rowColumnLayout -ann "+$animAnn+" -nc 2 -cw 1 100 -cw 2 15 "+$uiName+"RowColumnLayout"+$childNum+";\n";
			$fDet+="iconTextButton -w 100 -h 75 -i ($asIconLocation+\""+$projectName+"_"+$imageNr+$ext+"\") -c $cmd "+$uiName+"IconTextButton"+$childNum+";\n";
			float $min=`floatSlider -q -min $floatSlider`;
			float $max=`floatSlider -q -max $floatSlider`;
			$fDet+="floatSlider -ann \""+$ann+"\" -m "+$doConnectControl+" -min "+$min+" -max "+$max+" -w 10 -h 75 -hr 0 "+$uiName+"FloatSlider"+$childNum+";\n";
			$fDet+="text -h 15 -al \"center\" -fn \"smallBoldLabelFont\" -l \""+$label+"\""+$bgc+" "+$uiName+"Text"+$childNum+";\n";

			//place it
			$fDet+="gridLayout -e -pos "+$uiName+"ColumnLayout"+$childNum+" "+$childNum+" "+$uiName+"GridLayout;\n";

			//popups
			$fDet+="asPoserupdateGridBlock "+$uiName+" "+$childNum+";\n";

			$fDet+="\n";
			}
		}

	$fDet+="\n";
	$fDet+="asPopulateNameSpaceMenu as"+$tool+$projectName+";\n";
	$fDet+="asCharChange "+$uiName+";\n";
	$fDet+="evalDeferred \"showWindow;\";\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}
if ($tool=="Selector")
	{
	int $pictureWidth=`text -q -l asSelectorBackgroundWidth`;
	int $pictureHeight=`text -q -l asSelectorBackgroundHeight`;
	
	string $allCtls[]=`formLayout -q -ca asSelectorDefaultFormLayout`;
	string $ctlName[],$ctlType[],$ctlWidth[],$ctlHeight[],$ctlLeft[],$ctlTop[],$ctlImage[],$ctlCmd[],$ctlIol[],$ctlAnn[];
	string $ctlKeyCmd[],$ctlLinearKeyCmd[];
	string $ctlAlignFK2IKCmd[],$ctlAlignIK2FKCmd[],$ctlSwitchFK2IKCmd[],$ctlSwitchIK2FKCmd[];
	string $buffer[],$tempString[],$menuItems[];
	int $numTok;
	string $shortImageFileName,$oldProjectName;
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$ctlName[$i]=`substitute "asSelector" $allCtls[$i] $uiName`;
		if (`image -q -ex $allCtls[$i]`)
			$ctlType[$i]="image";
		if (`iconTextButton -q -ex $allCtls[$i]`)
			$ctlType[$i]="iconTextButton";
		$ctlWidth[$i]=`control -q -w $allCtls[$i]`;
		$ctlHeight[$i]=`control -q -h $allCtls[$i]`;
		$numTok=`tokenize $allCtls[$i] ":" $buffer`;
		$ctlLeft[$i]=$buffer[$numTok-2];
		$ctlTop[$i]=$buffer[$numTok-1];
		if ($ctlType[$i]=="iconTextButton")
			{
			$ctlImage[$i]=`eval ($ctlType[$i]+" -q -i \""+$allCtls[$i]+"\"")`;
			tokenize $ctlImage[$i] "/" $buffer;
			$shortImageFileName=$buffer[size($buffer)-1];
			tokenize $shortImageFileName "_" $buffer;
			$oldProjectName=$buffer[0];
			for ($b=1;$b<size($buffer)-3;$b++)
				$oldProjectName+="_"+$buffer[$b];
			$ctlImage[$i]=`substitute ($oldProjectName+"_") $shortImageFileName ($projectName+"_")`;
			$ctlCmd[$i]=`eval ($ctlType[$i]+" -q -c \""+$allCtls[$i]+"\"")`;
			$ctlCmd[$i]=`substitute "\"Default\"" $ctlCmd[$i] ("\""+$projectName+"\"")`;
			$ctlCmd[$i]="\""+`encodeString $ctlCmd[$i]`+"\"";
			$ctlAnn[$i]=`eval ($ctlType[$i]+" -q -ann \""+$allCtls[$i]+"\"")`;
			$ctlIol[$i]=`eval ($ctlType[$i]+" -q -iol \""+$allCtls[$i]+"\"")`;
			$tempString=`eval ($ctlType[$i]+" -q -pma \""+$allCtls[$i]+"\"")`;
			$menuItems=`popupMenu -q -ia $tempString[0]`;
			$ctlKeyCmd[$i]=`menuItem -q -c $menuItems[0]`;
			$ctlKeyCmd[$i]=`substitute "\"Default\"" $ctlKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlKeyCmd[$i]="\""+`encodeString $ctlKeyCmd[$i]`+"\"";
			$ctlLinearKeyCmd[$i]=`menuItem -q -c $menuItems[1]`;
			$ctlLinearKeyCmd[$i]=`substitute "\"Default\"" $ctlLinearKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlLinearKeyCmd[$i]="\""+`encodeString $ctlLinearKeyCmd[$i]`+"\"";
			if (size($menuItems)>6)
				{
				$subMenuItems=`menu -q -ia $menuItems[6]`;
				$ctlAlignFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlAlignFK2IKCmd[$i]=`substitute "\"Default\"" $ctlAlignFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignFK2IKCmd[$i]="\""+`encodeString $ctlAlignFK2IKCmd[$i]`+"\"";
				$ctlAlignIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlAlignIK2FKCmd[$i]=`substitute "\"Default\"" $ctlAlignIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignIK2FKCmd[$i]="\""+`encodeString $ctlAlignIK2FKCmd[$i]`+"\"";
				$subMenuItems=`menu -q -ia $menuItems[7]`;
				$ctlSwitchFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlSwitchFK2IKCmd[$i]=`substitute "\"Default\"" $ctlSwitchFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchFK2IKCmd[$i]="\""+`encodeString $ctlSwitchFK2IKCmd[$i]`+"\"";
				$ctlSwitchIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlSwitchIK2FKCmd[$i]=`substitute "\"Default\"" $ctlSwitchIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchIK2FKCmd[$i]="\""+`encodeString $ctlSwitchIK2FKCmd[$i]`+"\"";
				}
			}
		}

	$fDet+="columnLayout -adj 1;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="rowLayout -nc 4 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 80 -cw 4 60;\n";
	$fDet+="optionMenu -cc asSelChange "+$uiName+"OptionMenu;\n";
	$fDet+="button -l set -c \"asSetNameSpaceFromSelection "+$uiName+"\";\n";
	$fDet+="checkBox -v `optionVar -q asShowSelection` -onc \"asSelChangeToggle;optionVar -iv asShowSelection 1\" -ofc \"asSelChangeToggle;optionVar -iv asShowSelection 0\" -l Selection "+$uiName+"SelectionCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowKeyed` -onc \"asSelChangeToggle;optionVar -iv asShowKeyed 1\" -ofc \"asSelChangeToggle;optionVar -iv asShowKeyed 0\" -l Keyed "+$uiName+"KeyedCheckBox;\n";
	$fDet+="setParent..;\n";
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="\n";

	$fDet+="//Controls Begin//\n";
	if (`about -mac` || `about -linux`)
		$fDet+="iconTextButton -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	else
		$fDet+="image -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+=$ctlType[$i]+" -w "+$ctlWidth[$i]+" -h "+$ctlHeight[$i];
		if ($ctlImage[$i]!="")
			$fDet+=" -i ($asIconLocation+\""+$ctlImage[$i]+"\")";
		if ($ctlImage[$i]!="")
			$fDet+=" -iol \""+$ctlIol[$i]+"\"";
		if ($ctlCmd[$i]!="")
			$fDet+=" -c "+$ctlCmd[$i];
		if ($ctlAnn[$i]!="")
			$fDet+=" -ann \""+$ctlAnn[$i]+"\"";
		$fDet+=" \""+$ctlName[$i]+"\";\n";
		$fDet+="popupMenu;\n";
		$fDet+="\tmenuItem -l Key -c "+$ctlKeyCmd[$i]+";\n";
		$fDet+="\tmenuItem -l LinearKey -c "+$ctlLinearKeyCmd[$i]+";\n";
		if ($ctlAlignFK2IKCmd[$i]!="")
			{
			$fDet+="\tmenuItem -d 1;\n";
			$fDet+="\tmenuItem -l Align -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlAlignFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlAlignIK2FKCmd[$i]+";\n";
			$fDet+="\t\tsetParent -menu ..;\n";
			$fDet+="\tmenuItem -l Switch -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlSwitchFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlSwitchIK2FKCmd[$i]+";\n";
			}
		}
	$fDet+="//Controls End//\n";
	$fDet+="\n";
	$fDet+="formLayout -e\n";
	for ($i=0;$i<size($ctlType);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+="\t-af \""+$ctlName[$i]+"\" left "+$ctlLeft[$i]+"\n";
		$fDet+="\t-af \""+$ctlName[$i]+"\" top "+$ctlTop[$i]+"\n";
		}
	$fDet+="\t"+$uiName+"FormLayout;\n";
	
	$fDet+="\n\n\n\n";
	
	$fDet+="asPopulateNameSpaceMenu \"asSelector"+$projectName+"\";\n";
	$fDet+="asShowSelJob;\n";
	$fDet+="asSelChange;\n";
	$fDet+="showWindow;\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}

string $AdvancedSkeleton5File=`asGetScriptLocation`+"/AdvancedSkeleton5.mel";
int $fileId2=`fopen $AdvancedSkeleton5File "r"`;
string $nextLine = `fgetline $fileId2`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId2`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId2;

int $fileId=`fopen $projectFile "w"`;
fprint $fileId $fDet;
fclose $fileId;

//$installFile
$fDet="";
string $AdvancedSkeletonInstallFile=`asGetScriptLocation`+"/install.mel";
if (!`file -q -ex $AdvancedSkeletonInstallFile`)
	return;
$fileId=`fopen $AdvancedSkeletonInstallFile "r"`;
$nextLine = `fgetline $fileId`;
int $installTemplatePause;
while ( size( $nextLine ) > 0 )
	{
	$nextLine = `fgetline $fileId`;
	if ($nextLine=="//--installTemplate pause--//\n")
		$installTemplatePause=1;
	if ($nextLine=="//--installTemplate resume--//\n")
		{
		$installTemplatePause=0;
		continue;
		}
	if ($installTemplatePause)
		continue;
	if (`gmatch $nextLine "string $scriptName=*"`)
		{
		$fDet+=("string $scriptName=\""+$projectName+"\";\n");
		}
	else if (`gmatch $nextLine "string $sourceFile=*"`)
		{
		$fDet+=("string $sourceFile=$asInstallScriptLocation+\"../\"+$scriptName+\".mel\";\n");
		}
	else if (`gmatch $nextLine "string $icon=*"`)
		{
		$fDet+=("string $icon=$asInstallScriptLocation+\""+$projectName+"_background32.png\";\n");
		}
	else if (`gmatch $nextLine "string $command=*"`)
		{
		$fDet+=("string $command=\"source \\\"\"+$sourceFile+\"\\\"\";\n");
		}
	else
		$fDet+=$nextLine;
	}
fclose $fileId;

$fileId=`fopen $installFile "w"`;
fprint $fileId $fDet;
fclose $fileId;
}
//-- AS IO Procedures (for tools) Ends Here --//


//-- ASTools Procedures Starts Here --//
global proc asSelChange ()
{
global int $asfileLoading;
global int $asSelChangeSwitching;
if ($asfileLoading)
	return;
if (!`optionVar -q asShowSelection` && !`optionVar -q asShowKeyed`)
	return;
string $sel[]=`ls -sl`;
string $name,$obj,$nodeType,$projectName,$ann;
string $ctls[],$buffer[],$connections[];
int $numLetters,$numTok,$keyed;
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
if (`about -mac`)
	$ext=".iff";
if (`about -linux`)
	$ext=".xpm";
string $currImage,$buttonImageFile,$buttonImageFileOnK0,$buttonImageFileOnK1,$buttonImageFileOffK0,$buttonImageFileOffK1;
string $windows[]=`lsUI -windows`;
string $layout;
for ($window in $windows)
	{
	$layout="";
	if (size($window)>11)
		$layout="asSelector"+`substring $window 11 999`+"FormLayout";
	if (!`formLayout -q -ex $layout`)
		continue;
	$numLetters=size($layout);
	$name=`substring $layout 11 ($numLetters-10)`;
	$ctls=`formLayout -q -ca $layout`;
	for ($ctl in $ctls)
		{
		if (!`iconTextButton -q -ex $ctl`)
			continue;
		if (`optionVar -q asShowSelection` && !$asSelChangeSwitching)
			$selState="On";
		else
			$selState="Off";
		$keyed=0;
		$ann=`iconTextButton -q -ann $ctl`;
		$numTok=`tokenize $ann ";" $buffer`;
		for ($i=0;$i<$numTok;$i++)
			{
			$obj=`asSelectorResolveNameSpace $name $buffer[$i]`;
			if (!`stringArrayCount $obj $sel`)
				$selState="Off";
			if (`optionVar -q asShowKeyed` && !$asSelChangeSwitching && `objExists $obj`)
				{
				$connections=`listConnections -s 1 -d 0 $obj`;
				for ($node in $connections)
					{
					$nodeType=`objectType $node`;
					if (`gmatch $nodeType "animCurve*"`)
						$keyed=1;
					}
				}
			}

		$currImage=`iconTextButton -q -i1 $ctl`;
		if ($currImage=="")
			return;
		$numTok=`tokenize $currImage "_" $buffer`;
		if ($numTok<3)
			continue;
		$projectName=$buffer[0];
		for ($b=1;$b<size($buffer)-3;$b++)
			$projectName+="_"+$buffer[$b];
		$buttonImageFile=$projectName+"_"+$buffer[$numTok-3]+"_"+$buffer[$numTok-2]+"_"+$selState+"K"+$keyed+$ext;

		if ($buttonImageFile!=$currImage)
			iconTextButton -e -i $buttonImageFile $ctl;		
		}
	}
}

global proc float asMayaVersionAsFloat ()
{
float $version=2012;
if (`exists getApplicationVersionAsFloat`)
	return `getApplicationVersionAsFloat`;
string $versionString=`about -v`;
string $tempString[];
string $char;
tokenize $versionString $tempString;
//default to 2012, if versionString is not all numbers
for ($i=0;$i<size($tempString[0]);$i++)
	{
	$char=`substring $tempString[0] ($i+1) ($i+1)`;
	if (!`gmatch $char "[0-9]"`)
		return 2012;
	}
$version=$tempString[0];
return $version;
}

global proc asSelChangeToggle ()
{
global int $asSelChangeSwitching;
$asSelChangeSwitching=1;
string $sel[]=`ls -sl`;
select -cl;
asSelChange;
$asSelChangeSwitching=0;
select $sel;
}

global proc asCharChange (string $uiName)
{
string $gridOrder[];
if (`gridLayout -q -ex ($uiName+"GridLayout")`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`floatSlider -q -ex ($uiName+"FloatSlider"+$i)`)
			{
			$ann=`floatSlider -q -ann ($uiName+"FloatSlider"+$i)`;
			$resolvedName=`asPoserResolveNameSpace $uiName $ann`;
			if (`objExists $resolvedName`)
				connectControl ($uiName+"FloatSlider"+$i) $resolvedName;
			}
	}
asSelChange;
}

global proc asShowSelJob ()
{
global int $asSelChangeScripJobNr;
if ($asSelChangeScripJobNr)
	return;
$asSelChangeScripJobNr=`scriptJob -e "SelectionChanged" "asSelChange"`;
}

global proc string asSelectorResolveNameSpace (string $name, string $obj)
{
string $nameSpace=`optionMenu -q -v ("asSelector"+$name+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
return ($nameSpace+$obj);
}

global proc asSelect (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

int $modifier=`getModifiers`;
if (($modifier %  2)==0)
	select -cl;
if ($objs[0]=="")
	{
	select -cl;
	return;
	}
for ($obj in $objs)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
for ($obj in $objs)
	select -tgl $obj;
//enable hotKeys
string $formLayout="asSelector"+$name+"FormLayout";
if (`formLayout -q -ex $formLayout`)
	setFocus $formLayout;
}

global proc asKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe $obj;
select `ls -sl`;
asSelChange;
}

global proc asLinearKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe -itt linear -ott linear $obj;
select `ls -sl`;
asSelChange;
}

global proc asAlignIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "IK2FK";
}

global proc asAlignFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "FK2IK";
}

global proc asSwitchIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "IK2FK";
}

global proc asSwitchFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "FK2IK";
}

global proc asAssembleAlignSwitchCmd (string $name, string $objs[], string $alignSwitchCmd, string $W2K)
{
int $numLetters=size($objs[0]);
string $IK=`substring $objs[0] 5 ($numLetters-2)`;
string $side=`substring $objs[0] ($numLetters-1) $numLetters`;
eval ($alignSwitchCmd+" "+$name+" "+$IK+" "+$side+" "+$W2K);
}

global proc asAlignFKIK (string $name, string $IK, string $side, string $W2K)
{
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $tempLoc1[],$tempLoc2[],$tempConstraint[];
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$endJoint+$side),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"FKX"+$endJoint+$side),
	($nameSpace+"Pole"+$IK+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
float $charsize=`getAttr ($nameSpace+"Main.height")`;
float $tempFloat[],$alignIkToFloat[];
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;

if ($W2K=="FK2IK")
	{
	$tempFloat=`xform -q -ws -t ($nameSpace+"FK"+$endJoint+$side)`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	$tempLoc1=`spaceLocator`;
	$tempConstraint=`pointConstraint ($nameSpace+"FKX"+$startJoint+$side) ($nameSpace+"FKX"+$endJoint+$side) $tempLoc1[0]`;
	delete $tempConstraint[0];
	$tempConstraint=`aimConstraint -aimVector 1 0 0 ($nameSpace+"FKX"+$middleJoint+$side) $tempLoc1[0]`;
	$tempLoc2=`spaceLocator`;
	parent $tempLoc2[0] $tempLoc1[0];
	setAttr -type float3 ($tempLoc2[0]+".translate") ($charsize/3.333) 0 0;
	$tempFloat=`xform -q -ws -t $tempLoc2[0]`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"Pole"+$IK+$side);
	delete $tempLoc1;
	$tempFloat=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$endJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
			setAttr ($nameSpace+"IK"+$IK+$side+".roll") 0;
	}
else
	{
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$startJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$startJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$middleJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$middleJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$endJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$endJoint+$side);
	if (`objExists ($nameSpace+"IKXToes"+$side)`)
		{
		$tempFloat=`xform -q -ws -ro ($nameSpace+"IKXToes"+$side)`;
		xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FKToes"+$side);
		}
	}

if ($autoKey)
	autoKeyframe -st 1;
select $sel;
}

global proc asSwitchFKIK (string $name, string $IK, string $side, string $W2K)
{
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
string $poleCurve=$nameSpace+"Pole"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$endJoint+$side),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"FKX"+$endJoint+$side),
	($nameSpace+"Pole"+$IK+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
int $Blend;
int $BlendInverse=10;
int $onOff;
if ($W2K=="FK2IK")
	{
	$Blend=10;
	$BlendInverse=0;
	$onOff=1;
	}

if ($W2K=="FK2IK" && `getAttr ($controlCurve+".FKIKBlend")`>0)
	{
	warning ("Could not switch FK2IK, because \"FKIKBlend\" is not \"0\"\n");
	return;
	}
if ($W2K=="IK2FK" && `getAttr ($controlCurve+".FKIKBlend")`<10)
	{
	warning ("Could not switch IK2FK, because \"FKIKBlend\" is not \"10\"\n");
	return;
	}

int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;

currentTime (`currentTime -q` -1);
setAttr ($controlCurve+".FKIKBlend") $BlendInverse;
setKeyframe ($controlCurve+".FKIKBlend");
setKeyframe ($poleCurve+".follow");	

setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");

if (`objExists ($nameSpace+"IKXToes"+$side)`)
	{
	setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
	if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
		setKeyframe ($nameSpace+"IK"+$IK+$side+".roll");
	}

currentTime (`currentTime -q` +1);


asAlignFKIK $name $IK $side $W2K;


setAttr ($controlCurve+".FKIKBlend") $Blend;
setAttr ($poleCurve+".follow") 0;

setKeyframe ($controlCurve+".FKIKBlend");
setKeyframe ($poleCurve+".follow");

setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");
if (`objExists ($nameSpace+"IKXToes"+$side)`)
	{
	setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
	if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
		setKeyframe ($nameSpace+"IK"+$IK+$side+".roll");
	}

if ($autoKey)
	autoKeyframe -st 1;
select $sel;
}

global proc asPopulateNameSpaceMenu (string $name)
{
string $optionMenu=$name+"OptionMenu";
string $nameSpacesList[]=`namespaceInfo -lon`;
$nameSpacesList=`stringArrayRemove {"UI"} $nameSpacesList`;
$nameSpacesList[size($nameSpacesList)]="";
string $itemList[]=`optionMenu -q -ils $optionMenu`;
$nameSpacesList=`sort $nameSpacesList`;
for ($item in $itemList)
	deleteUI $item;

for ($nameSpace in $nameSpacesList)
	if (`objExists ($nameSpace+":Main")`)
		if (`attributeExists "version" ($nameSpace+":Main")`)
			if (`asFilterCheck $name $nameSpace`)
				menuItem -p $optionMenu -l ($nameSpace+":");

if (!`optionMenu -q -ni ($name+"OptionMenu")`)
	{
	if ($name=="bodySetup" || `gmatch $name "asPoser*"`)
		menuItem -p $optionMenu -l "None";
	else
		menuItem -p $optionMenu -l ":";
	}
}

global proc int asFilterCheck (string $name, string $nameSpace)
{
int $result=0;
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="" || $filterString=="0")
	return 1;
string $references[]=`file -q -r`;
for ($i=0;$i<size($references);$i++)
	{
	$refNameSpace=`file -q -ns $references[$i]`;
	if ($refNameSpace==$nameSpace)
		if (`gmatch $references[$i] $filterString`)
			$result=1;
	}
return $result;
}

global proc asFilterNameSpaceMenuUI (string $name)
{
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="0")
	$filterString="";
if (`window -q -ex ("SelectorFilter_"+$name)`)
	deleteUI ("SelectorFilter_"+$name);
window ("SelectorFilter_"+$name);
columnLayout;
textFieldGrp -tx $filterString -cc ("asSetFilterNameSpaceMenu "+$name) -l "Reference File Filter. (e.g. *characters*)" -cw 1 200 ("asSelectorFilterTextFieldGrp_"+$name);
showWindow;
}

global proc asSetFilterNameSpaceMenu (string $name)
{
string $filterString=`textFieldGrp -q -tx ("asSelectorFilterTextFieldGrp_"+$name)`;
optionVar -sv ("asSelectorFilter_"+$name) $filterString;
asPopulateNameSpaceMenu $name;
}

global proc asSetNameSpaceFromSelection (string $uiName)
{
asPopulateNameSpaceMenu $uiName;
string $sel[]=`ls -sl`;
string $tempString[],$ils[];
if (size($sel))
	{
	tokenize $sel[0] ":" $tempString;
	$ils=`optionMenu -q -ils ($uiName+"OptionMenu")`;
	for ($i=0;$i<size($ils);$i++)
		if (`menuItem -q -l $ils[$i]`==($tempString[0]+":"))
			{
			optionMenu -e -sl ($i+1) ($uiName+"OptionMenu");
			asSelChange;
			}
	}
print "// Setting nameSpace from selected object\n";
}

global proc asCopyToClipBoard (string $uiName, int $anim)
{
string $cmd=`asPoserGetCmd $uiName $anim`;
if (!$anim)
	menuItem -e -en 1 -c $cmd ($uiName+"PosePaste");
else
	menuItem -e -en 1 -c ($cmd+" 0") ($uiName+"AnimPaste");
}

global proc string[] asGetControlSetsFromUI (string $uiName)
{
string $controlSets[];
string $tempString[];
string $controlSetsText;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (`text -q -ex ($uiName+"ControlSetsText")`)
	{
	$controlSetsText=`text -q -l ($uiName+"ControlSetsText")`;
	tokenize $controlSetsText $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists ($nameSpace+$tempString[$i])`)
			$controlSets[size($controlSets)]=$nameSpace+$tempString[$i];
	}
else if ($uiName=="asPoserDefault" && `menuItem -q -ex asPoserControlSetsMenu`)
	{
	$tempString=`menu -q -ia asPoserControlSetsMenu`;
	for ($i=0;$i<size($tempString);$i++)
		if (`menuItem -q -cb $tempString[$i]`)
			$controlSets[size($controlSets)]=$nameSpace+`menuItem -q -l $tempString[$i]`;
	}
else
	$controlSets[0]=$nameSpace+"ControlSet";

return $controlSets;
}

global proc asDeleteStaticChannels (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Clean animation ?\n"
	+"This will delete static channels,\n"
	+"which means remove all animation where the value is not changing")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
select $controlSets;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
print ("// Static channels cleaned\n");
select $sel;
}
	
global proc string asPoserGetCmd (string $uiName, int $anim)
{
global string $gChannelBoxName;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $selectedMainAttrs[]=`channelBox -q -sma $gChannelBoxName`;
string $selectedShapeAttrs[]=`channelBox -q -ssa $gChannelBoxName`;
string $selectedHistoryAttrs[]=`channelBox -q -sha $gChannelBoxName`;
string $selectedOutputAttrs[]=`channelBox -q -soa $gChannelBoxName`;
string $selectedAttrs[];
$selectedAttrs=`stringArrayCatenate $selectedMainAttrs $selectedShapeAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedHistoryAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedOutputAttrs`;
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
int $onlySel;
if ($uiName=="asPoserDefault")
	{
	if (`checkBox -q -ex asPoserOnlySel`)
		$onlySel=`checkBox -q -v asPoserOnlySel`;
	}
else if ($altButton || $ctrlButton)
	$onlySel=1;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $cmd;
string $controls[],$buffer[];
int $weightedTangents[];
int $onlyOneObj,$onlyOneAttr;
string $connectObj;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
if (!$onlySel && !size($controlSets))
	error "No ControlSets";

//determine the name for poserAnimFile
string $animationFile,$animationFilePath;
string $gridOrder[];
int $childNum;
if (`gmatch $uiName "asPoser*"`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`gmatch $gridOrder[$i-1] "asPoser*"`)
			$childNum=$i;
	$childNum++;

	$animationFile="untitled_"+$childNum;
	$animationFilePath=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
	}
else
	{
	$animationFile="ClipBoard";
	$animationFilePath=`internalVar -utd`+"AdvancedSkeleton/Selector/";
	}

string $animCurves[];

if ($onlySel)
	{
	for ($i=$y=0;$i<size($sel);$i++)
		{
		if (`gmatch $sel[$i] ($nameSpace+"*")`)
			{
			tokenize $sel[$i] ":" $buffer;
			$controls[$y]=$buffer[size($buffer)-1];
			$y++;
			}
		}
	}
else
	{
	if (!`objExists $controlSets[0]`)
		error ("Object :\""+$controlSets[0]+"\" does not exists !\n");
	$controls=`sets -q $controlSets`;
	for ($i=0;$i<size($controls);$i++)
		$controls[$i]=`substitute  $nameSpace $controls[$i] ""`;
	}
string $attrs[];
if (size($controls)<1)
	error "No Controls Available!";
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Storing Data" -bp -ii 1 -min 0 -max (size($controls)) $gMainProgressBar;
select -cl;

if ($anim)
	{
	createNode -n poserAnimationInfo transform;
	addAttr -ln "cmd" -dt "string" poserAnimationInfo;
	select poserAnimationInfo;
	}

	{
for ($obj in $controls)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	$allKeyableAttrs=`listAttr -k -m -sn ($nameSpace+$obj)`;
	if ($onlySel && (size($selectedAttrs)>0))
		$attrs=$selectedAttrs;
	else
		$attrs=$allKeyableAttrs;
	for ($attr in $attrs)
		for ($allKeyableAttr in $allKeyableAttrs)
			if ($attr==$allKeyableAttr)
				{
				if (!$anim)
					$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+";";
				else
					{
					//Animation
					$animCurves=`listConnections -type animCurve -s 1 -d 0 ($nameSpace+$obj+"."+$attr)`;
					for ($y=0;$y<size($animCurves);$y++)
						{
						select -add $animCurves[$y];
						$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+" "+$animCurves[$y]+";";
						}
					}
				}
		}
	}

if ($anim)
	{
	setAttr -type "string" poserAnimationInfo.cmd $cmd;
	file -f -op "v=0" -typ "mayaAscii" -es ($animationFilePath+$animationFile+".ma");
	delete poserAnimationInfo;
	}

if ($cmd!="")
	{
	if (!$anim)
		$cmd="asSetAttrs "+$uiName+" \""+$cmd+"\"";
	else
		$cmd="asLoadAttrs "+$uiName;
	}

select $sel;
return $cmd;
}

global proc asSetAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[];
string $objAttr;
float $value;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";

for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asLoadAttrs (string $uiName, int $childNum)
{
string $sel[]=`ls -sl`;
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -e -st 0;
createNode -n tempXform transform;
int $shiftButton,$ctrlButton,$altButton;
if (`getModifiers` %  2)
	$shiftButton=1;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
float $timeOffset=0;
if ($shiftButton)
	$timeOffset=`currentTime -q`;
string $buffer[],$buffer2[],$buffer3[],$tempString[];
string $obj,$attr,$objAttr,$animCurve,$newAnimCurve;
float $value;

string $animationFile,$projectName;

if ($childNum==0)
	{
	$projectName="Selector";
	$animationFile=`internalVar -utd`+"AdvancedSkeleton/Selector/ClipBoard.ma";
	}
else
	{
	string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
	string $tempString[];
	tokenize $icon "/" $tempString;
	$projectName=$tempString[size($tempString)-2];
	$animationFile=`substitute "[.][a-z][a-z][a-z]" $icon ".ma"`;
	}
file -r -type "mayaAscii" -namespace $projectName -options "v=0;p=17" $animationFile;

string $cmds=`getAttr ($projectName+":poserAnimationInfo.cmd")`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	tokenize $objAttr "." $buffer3;
	$obj=$buffer3[0];
	$attr=$buffer3[1];
	$value=$buffer2[1];
	$animCurve=$buffer2[2];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		{
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
		if (!`attributeExists $attr tempXform`)
			addAttr -k 1 -ln $attr -at double tempXform;
		connectAttr -f ($projectName+":"+$animCurve+".output") ("tempXform."+$attr);
		copyKey -time ":" -hierarchy none -at $attr tempXform;
		pasteKey -option merge -copies 1 -connect 0 -timeOffset $timeOffset -floatOffset 0 -valueOffset 0 {$objAttr};
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;

if (`objExists tempXform`)
	delete tempXform;
file -rr  $animationFile;
select $sel;
if ($autoKey)
	autoKeyframe -e -st 1;
}

global proc asKeyAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[],$spaceBuffer[];
string $objAttr,$previousObjAttr,$restOfBuffers;
float $time,$value,$currentValue;
float $currentTime=`currentTime -q`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning,$firstValueSet;
string $warningMsg="The following attributes can not be keyed:";
float $firstValue;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	$restOfBuffers="";
	if ($objAttr!=$previousObjAttr)
		$firstValueSet=0;
	$previousObjAttr=$objAttr;
	for ($y=1;$y<size($buffer2);$y++)
		$restOfBuffers+=$buffer2[$y]+" ";
	if (`objExists $objAttr`)
		{
		tokenize $restOfBuffers $spaceBuffer;
		for ($y=0;$y<size($spaceBuffer);$y++)
			{
			//TimeOffset
			if ($spaceBuffer[$y]=="-t" && ($ctrlButton||$altButton))
				{
				$time=$spaceBuffer[$y+1];
				$spaceBuffer[$y+1]=$time+$currentTime;
				}
			//ValueOffset
			if ($spaceBuffer[$y]=="-v" && $ctrlButton)
				{
				$value=$spaceBuffer[$y+1];
				$currentValue=`getAttr $objAttr`;
				if (!$firstValueSet)
				$firstValue=$value;
				$firstValueSet=1;
				$spaceBuffer[$y+1]=$value+$currentValue-$firstValue;
				}
			}
		$restOfBuffers="";
		for ($y=0;$y<size($spaceBuffer);$y++)
			$restOfBuffers+=$spaceBuffer[$y]+" ";
		eval ($restOfBuffers+$objAttr);
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asPoseView (string $uiName, int $childNum)
{
string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $tempString[];
tokenize $icon "/" $tempString;
string $projectName=$tempString[size($tempString)-2];

string $mediaFile;
if ($anim)
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".avi"`;
else
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".jpg"`;
print ("// "+$mediaFile+"\n");
system ("load "+$mediaFile);
}

global proc asPoseObjects (string $uiName, string $button,string $action)
{
string $cmd=`iconTextButton -q -c $button`;
string $buffer[],$buffer2[];
string $objAttr,$value;
tokenize $cmd "\"" $buffer;
$cmd=$buffer[1];
int $numTok=`tokenize $cmd ";" $buffer`;
int $showWarning;
string $warningMsg="The following objects can not be found:";
if ($action==" select -add")
select -cl;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	tokenize $objAttr "." $buffer2;
	$obj=$buffer2[0];
	if ($action!=" select -add")
		$obj=$objAttr;
	$obj=`asPoserResolveNameSpace $uiName $obj`;
	if (`objExists $obj`)
		eval ($action+" "+$obj);
	else
		{
		$showWarning=1;
		$warningMsg+=$obj+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asMirrorOptions (string $uiName)
{
if (`window -q -ex asMirrorOptions`)
	deleteUI asMirrorOptions;
window -t "Mirror Options" asMirrorOptions;
columnLayout -adj 1;
	separator -h 25 -st "none";
	rowLayout -nc 4 -cw 1 40;
		text -l "side:";
		radioCollection asMOSideRadioCollection;
		radioButton -label "Swap" asMOSideFlip;
		radioButton -label "Right To Left" asMOSideR2L;
		radioButton -label "Left To Right" asMOSideL2R;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "axis:";
		radioCollection asMOAxisRadioCollection;
		radioButton -label "X" asMOAxisX;
		radioButton -label "Y" asMOAxisY;
		radioButton -label "Z" asMOAxisZ;
		radioCollection -e -sl "asMOAxisX" asMOAxisRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "space:";
		radioCollection asMOSpaceRadioCollection;
		radioButton -label "World" asMOSpaceWorld;
		radioButton -label "Main" asMOSpaceMain;
		radioButton -label "RootX_M" asMOSpaceCenter;
		radioCollection -e -sl "asMOSpaceWorld" asMOSpaceRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "control:";
		radioCollection asMOSelOnlyRadioCollection;
		radioButton -label "All" asMOSelOnlyAll;
		radioButton -label "Selected" asMOSelOnlySel;
		radioCollection -e -sl "asMOSelOnlyAll" asMOSelOnlyRadioCollection;
		setParent..;

separator -st "none" -h 25;
button -w 100 -l "Mirror" -c ("asMirror "+$uiName);
showWindow;

string $optionVars[]={"asMOSide","asMOSpace","asMOAxis","asMOSelOnly"};
string $cia[];
string $radioCollection,$selected,$optionVarString;
for ($i=0;$i<size($optionVars);$i++)
	{
	$radioCollection=$optionVars[$i]+"RadioCollection";
	$cia=`radioCollection -q -cia $radioCollection`;
	$selected=$cia[0];
	if (`optionVar -ex $optionVars[$i]`)
		{
		$optionVarString=`optionVar -q $optionVars[$i]`;
		for ($y=0;$y<size($cia);$y++)
			if (`gmatch $cia[$y] ("*"+$optionVarString)`)
				$selected=`optionVar -q $optionVars[$i]`;
		}
	radioCollection -e -sl $selected $radioCollection;
	}
}

global proc asMirror (string $uiName)
{
if (!`window -q -ex $uiName`)
	error ("Window : "+$uiName+" not found !");
string $side="asMOSideR2L";
string $space="asMOSpaceMain";
string $axis="asMOAxisX";
string $selOnly="asMOSelOnlyAll";
if (`window -q -ex asMirrorOptions`)
	{
	$side=`radioCollection -q -sl asMOSideRadioCollection`;
	$space=`radioCollection -q -sl asMOSpaceRadioCollection`;
	$axis=`radioCollection -q -sl asMOAxisRadioCollection`;
	$selOnly=`radioCollection -q -sl asMOSelOnlyRadioCollection`;
	optionVar -sv asMOSide $side;
	optionVar -sv asMOSpace $space;
	optionVar -sv asMOAxis $axis;
	optionVar -sv asMOSelOnly $selOnly;
	}
if (`optionVar -ex asMOSide`)
	$side=`optionVar -q asMOSide`;
if (`optionVar -ex asMOSpace`)
	$space=`optionVar -q asMOSpace`;
if (`optionVar -ex asMOAxis`)
	$axis=`optionVar -q asMOAxis`;
if (`optionVar -ex asMOSelOnly`)
	$selOnly=`optionVar -q asMOSelOnly`;
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;
string $sortedControls[];
if (`stringArrayCount "Main" $controlSets`)
	$sortedControls={"Main","RootX_M","CenterExtra_M"};

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Spine*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Leg_*")` || `gmatch $controls[$i] ($nameSpace+"IK*Arm_*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (!`stringArrayCount $controls[$i] $sortedControls`)
		$sortedControls[size($sortedControls)]=$controls[$i];
$controls=$sortedControls;
if ($selOnly=="asMOSelOnlySel")
	$controls=$sel;
string $allKeyableAttrs[],$tempString[];
string $source,$dest,$cmd,$loc1,$loc2;
float $pos[3],$rot[3];
int $wsXform[];
int $flip;
int $isFaceControl;
string $flipAxis,$t0;
if ($axis=="asMOAxisX")
	{$flipAxis="X";$t0="tx";}
if ($axis=="asMOAxisY")
	{$flipAxis="Y";$t0="ty";}
if ($axis=="asMOAxisZ")
	{$flipAxis="Z";$t0="tz";}

createNode -n flipGroup transform;
if ($space=="asMOSpaceCenter")
	parent flipGroup ($nameSpace+"RootX_M");
if ($space=="asMOSpaceMain")
	parent flipGroup ($nameSpace+"Main");
xform -os -t 0 0 0 -ro 0 0 0 flipGroup;
if ($space=="asMOSpaceCenter" || $space=="asMOSpaceMain")
	parent -w flipGroup;
for ($i=0;$i<size($controls);$i++)
	{
	if ($side!="asMOSideFlip")
		if (`gmatch $controls[$i] "*_M"` || `gmatch $controls[$i] "*Main"`)
			continue;
	if ($side=="asMOSideR2L")
		{
		if (`gmatch $controls[$i] "*_L"`)
			continue;
		$dest=`substitute "_R" $controls[$i] "_L"`;
		}
	else if ($side=="asMOSideL2R")
		{
		if (`gmatch $controls[$i] "*_R"`)
			continue;
		$dest=`substitute "_L" $controls[$i] "_R"`;
		}
	else if ($side=="asMOSideFlip")
		{
		if (!`gmatch $controls[$i] "*_L"` && !`gmatch $controls[$i] "*_R"` && !`gmatch $controls[$i] "*_M"`)
			continue;
		if (`gmatch $controls[$i] "*FKExtraSpine1_M"`)
			continue;
		if (`gmatch $controls[$i] "*_L"`)
			$dest=`substitute "_L" $controls[$i] "_R"`;
		if (`gmatch $controls[$i] "*_R"`)
			$dest=`substitute "_R" $controls[$i] "_L"`;
		if (`gmatch $controls[$i] "*_M"`)
			$dest=$controls[$i];
		}
	if (!`objExists $dest`)
		continue;
	$isFaceControl=0;
	if (`objExists ($nameSpace+"FaceControlSet")`)
		if (`sets -im ($nameSpace+"FaceControlSet") $controls[$i]`)
			$isFaceControl=1;
	$source=$controls[$i];
	$allKeyableAttrs=`listAttr -k -m -sn $controls[$i]`;
	for ($y=0;$y<size($allKeyableAttrs);$y++)
		{
		$flip=1;
		if (`gmatch $controls[$i] ($nameSpace+"FK*_L")` || `gmatch $controls[$i] ($nameSpace+"FK*_R")`
		 || `gmatch $controls[$i] ($nameSpace+"Bend*_L")` || `gmatch $controls[$i] ($nameSpace+"Bend*_R")`)
		 	{
		 	if ($allKeyableAttrs[$y]=="tx" || $allKeyableAttrs[$y]=="ty" || $allKeyableAttrs[$y]=="tz")
		 		$flip=-1;
		 	}
		else
			if ($allKeyableAttrs[$y]=="tz" || $allKeyableAttrs[$y]=="rx" || $allKeyableAttrs[$y]=="ry")
				$flip=-1;
		if ($isFaceControl && !`gmatch $controls[$i] ($nameSpace+"ctrl*")`)
			{
			if ($allKeyableAttrs[$y]=="tx" || $allKeyableAttrs[$y]=="ry" || $allKeyableAttrs[$y]=="rz")
				$flip=-1;
			else
				$flip=1;
			}
		if (`gmatch $controls[$i] ($nameSpace+"Aim*")` || `gmatch $controls[$i] ($nameSpace+"IK*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")` || `gmatch $controls[$i] ($nameSpace+"RootX_M*")`)
			$wsXform[$i]=1;
		if (!$wsXform[$i])
			if (`getAttr -se ($dest+"."+$allKeyableAttrs[$y])`)
				$cmd+="setAttr "+$dest+"."+$allKeyableAttrs[$y]+" "+(`getAttr ($source+"."+$allKeyableAttrs[$y])`*$flip)+";";
		}

	if ($wsXform[$i])
		{
		$tempString=`spaceLocator`;
		$loc1=$tempString[0];
		$tempString=`spaceLocator`;
		$loc2=$tempString[0];
		parent $loc2 $loc1;
		parent $loc1 $source;
		xform -os -t 0 0 0 -ro 0 0 0 $loc1;
		setAttr ($loc1+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ($loc2+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ("flipGroup.scale"+$flipAxis) 1;
		parent $loc1 flipGroup;
		setAttr ("flipGroup.scale"+$flipAxis) -1;
		setAttr ($loc1+".scaleX") -1;
		$pos=`xform -q -ws -t $loc2`;
		$rot=`xform -q -ws -ro $loc2`;
		$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" -ro "+$rot[0]+" "+$rot[1]+" "+$rot[2]+" "+$dest+";";
		}

	if (`attributeExists "mirror" $controls[$i]`)
		setAttr ($controls[$i]+".mirror") 0;
	}
delete flipGroup;
if ($cmd!="")
	eval ($cmd);
select $sel;
}

global proc asGoToBuildPose (string $uiName)
{
int $ctrlButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
string $nameSpace;
string $controlSets[];
if ($uiName=="bodySetup")
	{
	$nameSpace="";
	$controlSets[0]="ControlSet";
	}
else if ($uiName=="faceSetup")
	{
	$nameSpace="";
	$controlSets[0]="FaceControlSet";
	}
else
	{
	$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
	$controlSets=`asGetControlSetsFromUI $uiName`;
	}
if ($nameSpace==":")
	$nameSpace="";

string $buildPose="buildPose";
if (`gmatch $controlSets[0] "*FaceControlSet"`)
    $buildPose="faceBuildPose";

string $tempString[],$tempString2[],$buffer[];
string $setAttrCmd,$cmd;


$setAttrCmd=`getAttr ($nameSpace+$buildPose+".udAttr")`;
tokenize $setAttrCmd ";" $tempString;
for ($y=0;$y<size($tempString);$y++)
	{
	$cmd=$tempString[$y];
	if ($cmd=="")
		continue;
	if ($nameSpace!="")
		{
		tokenize $cmd $buffer;
		if (`gmatch $cmd "xform*"`)
			$substituteWordNr=size($buffer)-1;
		else
			$substituteWordNr=1;
		$cmd="";
		for ($z=0;$z<size($buffer);$z++)
			{
			if ($z==$substituteWordNr)
				$cmd+=$nameSpace;
			$cmd+=$buffer[$z]+" ";
			}
		}
	if ($ctrlButton)
		if (`gmatch $cmd "*Main.*"`)
			continue;
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
	}

//run
string $run,$fitTopNode,$objAttr;
for ($i=0;$i<size($controlSets);$i++)
	{
	if (`gmatch $controlSets[$i] "*ControlSet"`)
		if (`objExists ($nameSpace+"FitSkeleton")`)
			$fitTopNode=$nameSpace+"FitSkeleton";
	if (`gmatch $controlSets[$i] "*FaceControlSet"`)
		$fitTopNode=($nameSpace+"FaceFitSkeleton");
	}

if (`objExists $fitTopNode`)
	if (`attributeExists "run" $fitTopNode`)
		{
		$run=`getAttr ($fitTopNode+".run")`;
		if ($nameSpace=="")
			catch (`eval ($run)`);
		else
			{
			tokenize $run ";" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				tokenize $tempString[$i] $tempString2;
				$objAttr=`substitute "\"" $tempString2[1] ""`;
				$objAttr=`substitute "\"" $objAttr ""`;
				$cmd=$tempString2[0]+" "+$nameSpace+$objAttr+" "+$tempString2[2]+";";
				catch (`eval ($cmd)`);
				}
			}
		}
}

global proc asPoserupdateGridBlock (string $uiName, int $childNum)
{
string $existingPopUpMenus[]=`control -q -pma ($uiName+"IconTextButton"+$childNum)`;
for ($pop in $existingPopUpMenus)
	deleteUI $pop;

int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $button=$uiName+"IconTextButton"+$childNum;
string $viewCmd="asPoseView "+$uiName+" "+$childNum;
string $selectCmd="asPoseObjects "+$uiName+" "+$button+"\" select -add\"";
string $keyCmd="asPoseObjects "+$uiName+" "+$button+" setKeyframe";
string $linearKeyCmd="asPoseObjects "+$uiName+" "+$button+" \"setKeyframe -itt linear -ott linear\"";

popupMenu -p ($uiName+"IconTextButton"+$childNum);
	menuItem -l "View" -c $viewCmd;
	if (!$anim)
		{
		menuItem -d 1;
		menuItem -l "Select" -c $selectCmd;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		}
	if ($uiName=="asPoserDefault")
		{
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asPoserRename "+$childNum);
		menuItem -l "Remove Button" -c ("asPoserDeletePose "+$uiName+" "+$childNum);
		menuItem -l "Update icon" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 1 0");
		if ($anim)
			menuItem -l "Update movie" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 0 1");
		}
}

global proc string asPoserResolveNameSpace (string $uiName, string $obj)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
return ($nameSpace+$obj);
}

global proc asDynRemove (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
for ($i=0;$i<size($sel);$i++)
	{
	string $dynObj="dynamics"+`substitute ($nameSpace+"FK") $sel[$i] ""`;
	if(`objExists $dynObj`)
		{
		delete $dynObj;
		print ("// Dynamics for "+$sel[$i]+" removed\n");
		}
	else
		print ("// No dynamics for "+$sel[$i]+" found\n");
	}
}

global proc asDynAdd (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
global string $gSelect;
setToolTo $gSelect;

string $deformJoints[];
for ($i=0;$i<size($sel);$i++)
	{
	$deformJoints[$i]=`substitute ($nameSpace+"FK") $sel[$i] ($nameSpace+"")`;
	if (`objExists ("dynamics"+$deformJoints[$i])`)
		error ("dynamics for "+$deformJoints[$i]+" already exists");
	}
$dynSortedDeformJoints=`asResolveDynJoints $nameSpace $deformJoints`;
asDynAddChain $nameSpace $dynSortedDeformJoints;
}

global proc asDynAddChain (string $nameSpace, string $dynSortedDeformJoints[])
{
string $dynJoints[],$tempString[];
string $name;
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	select $dynSortedDeformJoints[$i];
	$dynJoints[$i]="dyn"+`substitute $nameSpace $dynSortedDeformJoints[size($dynSortedDeformJoints)-1] ""`+$i;
	joint -n $dynJoints[$i];
	}
string $startJoint=$dynJoints[0];
string $endJoint=$dynJoints[size($dynJoints)-1];

string $dynTopNode="dynamics"+`substitute $nameSpace $dynSortedDeformJoints[size($dynSortedDeformJoints)-1] ""`;
if (!`objExists "Dynamics"`)
	createNode -n Dynamics transform;
createNode -n ($dynJoints[0]+"Offset") transform;
int $foundParentFK;
string $parentFK,$fk;
string $joint=$dynSortedDeformJoints[0];
while($parentFK=="")
	{
	$tempString=`listRelatives -type joint -p $joint`;
	if ($tempString[0]=="")
		$parentFK=$nameSpace+"RootX_M";
	else
		{
		$joint=$tempString[0];
		if ($nameSpace=="")
			$fk="FK"+$joint;
		else
			$fk=`substitute $nameSpace $joint ($nameSpace+"FK")`;
		if (`objExists $fk`)
			$parentFK=$fk;
		}
		
	}
parentConstraint $parentFK ($dynJoints[0]+"Offset");
createNode -n $dynTopNode transform;
parent ($dynJoints[0]+"Offset") $dynTopNode;
parent $dynTopNode Dynamics;
setAttr ($dynTopNode+".overrideEnabled") 1;
setAttr ($dynTopNode+".overrideDisplayType") 2;

for ($i=1;$i<size($dynJoints);$i++)
	parent $dynJoints[$i] $dynJoints[$i-1];
$tempString=`ikHandle -n ("DynIKHandle"+$endJoint) -ns 2 -sol ikSplineSolver -sj $startJoint -ee $endJoint`;
rename $tempString[1] ("DynIKEffector"+$endJoint);
string $ikCurve=`rename $tempString[2] ("DynIKCurve"+$endJoint)`;
parent ("DynIKHandle"+$endJoint) $dynTopNode;

parent $dynJoints[0] ($dynJoints[0]+"Offset");

//remove existing
string $dynNodes[]={("DynParticle"+$endJoint),("DynIKCurveSoft"+$endJoint),("DynParticleArrayMapper"+$endJoint),("DynParticleRamp"+$endJoint)};
for ($node in $dynNodes)
	if (`objExists $node`)
		delete $node;

//$numCv
int $numCv;
$form=`getAttr ($ikCurve+".form")`;
$spans=`getAttr ($ikCurve+".spans")`;
$degrees=`getAttr ($ikCurve+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;

//soft
$tempString=`soft -d -g 1 -c ("DynIKCurve"+$endJoint)`;
rename $tempString[0] ("DynParticle"+$endJoint);
$tempString=`listRelatives -p ("DynParticle"+$endJoint)`;
rename $tempString[0] ("DynIKCurveSoft"+$endJoint);
rename ("copyOfDynIKCurve"+$endJoint)  ("copyOfDynIKCurveDeform"+$endJoint);
parent ("DynIKCurveSoft"+$endJoint) ("copyOfDynIKCurveDeform"+$endJoint) $dynTopNode;

//mass
for ($i=0;$i<$numCv;$i++)
	{
	float $massPP=($i+0.00)/$numCv;
	if ($massPP==0)
		$massPP=0.01;
	particle -e -or $i -at mass -fv $massPP ("DynParticle"+$endJoint);
	}

//arrayMapper
$tempString=`arrayMapper -target ("DynParticle"+$endJoint) -destAttr goalPP -inputV mass -type ramp`;
rename $tempString[0] ("DynParticleArrayMapper"+$endJoint);

$tempString=`listConnections -s 1 -d 0 ("DynParticleArrayMapper"+$endJoint+".computeNodeColor")`;
rename $tempString[0] ("DynParticleRamp"+$endJoint);
removeMultiInstance -break true ("DynParticleRamp"+$endJoint+".colorEntryList[1]");
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[0].position") 0;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[2].position") 1;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[0].color") -type double3 1 1 1 ;
setAttr ("DynParticleRamp"+$endJoint+".colorEntryList[2].color") -type double3 0 0 0;

string $fkEnd;
int $arrayNr=size($dynSortedDeformJoints)-1;
if ($nameSpace=="")
	$fkEnd="FK"+$dynSortedDeformJoints[$arrayNr];
else
	$fkEnd=`substitute $nameSpace $dynSortedDeformJoints[$arrayNr] ($nameSpace+"FK")`;
if (!`attributeExists blend $fkEnd`)
	addAttr -k 1 -ln blend -at double -min 0 -max 1 -dv 1 $fkEnd;
if (!`attributeExists baseGoal $fkEnd`)
	addAttr -k 1 -ln baseGoal -at double -min 0 -max 1 -dv 1 $fkEnd;
if (!`attributeExists tipGoal $fkEnd`)
	addAttr -k 1 -ln tipGoal -at double -min 0 -max 1 -dv 0.6 $fkEnd;
if (!`attributeExists conserve $fkEnd`)
	addAttr -k 1 -ln conserve -at double -min 0 -max 1 -dv 0.75 $fkEnd;
connectAttr ($fkEnd+".baseGoal") ("DynParticleArrayMapper"+$endJoint+".maxValue");
connectAttr ($fkEnd+".tipGoal") ("DynParticleArrayMapper"+$endJoint+".minValue");
connectAttr ($fkEnd+".conserve") ("DynParticle"+$endJoint+".conserve");

//skinCurve
select -cl;
string $fkx;
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	if ($nameSpace=="")
		$fkx="FKX"+$dynSortedDeformJoints[$i];
	else
		$fkx=`substitute $nameSpace $dynSortedDeformJoints[$i] ($nameSpace+"FKX")`;
	if (`objExists $fkx`)
		select -add $fkx;
	}
select -add ("copyOfDynIKCurveDeform"+$endJoint);
newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false";

//pairBlend
for ($i=0;$i<size($dynSortedDeformJoints);$i++)
	{
	if ($i>0)
		{
		$tempString[0]=`pairBlend -nd $dynSortedDeformJoints[$i] -at tx -at ty -at tz`;
		rename $tempString[0] ("parBlendT"+$dynJoints[$i]);
		connectAttr -f ($dynJoints[$i]+".translate") ("parBlendT"+$dynJoints[$i]+".inTranslate2");
		}
	$tempString[0]=`pairBlend -nd $dynSortedDeformJoints[$i] -at rx -at ry -at rz`;
	rename $tempString[0] ("parBlendR"+$dynJoints[$i]);
	connectAttr -f ($dynJoints[$i]+".rotate") ("parBlendR"+$dynJoints[$i]+".inRotate2");
	connectAttr ($fkEnd+".blend") ("parBlendR"+$dynJoints[$i]+".weight");
	}

setAttr -l 1 ($startJoint+"Offset.v") 0;
setAttr -l 1 ("DynIKHandle"+$endJoint+".v") 0;
setAttr -l 1 ("copyOfDynIKCurveDeform"+$endJoint+".v") 0;

select $fkEnd;
}

global proc string[] asResolveDynJoints (string $nameSpace, string $joints[])
{
string $dynJoints[];
string $jointLongNames[],$tempStringA[],$tempStringB[];
for ($i=0;$i<size($joints);$i++)
	{
	$tempStringA=`ls -l $joints[$i]`;
	$jointLongNames[$i]=$tempStringA[0];
	}
string $sorted[]=`sort $jointLongNames`;
for ($i=1;$i<size($sorted);$i++)
	{
	$tempStringA=`ls $sorted[$i]`;
	$tempStringB=`ls $sorted[$i-1]`;
	if (!`gmatch $sorted[$i] ($sorted[$i-1]+"*")`)
	error ("\""+$tempStringA[0]+"\" is not a child of \""+$tempStringB[0]+"\", select controls in same hiarchy");
	}

string $dynEndJointLongName=$sorted[size($sorted)-1];
$tempStringA=`ls -sn $dynEndJointLongName`;
$dynJoints[0]=$tempStringA[0];
string $joint=$dynJoints[0];
int $reachedStartJoint,$reachedParentOfStartJoint;
while (!$reachedStartJoint)
	{
	$tempStringA=`listRelatives -p -f -type joint $joint`;
	if (!size($tempStringA))
		break;
	$jointLongName=$tempStringA[0];
	$tempStringA=`ls -sn $tempStringA[0]`;
	$joint=$tempStringA[0];
	if (size($joints)==1)
		{
		//single control selected
		if (!`stringArrayCount $jointLongName $sorted`)
			if (!`gmatch $joint "*Part[0-9]*"`)
				$reachedStartJoint=1;
		}
	else
		{
		//several controls selected
		if ($jointLongName==$sorted[0])
			$reachedStartJoint=1;
		}
	$dynJoints[size($dynJoints)]=$joint;
	}
string $dynJointReverse[];
for ($i=size($dynJoints)-1;$i>-1;$i--)
	$dynJointReverse[size($dynJointReverse)]=$dynJoints[$i];
return $dynJointReverse;
}

global proc asAnimBake (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Bake character ?\n"
	+"This creates a single joint chain for game engine export\n"
	+"The rig controllers will no longer work")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $name=`substitute ":" $nameSpace ""`;
string $bakeNameSpace=$name+"Bake:";
namespace -add ($name+"Bake");
namespace -set ($name+"Bake");
$tempString=`listRelatives -c ($nameSpace+"DeformationSystem")`;
$tempString=`duplicate $tempString[0]`;
string $topBakeJoint=$tempString[0];
parent -w $topBakeJoint;
$tempString=`listRelatives -ad $topBakeJoint`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`!="joint")
		delete $tempString[$i];
string $allBakeJoints[]=`listRelatives -ad -type joint $topBakeJoint`;
$allBakeJoints[size($allBakeJoints)]=$topBakeJoint;
sets -rm ($nameSpace+"DeformSet") $allBakeJoints;
//Disable Skincluster
string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 1;
//Constraint bakeSkeleton
string $deformJoints[]=`listRelatives -ad -type joint ($nameSpace+"DeformationSystem")`;
for ($i=0;$i<size($deformJoints);$i++)
    {
		if ($nameSpace=="")
			$bakeDeformJoint=$bakeNameSpace+$deformJoints[$i];
		else
			$bakeDeformJoint=`substitute $nameSpace $deformJoints[$i] $bakeNameSpace`;
    parentConstraint $deformJoints[$i] $bakeDeformJoint;
//    scaleConstraint $deformJoints[$i] $bakeDeformJoint;//caues issues with overall scale
    }
//Bake
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $allBakeJoints;
//Transfer deformation to bake skeleton
for ($i=0;$i<size($deformJoints);$i++)
{
    $tempString=`listConnections -s 0 -d 1 -p 1 -c 1 $deformJoints[$i]`;
    for ($y=0;$y<size($tempString);$y=$y+2)
        {        
        if ($nameSpace=="")
        	$newSource=$bakeNameSpace+$tempString[$y];
				else
	        $newSource=`substitute $nameSpace $tempString[$y] $bakeNameSpace`;
        catch (`connectAttr -f $newSource $tempString[$y+1]`);
        }
}
//Enable Skincluster
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 0;

namespace -set ":";
select $allBakeJoints;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
select $topBakeJoint;
print ("// Selected joint chain is ready for export, add geometry to selection and export\n");
}

global proc asDynBake (string $uiName)
{
if (`confirmDialog -title "Confirm" -message "Bake all dynamics ?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
asDynUnBake $uiName;
string $softDynCurves[]=`ls -type nurbsCurve "DynIKCurveSoftdyn*"`;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl 0 -preserveOutsideKeys 0 -sparseAnimCurveBake false -controlPoints true -shape false $softDynCurves;
}

global proc asDynUnBake (string $uiName)
{
string $softDynCurves[]=`ls -type nurbsCurve "DynIKCurveSoftdyn*"`;
string $particles;
int $spans,$degrees,$numCv;
for ($i=0;$i<size($softDynCurves);$i++)
	{
	$particles=`substitute "DynIKCurveSoft" $softDynCurves[$i] "DynParticle"`;
	$particles=`substitute "Shape" $particles ""`;
	if (!`isConnected ($particles+".targetGeometry") ($softDynCurves[$i]+".create")`)
		connectAttr ($particles+".targetGeometry") ($softDynCurves[$i]+".create");
	if (size(`listConnections -type animCurve $softDynCurves[$i]`))
		delete `listConnections -type animCurve $softDynCurves[$i]`;
	$spans=`getAttr ($softDynCurves[$i]+".spans")`;
	$degrees=`getAttr ($softDynCurves[$i]+".degree")`;
	$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv;$y++)
		setAttr ($softDynCurves[$i]+".cv["+$y+"]") 0 0 0;
	}
}

global proc asJointsVisibilityToggle ()
{
int $vis;
int $firstModelEditor=0;
string $editors[]=`lsUI -editors`;
for ($i=0;$i<size($editors);$i++)
    if (`modelEditor -q -ex $editors[$i]`)
        {
        if (!$firstModelEditor)
            $vis=!(`modelEditor -q -joints $editors[$i]`);
        $firstModelEditor=1;
        modelEditor -e -joints $vis $editors[$i];
        }
}

global proc asControlsVisibilityToggle ()
{
int $vis;
string $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;
for ($i=0;$i<size($motionSystems);$i++)
    {
    if ($i==0)
        $vis=!(`getAttr ($motionSystems[$i]+".v")`);
    setAttr ($motionSystems[$i]+".v") $vis;
    }
}

global proc asSetupControlVisibilityHotKeyDialog ()
{
if (`confirmDialog -title "Confirm"
	-message ("Add toggle of control-visibility to the \"~\" hotkey.\n"
	+"For easy toggling visibility of controls.\n"
	+"Holding down the \"~\" key (next to the \"number 1\" on the keyboard) to see and select controls.\n"
	+"As you let go, controls will again be hidden.\n"
	+"The idea is to work without the `visual clutter` of the controls.\n"
	+"Tip: Ctrl+\"\~\" will leave the controls visible")
	-button "Confirm" -button "Cancel" -defaultButton "Confirm"
	-cancelButton "Cancel" -dismissString "Cancel"`!="Confirm")
	return;
asSetupControlVisibilityHotKey;
}

global proc asSetupControlVisibilityHotKey ()
{
if (`runTimeCommand -q -ex advancedSkeletonVisibilitySwitch`)
	return;
nameCommand -ann "advancedSkeletonVisibilitySwitch" -c "advancedSkeletonVisibilitySwitch" advancedSkeletonVisibilitySwitchNameCommand;
runTimeCommand -annotation "switches the visibility of controls" -category "User"
	-command ("int $vis;\nstring $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;\nfor ($i=0;$i<size($motionSystems);$i++)\n    {\n    if ($i==0)\n        $vis=!(`getAttr ($motionSystems[$i]+\".v\")`);\n    setAttr ($motionSystems[$i]+\".v\") $vis;\n    }")
	advancedSkeletonVisibilitySwitch;
hotkey -keyShortcut "`" -name "advancedSkeletonVisibilitySwitchNameCommand" -releaseName "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "`" -ctrlModifier -name "advancedSkeletonVisibilitySwitchNameCommand";
}

global proc asVisualizeGimbalLock (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
int $fromSelection;
int $buildGimbal[];
float $scale;
float $bb[];
string $name,$lookForVisConnectionOnObject;
string $tempString[];
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;

if (`objExists GimbalLockVisualizers`)
	{
	delete GimbalLockVisualizers;
	return;
	}
createNode -n GimbalLockVisualizers transform;
if ($sel[0]!="")
	if (`stringArrayCount $sel[0] $controls`)
		$fromSelection=1;
for ($i=0;$i<size($controls);$i++)
	{
	if ($controls[$i]==$nameSpace+"Main")
		continue;
	$tempString=`listRelatives -s $controls[$i]`;
	if ($tempString[0]!="")
		if (`objectType $tempString[0]`=="nurbsCurve")
			{
			if ($fromSelection)
				if (`stringArrayCount $controls[$i] $sel`)
					$buildGimbal[$i]=1;
			if (!$fromSelection)
				$buildGimbal[$i]=1;
			}
	}
for ($i=0;$i<size($controls);$i++)
	{
	if (!$buildGimbal[$i])
		continue;
	$name=$controls[$i];
	createNode -n ($name+"Constraint") -p GimbalLockVisualizers transform;
	createNode -n ($name+"Offset") -p ($name+"Constraint") transform;

	polyCylinder -n ($name+"Cones") -r 0.3 -h 2.5 -sx 10 -sy 2 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	scale -r -p 0 0 0 0 0 0 ($name+"Cones.vtx[10:19]");
	parent ($name+"Cones") ($name+"Offset");
	if (`objExists asGreenSG`)
		sets -e -forceElement asGreenSG ($name+"Cones");

	polyTorus -n ($name+"Torus") -r 1 -sr 0.03 -tw 0 -sx 30 -sy 6 -ax 0 1 0 -cuv 1 -ch 0;
	parent ($name+"Torus") ($name+"Offset");
	if (`objExists asRedSG`)
		sets -e -forceElement asRedSG ($name+"Torus");

	polyCylinder -n ($name+"Arrow") -r 0.06 -h 2 -sx 10 -sy 3 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	rotate -r 0 0 90 ($name+"Arrow.vtx[0:41]");
	move -r 1 0 0 ($name+"Arrow.vtx[0:41]");
	scale -r -p 0 0 0 1 0 0 ($name+"Arrow.vtx[0:9]") ($name+"Arrow.vtx[40]");
	move -r 0.35 0 0 ($name+"Arrow.vtx[10:19]");
	scale -r -p 0 0 0 1 1.75 1.75 ($name+"Arrow.vtx[10:19]");
	move -r 1 0 0 ($name+"Arrow.vtx[20:29]");
	parent ($name+"Arrow") ($name+"Offset");
	if (`objExists asGreen2SG`)
		sets -e -forceElement asGreen2SG ($name+"Arrow");
	orientConstraint $name ($name+"Arrow");

	$tempString=`listRelatives -p $name`;
	parentConstraint $tempString[0] ($name+"Constraint");
	$tempString=`listRelatives -s $name`;
	$bb=`xform -q -bb ($tempString[0]+".cv[0:999]")`;
	$scale=(($bb[3]-$bb[0])+($bb[4]-$bb[1])+($bb[5]-$bb[2]))/5.0;
	setAttr -type float3 ($name+"Offset.s") $scale $scale $scale;
	$lookForVisConnectionOnObject=$name;
	$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
	for ($y=0;$y<20;$y++)
		{
		if ($tempString[0]!="")
			{
			connectAttr $tempString[0] ($name+"Offset.v");
			break;
			}
		$tempString=`listRelatives -p $lookForVisConnectionOnObject`;
		if ($tempString[0]=="")
			break;
		$lookForVisConnectionOnObject=$tempString[0];
		$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
		}
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	}
select $sel;
}

global proc string asSelectorScriptLocation ()
{
string $whatIs=`whatIs asSelectorScriptLocation`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
if ($numTok<2)
	if (`about -win`)
		$numTok=`tokenize $fullPath "\\" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;
return $scriptLocation;
}
//-- ASTools Procedures Ends Here --//

//-- ASSelector Procedures Starts Here --//
global proc asSelectorDesigner ()
{
asShowSelJob;
string $controlSets[]=`asGetControlSets`;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");

if (`window -q -ex asSelectorDefault`)
	deleteUI asSelectorDefault;
window -w 640 -h 480 -mb 1 -t "SelectorDesigner :untitled" asSelectorDefault;

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`internalVar -utd`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	intField -v 640 asSelectorWidth;
	intField -v 480 asSelectorHeight;
	setParent..;

menu "File";
	menuItem -c "asSave Selector" "Save";
	menuItem -c "asfileBrowse Selector SaveAs" "Save As";
	menuItem -c "astoShelf Selector" "Put on shelf";

menu "Edit";
	menuItem -sm 1 "Colors";
		menuItem -c "asSelectorBackgroundSetColor asSelectorSelColor" "set Selected Color";
		menuItem -c "asSelectorBackgroundSetColor asSelectorKeyColor" "set Keyed Color";

menu "Layout";
	menuItem -c "asSDNewLayout 0" -l "New Empty Layout";
	menuItem -c "asSDNewLayout 1" -l "New Biped Layout";
	menuItem -c "asSDNewLayout 2" -l "New Face Layout";

menu "Buttons";
	menuItem -c "asSDNewButtton Object 50 50 100 100" -l "Create New Button";

menu "Render";
	menuItem -c "asSDRender 1" -l "Render Background";
	menuItem -c "asfileBrowse Selector Import" -l "Import  Background";
	menuItem -d 1;
	menuItem -c "asSDRender 0" -l "Render Buttons";

columnLayout -adj 1;
rowLayout -nc 4 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 80 -cw 4 60;
optionMenu -cc asSelChange asSelectorDefaultOptionMenu;
button -l "set" -c "asSetNameSpaceFromSelection asSelectorDefault";
checkBox -v `optionVar -q asShowSelection` -onc "asSelChangeToggle;optionVar -iv asShowSelection 1;" -ofc "asSelChangeToggle;optionVar -iv asShowSelection 0;" -l Selection asSelectorSelectionCheckBox;
checkBox -v `optionVar -q asShowKeyed` -onc "asSelChangeToggle;optionVar -iv asShowKeyed 1;" -ofc "asSelChangeToggle;optionVar -iv asShowKeyed 0;" -l Keyed asSelectorKeyedCheckBox;
setParent..;

formLayout asSelectorDefaultFormLayout;
setParent..;
asPopulateNameSpaceMenu "asSelectorDefault";

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`internalVar -utd`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	text -l "640" asSelectorBackgroundWidth;
	text -l "480" asSelectorBackgroundHeight;

showWindow;
}

global proc asSDNewLayout (int $LayoutType)
{
if (`objExists SelectorLayout`)
	if (`confirmDialog -t "Confirm"
	-m "SelectorLayout already exists, this will replace the current Layout"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;

float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $tempString[];

select -cl;
string $deleteObjs[]={"SelectorLayout","Template","SelectorLayoutShader","SelectorLayoutSG","SelectorIcons"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

createNode -n SelectorLayout transform;
polyCube -n Button_Template -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
addAttr -ln label -dt "string" Button_Template;
addAttr -ln multiObjs -dt "string" Button_Template;
polyProjection -ch 0 -type Planar -ibd on -md z Button_Template.f[0];
setAttr Button_Template.sz 0.001;
parent Button_Template SelectorLayout;
setAttr SelectorLayout.tz ($height/2);
setAttr -l 1 -k 0 Button_Template.tz;
setAttr -l 1 -k 0 Button_Template.rx;
setAttr -l 1 -k 0 Button_Template.ry;
setAttr -l 1 -k 0 Button_Template.rz;
setAttr -l 1 -k 0 Button_Template.sz;
//setAttr -l 1 -k 0 Button_Template.v;

shadingNode -n SelectorLayoutShader -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name SelectorLayoutSG;
connectAttr -f SelectorLayoutShader.outColor SelectorLayoutSG.surfaceShader;
setAttr SelectorLayoutShader.transparency -type double3 0.8 0.8 0.8; 
sets -e -forceElement SelectorLayoutSG Button_Template;

setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.overrideColor 15;
setAttr Button_TemplateShape.primaryVisibility 0;
//setAttr Button_TemplateShape.overrideShading 0;
setAttr Button_TemplateShape.castsShadows 0;
setAttr Button_TemplateShape.receiveShadows 0;
setAttr Button_TemplateShape.visibleInReflections 0;
setAttr Button_TemplateShape.visibleInRefractions 0;
setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.motionBlur 0;
setAttr Button_TemplateShape.smoothShading 0;
//setAttr Button_TemplateShape.doubleSided 0;

//SelectorWindow
duplicate -n SelectorWindow Button_Template;
setAttr SelectorWindowShape.overrideShading 0;
setAttr SelectorWindow.sx 640;
setAttr SelectorWindow.sy 480;
move -r 0 240 0 SelectorWindow.vtx[0:7];
setAttr -type float3 SelectorLayout.s ($height*0.002083) ($height*0.002083) ($height*0.002083);

//WindowCorner
createNode -n WindowCorner -p SelectorWindow transform;
setAttr -type float3 WindowCorner.t -0.5 1 0;
setAttr -type float3 WindowCorner.s (1.0/640) (-1.0/480) 1;

//Prep Button_Template
move -r (`getAttr SelectorLayout.sx`/2.0) (`getAttr SelectorLayout.sy`/2.0) 0 Button_Template.vtx[0:7];
parent Button_Template WindowCorner;
setAttr Button_Template.tx -150;
setAttr Button_Template.ty 50;
setAttr Button_Template.sx 100;
setAttr Button_Template.sy 100;
setAttr Button_Template.v 0;

select -cl;
if ($LayoutType==1)
	{
	asSDNewButtton FKElbow_R 136 78 72 27;
	asSDNewButtton FKShoulder_R 210 75 64 32;
	asSDNewButtton FKWrist_R 92 68 43 43;
	asSDNewButtton RootX_M 188 228 70 24;
		$tempString=`listConnections -p 1 Button_RootX_M.tx`;disconnectAttr $tempString[0] Button_RootX_M.tx;
		setAttr Button_RootX_M.tx 188;
		setAttr -type "string" Button_RootX_M.label Root;
	asSDNewButtton FKRoot_M 270 190 100 38;
	asSDNewButtton FKSpine1_M 270 149 100 38;
	asSDNewButtton FKChest_M 270 108 100 38;
	asSDNewButtton FKHip_R 267 234 48 106;
	asSDNewButtton FKKnee_R 275 346 39 104;
	asSDNewButtton FKAnkle_R 275 451 39 26;
	asSDNewButtton FKToes_R 243 461 30 14;
	asSDNewButtton FKScapula_R 277 67 25 41;
	asSDNewButtton FKNeck_M 304 79 30 26;
	asSDNewButtton FKHead_M 291 3 56 56;

	asSDNewButtton IKArm_R 92 10 43 43;
	asSDNewButtton PoleArm_R 160 22 30 30;
	asSDNewButtton FKIKArm_R 216 21 30 30;
	asSDNewButtton IKLeg_R 205 405 43 43;
	asSDNewButtton PoleLeg_R 210 333 30 30;
	asSDNewButtton FKIKLeg_R 210 261 30 30;
	asSDNewButtton RollHeel_R 215 452 24 24;
	asSDNewButtton RollToes_R 188 452 24 24;
	asSDNewButtton RollToesEnd_R 160 452 24 24;

	asSDNewButtton HipSwinger_M 205 161 43 43;
		$tempString=`listConnections -p 1 Button_HipSwinger_M.tx`;disconnectAttr $tempString[0] Button_HipSwinger_M.tx;
		setAttr Button_HipSwinger_M.tx 205;

	asSDNewButtton Main 20 10 43 20;
		setAttr -type "string" Button_Main.label Main;

	asSDNewButtton FKWrist_R 6 330 140 100;
	asSDNewButtton FKIndexFinger1_R 114 268 32 58;
	asSDNewButtton FKMiddleFinger1_R 78 268 32 58;
	asSDNewButtton FKRingFinger1_R 43 268 32 58;
	asSDNewButtton FKPinkyFinger1_R 6 268 32 58;
	asSDNewButtton FKIndexFinger2_R 114 211 32 52;
	asSDNewButtton FKMiddleFinger2_R 78 211 32 52;
	asSDNewButtton FKRingFinger2_R 43 211 32 52;
	asSDNewButtton FKPinkyFinger2_R 6 211 32 52;
	asSDNewButtton FKIndexFinger3_R 114 167 32 40;
	asSDNewButtton FKMiddleFinger3_R 78 167 32 40;
	asSDNewButtton FKRingFinger3_R 43 167 32 40;
	asSDNewButtton FKPinkyFinger3_R 6 167 32 40;
	asSDNewButtton FKThumbFinger1_R 149 330 32 66;
	asSDNewButtton FKThumbFinger2_R 149 272 32 52;
	asSDNewButtton FKThumbFinger3_R 149 225 32 41;
	asSDNewButtton Fingers_R 31 436 91 24;
		setAttr -type "string" Button_Fingers_R.label Fingers;

	asSDNewButtton FKSpine 188 129 70 24;
		setAttr -type "string" Button_FKSpine.label Spine;
		setAttr -type "string" Button_FKSpine.multiObjs "FKChest_M FKSpine1_M FKRoot_M";
	asSDNewButtton IKSpine1_M 390 204 30 30;
		$tempString=`listConnections -p 1 Button_IKSpine1_M.tx`;disconnectAttr $tempString[0] Button_IKSpine1_M.tx;
		setAttr Button_IKSpine1_M.tx 390;
	asSDNewButtton IKSpine2_M 390 164 30 30;
		$tempString=`listConnections -p 1 Button_IKSpine2_M.tx`;disconnectAttr $tempString[0] Button_IKSpine2_M.tx;
		setAttr Button_IKSpine2_M.tx 390;
	asSDNewButtton IKSpine3_M 390 127 30 30;
		$tempString=`listConnections -p 1 Button_IKSpine3_M.tx`;disconnectAttr $tempString[0] Button_IKSpine3_M.tx;
		setAttr Button_IKSpine3_M.tx 390;
	asSDNewButtton FKIKSpine_M 425 163 30 30;
		$tempString=`listConnections -p 1 Button_FKIKSpine_M.tx`;disconnectAttr $tempString[0] Button_FKIKSpine_M.tx;
		setAttr Button_FKIKSpine_M.tx 425;
	}
if ($LayoutType==2)
	{
	asSDNewButtton browOuter_R 143 20 33 33;
	asSDNewButtton browHalf_R 192 20 33 33;
	asSDNewButtton browInner_R 246 20 33 33;

	asSDNewButtton LidCorner2_R 150 103 33 33;
	asSDNewButtton upperLid1_R 208 67 33 33;
	asSDNewButtton LidCorner1_R 269 103 33 33;
	asSDNewButtton lowerLid1_R 208 139 33 33;
	asSDNewButtton upperLid3_R 178 74 25 25;
	asSDNewButtton upperLid2_R 243 75 25 25;
	asSDNewButtton lowerLid3_R 179 137 25 25;
	asSDNewButtton lowerLid2_R 244 137 25 25;

	asSDNewButtton noseCorner_R 253 251 33 33;
	asSDNewButtton cheek_R 187 311 33 33;

	asSDNewButtton Lip6_R 231 335 33 33;
	asSDNewButtton upperLip0_M 303 306 33 33;
	asSDNewButtton lowerLip0_M 303 358 33 33;
	asSDNewButtton upperLip3_R 271 320 25 25;
	asSDNewButtton lowerLip3_R 271 355 25 25;

	asSDNewButtton ctrlBrow_R 547 30 40 40;
	asSDNewButtton ctrlBrow_L 597 30 40 40;
	asSDNewButtton ctrlEye_R 547 104 40 40;
	asSDNewButtton ctrlEye_L 597 104 40 40;
	asSDNewButtton ctrlCheek_R 547 183 40 20;
	asSDNewButtton ctrlCheek_L 597 183 40 20;
	asSDNewButtton ctrlNose_R 547 245 40 20;
	asSDNewButtton ctrlNose_L 597 245 40 20;
	asSDNewButtton ctrlMouth_M 561 293 65 65;
		$tempString=`listConnections -p 1 Button_ctrlMouth_M.tx`;disconnectAttr $tempString[0] Button_ctrlMouth_M.tx;
		setAttr Button_ctrlMouth_M.tx 561;
	asSDNewButtton ctrlMouthCorner_R 547 377 40 40;
	asSDNewButtton ctrlMouthCorner_L 597 377 40 40;
/*
	asSDNewButtton ctrlTongue_M 561 431 65 15;
		$tempString=`listConnections -p 1 Button_ctrlTongue_M.tx`;disconnectAttr $tempString[0] Button_ctrlTongue_M.tx;
		setAttr Button_ctrlTongue_M.tx 561;
*/
	asSDNewButtton ctrlBox 520 299 13 159;

	asSDNewButtton lips 18 72 71 30;
		setAttr -type "string" Button_lips.label lips;
		setAttr -type "string" Button_lips.multiObjs "Lip6_R upperLip0_M Lip6_L lowerLip0_M";
	asSDNewButtton FKJaw_M 231 411 177 43;
	}

//SelectorIcons
asFitModeEnsureShaders;
createNode -n SelectorIcons transform;
setAttr SelectorIcons.tz ($height/2.2);
connectAttr SelectorLayout.s SelectorIcons.s;
createNode -n SelectorIconsWindow -p SelectorIcons transform;
connectAttr SelectorWindow.t SelectorIconsWindow.t;
connectAttr SelectorWindow.s SelectorIconsWindow.s;
createNode -n WindowIconsCorner -p SelectorIconsWindow transform;
connectAttr WindowCorner.t WindowIconsCorner.t;
connectAttr WindowCorner.s WindowIconsCorner.s;
createNode -n MirroredIcons -p WindowIconsCorner transform;
setAttr MirroredIcons.tx `getAttr SelectorWindow.sx`;
setAttr MirroredIcons.sx -1;

if ($LayoutType==1)
	{
	asSDNewIcon IKArm_R asRedSG sphere;
	asSDNewIcon PoleArm_R asRedSG cross;
	asSDNewIcon FKIKArm_R asBlueSG cross;
	asSDNewIcon IKLeg_R asRedSG sphere;
	asSDNewIcon PoleLeg_R asRedSG cross;
	asSDNewIcon FKIKLeg_R asBlueSG cross;
	asSDNewIcon RollHeel_R asRedSG torus;
	asSDNewIcon RollToes_R asRedSG torus;
	asSDNewIcon RollToesEnd_R asRedSG torus;
	asSDNewIcon HipSwinger_M asGreen2SG torus;
	asSDNewIcon IKSpine1_M asRedSG sphere;
	asSDNewIcon IKSpine2_M asRedSG sphere;
	asSDNewIcon IKSpine3_M asRedSG sphere;
	asSDNewIcon FKIKSpine_M asBlueSG cross;
	}
if ($LayoutType==2)
	{
	asSDNewIcon browOuter_R asBlueSG sphere;
	asSDNewIcon browHalf_R asGreen2SG sphere;
	asSDNewIcon browInner_R asBlueSG sphere;
	asSDNewIcon LidCorner2_R asGreenSG sphere;
	asSDNewIcon upperLid1_R asGreenSG sphere;
	asSDNewIcon LidCorner1_R asGreenSG sphere;
	asSDNewIcon lowerLid1_R asGreenSG sphere;
	asSDNewIcon upperLid3_R asGreen2SG sphere;
	asSDNewIcon upperLid2_R asGreen2SG sphere;
	asSDNewIcon lowerLid2_R asGreen2SG sphere;
	asSDNewIcon lowerLid3_R asGreen2SG sphere;
	asSDNewIcon noseCorner_R asBlue2SG sphere;
	asSDNewIcon cheek_R asBlue2SG sphere;
	asSDNewIcon Lip6_R asGreenSG sphere;
	asSDNewIcon upperLip0_M asGreenSG sphere;
	asSDNewIcon lowerLip0_M asGreenSG sphere;
	asSDNewIcon upperLip3_R asGreen2SG sphere;
	asSDNewIcon lowerLip3_R asGreen2SG sphere;
	
	}
select SelectorLayout;
}

global proc asSDNewIcon (string $name, string $shader, string $shape)
{
string $buttonIcon="ButtonIcon_"+$name;
int $numLetters=`size($buttonIcon)`;
string $buttonIconLeft=`substring $buttonIcon 1 ($numLetters-2)`+"_L";
if ($shape=="sphere")
	polySphere -n $buttonIcon -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0;
if ($shape=="cross")
	{
	polyCube -n $buttonIcon -w 1 -h 1 -d 1 -sx 3 -sy 3 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	scale -r -p 0 0 0 0.333 0.333 0.333 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3]") ($buttonIcon+".vtx[12]")
		($buttonIcon+".vtx[15:16]") ($buttonIcon+".vtx[19]") ($buttonIcon+".vtx[28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 2.5 2.5 2.5 ($buttonIcon+".vtx[0:99]");
	scale -r -p 0 0 0 1 0.5 1 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3:12]") ($buttonIcon+".vtx[15:16]")
		($buttonIcon+".vtx[19:28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 0.5 1 1 ($buttonIcon+".vtx[0:3]") ($buttonIcon+".vtx[5:6]") ($buttonIcon+".vtx[9:10]")
		($buttonIcon+".vtx[12:19]") ($buttonIcon+".vtx[21:22]") ($buttonIcon+".vtx[25:26]") ($buttonIcon+".vtx[28:31]");
	}
if ($shape=="torus")
	polyTorus -n $buttonIcon -r 1 -sr 0.1 -tw 0 -sx 20 -sy 20 -ax 0 0 1 -cuv 1 -ch 0;
parent $buttonIcon WindowIconsCorner;
sets -e -forceElement $shader $buttonIcon;
move -r 1 -1 0 ($buttonIcon+".vtx[0:999]");
scale -r -p 0 0 0 0.5 0.5 0.5 ($buttonIcon+".vtx[0:999]");
scale -r -p 0.5 -0.5 0 0.75 0.75 0.75 ($buttonIcon+".vtx[0:999]");
connectAttr ("Button_"+$name+".t") ($buttonIcon+".t");
connectAttr ("Button_"+$name+".sx") ($buttonIcon+".sx");
connectAttr ("Button_"+$name+".sy") ($buttonIcon+".sy");
setAttr ($buttonIcon+".sz") 1000;
if (`gmatch $buttonIcon "*_R"`)
	{
	instance -n $buttonIconLeft $buttonIcon;
	parent $buttonIconLeft MirroredIcons;
	connectAttr ($buttonIcon+".t") ($buttonIconLeft+".t");
	connectAttr ($buttonIcon+".sy") ($buttonIconLeft+".sy");
	connectAttr ($buttonIcon+".sz") ($buttonIconLeft+".sz");
	createNode -n ($buttonIcon+"Reverse") reverse;
	connectAttr ($buttonIcon+".sx") ($buttonIcon+"Reverse.inputX");
	connectAttr ($buttonIcon+"Reverse.outputX") ($buttonIconLeft+".sx");
	}
	
}

global proc asSDNewButtton (string $name,int $x, int $y, int $width, int $height)
{
if (!`objExists Button_Template`)
	error "\"Button_Template\" Not found";
string $multiObjString;
string $sel[]=`ls -sl`;
string $buttonName="Button_"+$name;
if ($sel[0]!="" && !`gmatch $sel[0] "Button*"` && $sel[0]!="SelectorWindow" && $sel[0]!="SelectorLayout")
	{
	string $nameSpace=`optionMenu -q -v asSelectorDefaultOptionMenu`;
	if ($nameSpace==":")
		$buttonName="Button_"+$sel[0];
	else
		$buttonName="Button_"+`substitute $nameSpace $sel[0] ""`;
	createNode -n SelectorSampler -p WindowCorner transform;
	pointConstraint $sel[0] SelectorSampler;
	dgdirty -a;
	$x=`getAttr SelectorSampler.tx`-($width/2);
	$y=`getAttr SelectorSampler.ty`-($height/2);
	delete SelectorSampler;
	if (size($sel)>1)
		for ($i=0;$i<size($sel);$i++)
			$multiObjString+=$sel[$i]+" ";
	}
//unique buttonName
if (`objExists $buttonName`)
	for ($i=1;$i<10;$i++)
		{
		$buttonName=`substitute "Button" $buttonName ""`;
		if (`gmatch $buttonName "[1-9]*"`)
			$buttonName=`substring $buttonName 2 99`;
		$buttonName="Button"+$i+$buttonName;
		if (!`objExists $buttonName`)
			break;
		}

string $tempString[]=`duplicate -n $buttonName Button_Template`;
$buttonName=$tempString[0];
setAttr ($buttonName+".v") 1;
setAttr ($buttonName+".tx") $x;
setAttr ($buttonName+".ty") $y;
setAttr ($buttonName+".sx") $width;
setAttr ($buttonName+".sy") $height;
if ($multiObjString!="")
	setAttr -type "string" ($buttonName+".multiObjs") $multiObjString;

//Middle Constraint
if (`gmatch $buttonName "*_M"`)
	{
	if (`objExists ($buttonName+"MultiplyDivide")`) delete ($buttonName+"MultiplyDivide");
	if (`objExists ($buttonName+"PlusMinusAverage")`) delete ($buttonName+"PlusMinusAverage");
	createNode -n ($buttonName+"MultiplyDivide") multiplyDivide;
	createNode -n ($buttonName+"PlusMinusAverage") plusMinusAverage;
	setAttr ($buttonName+"PlusMinusAverage.operation") 2;
	connectAttr ($buttonName+".scale.scaleX") ($buttonName+"MultiplyDivide.input1Y");
	setAttr -type float3 ($buttonName+"MultiplyDivide.input2") 2 2 2;
	setAttr ($buttonName+"MultiplyDivide.operation") 2;
	connectAttr ($buttonName+"MultiplyDivide.outputY") ($buttonName+"PlusMinusAverage.input1D[1]");
//	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") (`getAttr SelectorWindow.scale.scaleX`/2.0);
	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") 320;
	connectAttr ($buttonName+"PlusMinusAverage.output1D") ($buttonName+".tx");
	}

select $buttonName;
}

global proc int asSelectorBackgroundImport (string $fileName, string $fileType)
{
eval ("renderWindowEditor -e -loadImage \""+$fileName+"\" renderView");
asSDRender 2;
return 1;
}

global proc asSDRender (int $background)
{
global string $gMove;
setToolTo $gMove;
if (!`objExists SelectorWindow`)
	{
	if (`confirmDialog -t "Confirm"
	-m "No Layout found. Create New one ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
	asSDNewLayout 0;
	}
if (`objExists SelectorCamera`)
	delete SelectorCamera;
int $renderViewIconized=1;
if (`window -q -ex renderViewWindow`)
	$renderViewIconized=`window -q -i renderViewWindow`;
else if ($background)
	RenderViewWindow;
int $x,$y,$width,$height,$numLetters;
int $windowWidth=`getAttr SelectorWindow.sx`;
int $windowHeight=`getAttr SelectorWindow.sy`;
float $widthFloat,$heightFloat;
float $windowCornerWidth=`getAttr WindowCorner.sx`;
float $windowCornerHeight=`getAttr WindowCorner.sy`;
$windowCornerHeight=`abs($windowCornerHeight)`;
int $doMirrorBox[];
float $pos[];
string $sel[]=`ls -sl`;
string $projectName=`text -q -l asSelectorProjectName`;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/untitled/";
//string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Selector/"+$projectName+"/";
//string $iconDir=`text -q -l asSelectorProjectPath`+$projectName+"/";
string $bgImageFile=$iconDir+"untitled_background.png";
string $bgImageFile32=$iconDir+"untitled_background32.png";
string $cmd,$keyCmd,$linearKeyCmd,$labelAttr,$iol,$multiObjAttr,$ann,$fileName;
string $alignFK2IKCmd,$alignIK2FKCmd,$switchFK2IKCmd,$switchIK2FKCmd;
string $annBuffer[],$tempString[];
string $renderBoxes[]=`listRelatives -c WindowCorner`;
string $renderBoxObjs[]=$renderBoxes;
for ($i=0;$i<size($renderBoxes);$i++)
	{
	if (`gmatch $renderBoxes[$i] "Button_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 8 999`;
	if (`gmatch $renderBoxes[$i] "Button?_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 9 999`;
//	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<$windowWidth/2)
	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<320)
		{
		$numLetters=`size($renderBoxes[$i])`;
		$mirrorBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_L";
		if (!`objExists $mirrorBox`)
			{
			$doMirrorBox[$i]=1;
			$doMirrorBox[size($renderBoxes)]=1;
			$renderBoxes[size($renderBoxes)]=$mirrorBox;
			}
		}
	}

string $deleteObjs[]={"SelectorScaleSampler","SelectorCamera","SelectorFileNode","SelectorFilePlace",
	"SelectorRampU","SelectorRampV","SelectorLayeredTexture"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

float $color[3]=`displayRGBColor -q "background"`;
if (!`optionVar -ex asSelectorBGColor`)
	{
	optionVar -fv asSelectorBGColor $color[0];
	optionVar -fva asSelectorBGColor $color[1];
	optionVar -fva asSelectorBGColor $color[2];
	}
if (!`optionVar -ex asSelectorDefaultColor`)
	{
	optionVar -fv asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	}
if (!`optionVar -ex asSelectorSelColor`)
	{
	optionVar -fv asSelectorSelColor 0.2;
	optionVar -fva asSelectorSelColor 0.8;
	optionVar -fva asSelectorSelColor 0.2;
	}
if (!`optionVar -ex asSelectorKeyColor`)
	{
	optionVar -fv asSelectorKeyColor 1;
	optionVar -fva asSelectorKeyColor 0.4;
	optionVar -fva asSelectorKeyColor 0.4;
	}
float $bgColor[3]=`optionVar -q asSelectorBGColor`;
float $selColor[3]=`optionVar -q asSelectorSelColor`;
float $keyColor[3]=`optionVar -q asSelectorKeyColor`;

$tempString=`formLayout -q -ca asSelectorDefaultFormLayout`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!$background && $tempString[$i]=="asSelectorDefaultBGPicture")
		continue;
	deleteUI $tempString[$i];
	}

if ($background)
	{
	if (`text -q -l asSelectorBackgroundWidth`) text -e -l $windowWidth asSelectorBackgroundWidth;
	if (`text -q -l asSelectorBackgroundHeight`) text -e -l $windowHeight asSelectorBackgroundHeight;

	createNode -n SelectorScaleSampler transform;
	$tempString=`camera -centerOfInterest 5 -focalLength 35 -lensSqueezeRatio 1 -cameraScale 1 -horizontalFilmAperture 1.4173 -horizontalFilmOffset 0 -verticalFilmAperture 0.9449 -verticalFilmOffset 0 -filmFit Fill -overscan 1 -motionBlur 0 -shutterAngle 144 -nearClipPlane 0.1 -farClipPlane 10000 -orthographic 1 -orthographicWidth 30 -panZoomEnabled 0 -horizontalPan 0 -verticalPan 0 -zoom 1`;
	rename $tempString[0] SelectorCamera;
	float $restoreRenderWidth=`getAttr defaultResolution.width`;
	float $restoreRenderHeight=`getAttr defaultResolution.height`;
	float $restoreRenderAspectLock=`getAttr defaultResolution.aspectLock`;
	int $restoreFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
	setAttr defaultRenderGlobals.imageFormat 32;
	
	setAttr "defaultResolution.aspectLock" 0;
	setAttr defaultResolution.width $windowWidth;
	setAttr defaultResolution.height $windowHeight;
	setAttr "defaultResolution.aspectLock" 1;
	setAttr defaultResolution.deviceAspectRatio ($windowWidth/($windowHeight+0.00));
	
	select SelectorWindow.vtx[0:99];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] SelectorCamera;
	move -r 0 0 1.1 SelectorCamera;
	delete `scaleConstraint SelectorWindow SelectorScaleSampler`;
	setAttr SelectorCameraShape.orthographicWidth `getAttr SelectorScaleSampler.sx`;
	if ($background==1)
		renderWindowRenderCamera render renderView SelectorCamera;
	eval ("renderWindowEditor -e -wi \""+$bgImageFile+"\" renderView");
	setParent asSelectorDefaultFormLayout;

	image -en 0 -w $windowWidth -h $windowHeight -i $bgImageFile asSelectorDefaultBGPicture;
	reloadImage $bgImageFile asSelectorDefaultBGPicture;
	formLayout -e -af asSelectorDefaultBGPicture "left" 0 -af asSelectorDefaultBGPicture "top" 0 asSelectorDefaultFormLayout;
	//32
	string $fileNode=`createNode file`;
	setAttr -type "string" ($fileNode+".fileTextureName") $bgImageFile;
	select $fileNode;
	eval ("convertSolidTx -sp 1 -al 1 -rx 32 -ry 32 -n asTempSolidTx32 -fil \"png\" -fin \""+$bgImageFile32+"\"");
	delete $fileNode asTempSolidTx32;
	evalDeferred -lp ("window -e -w "+$windowWidth+" -h "+$windowHeight+" asSelectorDefault");
	
	setAttr defaultResolution.width $restoreRenderWidth;
	setAttr defaultResolution.height $restoreRenderHeight;
	setAttr defaultResolution.aspectLock $restoreRenderAspectLock;
	setAttr defaultRenderGlobals.imageFormat $restoreFormat;
	delete SelectorCamera SelectorScaleSampler;
	if ($renderViewIconized)
		window -e -i 1 renderViewWindow;
	}

for ($i=0;$i<size($renderBoxes);$i++)
	{
	$guiBox=$renderBoxes[$i];
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		{
		$numLetters=`size($renderBoxes[$i])`;
		$guiBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_R";
		}
	$x=`getAttr ($guiBox+".tx")`*$windowWidth*$windowCornerWidth;
	$y=`getAttr ($guiBox+".ty")`*$windowHeight*$windowCornerHeight;
	
	$widthFloat=`getAttr ($guiBox+".sx")`*$windowWidth*$windowCornerWidth;
	$width=`asRoundOff $widthFloat 0`;
	$heightFloat=`getAttr ($guiBox+".sy")`*$windowHeight*$windowCornerHeight;
	$height=`asRoundOff $heightFloat 0`;
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		$x=$windowWidth-$x-$width;
	if ($x<0 || $x>$windowWidth || $y<0 || $y>$windowHeight)
		continue;
	if ($background)
		continue;
	if ($bgImageFile=="" || !`file -q -ex $bgImageFile`)
		error "No background image, Render a background first";
	$iol="";
	$labelAttr=`getAttr ($guiBox+".label")`;
	if ($labelAttr!="")
		$iol=$labelAttr;
	$ann=$renderBoxObjs[$i];
	$fileName=$ann;
	$multiObjAttr=`getAttr ($guiBox+".multiObjs")`;
	if ($multiObjAttr!="")
		{
		$ann=$multiObjAttr;
		if (`gmatch $renderBoxes[$i] "*_L"`)
			{
			tokenize $ann $tempString;
			$ann="";
			for ($z=0;$z<size($tempString);$z++)
				$ann+=`substitute "_R" $tempString[$z] "_L"`+" ";
			}
		$fileName="combo"+$x+$y;
		}

	createNode -n SelectorFileNode file;
	setAttr -type "string" SelectorFileNode.fileTextureName $bgImageFile;
	float $pictureWidth=`getAttr SelectorFileNode.outSizeX`;
	float $pictureHeight=`getAttr SelectorFileNode.outSizeY`;
	createNode -n SelectorFilePlace place2dTexture;
	connectAttr SelectorFilePlace.outUV SelectorFileNode.uvCoord; connectAttr -f SelectorFilePlace.outUvFilterSize SelectorFileNode.uvFilterSize; 
	connectAttr -f SelectorFilePlace.coverage SelectorFileNode.coverage; connectAttr -f SelectorFilePlace.translateFrame SelectorFileNode.translateFrame; 
	connectAttr -f SelectorFilePlace.rotateFrame SelectorFileNode.rotateFrame; connectAttr -f SelectorFilePlace.mirrorU SelectorFileNode.mirrorU; 
	connectAttr -f SelectorFilePlace.mirrorV SelectorFileNode.mirrorV; connectAttr -f SelectorFilePlace.stagger SelectorFileNode.stagger; 
	connectAttr -f SelectorFilePlace.wrapU SelectorFileNode.wrapU; connectAttr -f SelectorFilePlace.wrapV SelectorFileNode.wrapV; 
	connectAttr -f SelectorFilePlace.repeatUV SelectorFileNode.repeatUV; connectAttr -f SelectorFilePlace.vertexUvOne SelectorFileNode.vertexUvOne; 
	connectAttr -f SelectorFilePlace.vertexUvTwo SelectorFileNode.vertexUvTwo; connectAttr -f SelectorFilePlace.vertexUvThree SelectorFileNode.vertexUvThree; 
	connectAttr -f SelectorFilePlace.vertexCameraOne SelectorFileNode.vertexCameraOne; connectAttr -f SelectorFilePlace.noiseUV SelectorFileNode.noiseUV; 
	connectAttr -f SelectorFilePlace.offset SelectorFileNode.offset; connectAttr -f SelectorFilePlace.rotateUV SelectorFileNode.rotateUV;
	setAttr SelectorFilePlace.offsetU (($x+1)/$pictureWidth);
	setAttr SelectorFilePlace.offsetV (($pictureHeight-($y-1+$height))/$pictureHeight);
	setAttr SelectorFilePlace.repeatV (($height-2)/$pictureHeight);
	setAttr SelectorFilePlace.repeatU (($width-2)/$pictureWidth);

	createNode -n SelectorRampU ramp;
	createNode -n SelectorRampV ramp;
	setAttr SelectorRampU.type 1;
	setAttr SelectorRampU.interpolation 0;
	setAttr SelectorRampU.colorEntryList[1].color -type double3 0.75 0.75 0.75;
//	if ($width>2)
		setAttr SelectorRampU.colorEntryList[1].position (1-(1.00000/$width));
	setAttr SelectorRampU.colorEntryList[0].color -type double3 0 0 0;
	setAttr SelectorRampV.type 0;
	setAttr SelectorRampV.interpolation 0;
	setAttr SelectorRampV.colorEntryList[0].color -type double3 0.75 0.75 0.75;
//	if ($height>2)
		setAttr SelectorRampV.colorEntryList[1].position (1.00000/$height);
	connectAttr SelectorRampU.outColor SelectorRampV.colorEntryList[1].color;
	setAttr SelectorRampU.colorEntryList[0].position (1.00000/$width);
	setAttr SelectorRampU.colorEntryList[2].color -type double3 0.75 0.75 0.75;
	setAttr SelectorRampV.colorEntryList[0].position (1-(1.00000/$height));
	setAttr SelectorRampV.colorEntryList[2].color -type double3 0.75 0.75 0.75;


	createNode -n SelectorLayeredTexture layeredTexture;
	setAttr SelectorLayeredTexture.inputs[0].color -type double3 1 1 1 ;
	connectAttr SelectorRampV.outColorR SelectorLayeredTexture.inputs[0].alpha;
	connectAttr -f SelectorFileNode.outAlpha SelectorLayeredTexture.inputs[1].alpha;
	connectAttr -f SelectorFileNode.outColor SelectorLayeredTexture.inputs[1].color;

	string $buttonImageFileOffK0=$iconDir+$projectName+"_"+$fileName+"_OffK0.png";
	string $buttonImageFileOffK1=$iconDir+$projectName+"_"+$fileName+"_OffK1.png";
	string $buttonImageFileOnK0=$iconDir+$projectName+"_"+$fileName+"_OnK0.png";
	string $buttonImageFileOnK1=$iconDir+$projectName+"_"+$fileName+"_OnK1.png";
	
	//Off K0 version
	select SelectorLayeredTexture;
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK0+"\"");
	delete asTempSolidTx;

	//add tint now, so that selection/keyed buttons (with blank space background) are also visible
	setAttr SelectorLayeredTexture.inputs[2].alpha 0.3;
	
	//Off K1 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK1+"\"");
	delete asTempSolidTx;
	
	//On K0 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $selColor[0] $selColor[1] $selColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK0+"\"");
	delete asTempSolidTx;
	
	//On K1 version
	setAttr SelectorFileNode.colorOffset -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 ($selColor[0]+$keyColor[0]) ($selColor[1]+$keyColor[1]) ($selColor[2]+$keyColor[2]);
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK1+"\"");
	delete asTempSolidTx;
	for ($q=0;$q<size($deleteObjs);$q++)
		if (`objExists $deleteObjs[$q]`)
			delete $deleteObjs[$q];


	if (`control -q -ex $renderBoxes[$i]`)
		deleteUI $renderBoxes[$i];
	setParent asSelectorDefaultFormLayout;

	//Update cmd, popUp
	$alignFK2IKCmd=$alignIK2FKCmd=$switchFK2IKCmd=$switchIK2FKCmd="";
	if (`gmatch $renderBoxObjs[$i] "FKIK*"` && !`gmatch $renderBoxObjs[$i] "FKIKSp*ine*"`)
		{
		$alignFK2IKCmd="asAlignFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$alignIK2FKCmd="asAlignIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchFK2IKCmd="asSwitchFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchIK2FKCmd="asSwitchIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		}
	$cmd="asSelect \"Default\" {\""+$ann+"\"};";
	if (`gmatch $ann "* *"`)
		{
		tokenize $ann $annBuffer;
		$cmd="asSelect \"Default\" {";
		for ($q=0;$q<size($annBuffer);$q++)
			{
			$cmd+="\""+$annBuffer[$q]+"\"";
			if ($q<size($annBuffer)-1)
				$cmd+=",";
			}
		$cmd+="};";
		}
	$keyCmd="asKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";
	$linearKeyCmd="asLinearKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";

	$buttonName=$renderBoxObjs[$i]+":"+$x+":"+$y;
	iconTextButton -w $width -h $height -i $buttonImageFileOffK0 -iol $iol -c $cmd -ann $ann $buttonName;
	reloadImage $buttonImageFileOffK0 $buttonName;
	formLayout -e -af $buttonName "left" $x -af $buttonName "top" $y asSelectorDefaultFormLayout;

	popupMenu -p $buttonName;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asLabelButton \""+$buttonName+"\"");
		menuItem -l "Remove Button" -c ("asDeleteButton \""+$buttonName+"\"");
		if ($alignFK2IKCmd!="")
			{
			menuItem -d 1;
			menuItem -sm 1 -l "Align";
				menuItem -l "FK2IK" -c $alignFK2IKCmd;
				menuItem -l "IK2FK" -c $alignIK2FKCmd;
				setParent -menu ..;
			menuItem -sm 1 -l "Switch";
				menuItem -l "FK2IK" -c $switchFK2IKCmd;
				menuItem -l "IK2FK" -c $switchIK2FKCmd;
			}
	}


select $sel;
}

global proc asLabelButton (string $button)
{
string $result=`promptDialog -t "Label" -b "Ok"  -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($result!="Ok")
	return;
iconTextButton -e -iol (`promptDialog -q -tx`) $button;
if (`promptDialog -q -tx`=="All")
	iconTextButton -e -ann "ControlSet" $button;
//asSelectorRefresh;
}
//-- ASSelectorDesigner Procedures Ends Here --//

//-- ASPoserDesigner Procedures Starts Here --//
global proc asPoserDesigner ()
{
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
int $nc=`optionVar -q asPoserNc`;
if ($nc<1)
	$nc=4;
int $nr=`optionVar -q asPoserNr`;
if ($nr<1)
	$nr=2;
string $poserText=`optionVar -q asPoserText`;
if ($poserText=="0")
	$poserText="Pose";
int $onlySel=`optionVar -q asPoserOnlySel`;
int $anim=`optionVar -q asPoserAnim`;
int $renderView=`optionVar -q asPoserRenderView`;
string $controlSets[]=`asGetControlSets`;

if (`window -q -ex asPoserDefault`)
	deleteUI asPoserDefault;
window -mb 1 -t "PoserDesigner :untitled" asPoserDefault;
menu "File";
	menuItem -c asPoserDesigner "New";
	menuItem -c "asfileBrowse Poser Open" "Open";
	menuItem -sm 1 -l "ControlSets" asPoserControlSetsMenu;
		menuItem -cb 1 -l ControlSet asPoserControlSetsMenuItemControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if ($controlSets[$i]!="ControlSet")
				menuItem -cb 0 -l $controlSets[$i] ("asPoserControlSetsMenuItem"+$controlSets[$i]);
		setParent -menu ..;
	menuItem -d 1;
	menuItem -c "asSave Poser" "Save";
	menuItem -c "asfileBrowse Poser SaveAs" "Save As";
	menuItem -c "astoShelf Poser" "Put on shelf";
	setParent -menu ..;
	menuItem -d 1;
	menuItem -c "deleteUI asPoserDefault" "Close";
	setParent -menu ..;
formLayout asPoserDefaultFormLayout;
	text -vis 0 -l (`internalVar -utd`+"AdvancedSkeleton/Poser/") asPoserProjectPath;
	text -vis 0 -l ("untitled") asPoserProjectName;
	rowLayout -adj 1 -nc 8 -cw 2 90 -cw 3 80 -cw 4 90 -cw 5 50 -cw 6 20 -cw 7 25 asPoserDefaultRowLayout;
		optionMenu asPoserDefaultOptionMenu;
		button -l "    New Pose    " -c "asNewPose {} 0";
		textField -w 70 -tx $poserText -cc asPoserUpdateGrid asPoserTextField;
		checkBox -v $onlySel -l "only selected" -cc asPoserUpdateGrid asPoserOnlySel;
		checkBox -v $anim -l "anim" -cc asPoserUpdateGrid asPoserAnim;
		intField -w 20 -v $nc -cc asPoserUpdateGrid asPoserNc;
		intField -w 20 -v $nr -cc asPoserUpdateGrid asPoserNr;
		checkBox -v $renderView -l "renderView" -cc asPoserUpdateGrid asPoserRenderView;
		setParent..;
//	scrollLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
//	cannot use scrollLayout cause it returns incorrect drop coordinates when scrolled.
	columnLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
		gridLayout -h (90*$nr) -nc $nc -nr $nr -cw 110 -ch 90 asPoserDefaultGridLayout;

formLayout -e
	-af asPoserDefaultRowLayout "top" 0
	-ac asPoserDefaultScrollayout "top" 0 asPoserDefaultRowLayout
	-af asPoserDefaultScrollayout "bottom" 0
	-af asPoserDefaultScrollayout "left" 0
	-af asPoserDefaultScrollayout "right" 0
	asPoserDefaultFormLayout;

asPopulateNameSpaceMenu "asPoserDefault";

//Remove Old Icons
string $oldFilesList[]=`getFileList -fld $iconDir`;
for ($file in $oldFilesList)
	sysFile -del ($iconDir+$file);

showWindow asPoserDefault;
}

global proc asNewPose (string $loadData[], int $anim)
{
global int $asfileLoading;
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $setParent=`setParent -q`;
string $uiName,$image,$label,$cmd,$mayaFile,$loadingMayaFile;
int $nc,$nr,$numTok,$singleAttr;
float $range[2]={0,1};
string $buffer[];
if ($loadData[0]=="" || $asfileLoading)
	{
	$nc=`intField -q -v asPoserNc`;
	$nr=`intField -q -v asPoserNr`;
	$uiName="asPoserDefault";
	}
else
	$uiName=$loadData[0];
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
string $gridOrder[]=`gridLayout -q -go ($uiName+"GridLayout")`;
int $lastFilled,$childNum;
//Find Last filled
for ($i=1;$i<size($gridOrder)+1;$i++)
	if (`gmatch $gridOrder[$i-1] "asPoser*"`)
		$lastFilled=$i;
$childNum=$lastFilled+1;

//Total full
if ($childNum>($nc*$nr) && $loadData[0]=="")
	error "Grid is full, extend rows or columns !\n";

if ($loadData[0]=="")
	{
	if (`optionMenu -q -v asPoserDefaultOptionMenu`=="None")
		error "No Character In The Scene\n";
	$anim=`checkBox -q -v asPoserAnim`;
	$cmd=`asPoserGetCmd $uiName $anim`;
	if ($cmd=="")
		error "No valid objects !\n";
	$image=`asPoserSnapShoot $uiName $childNum $anim 1 1`;
	if ($anim && $cmd!="")
		$cmd+=" "+$childNum;
	if (`about -mac`)
		showWindow asPoserDefault;
	$label=`textField -q -tx asPoserTextField`;
	}
else
	{
	$childNum=$loadData[4];
	$numTok=`tokenize $loadData[1] "/" $buffer`;
	$image=$iconDir+"untitled_"+$childNum+"."+$ext;
	sysFile -cp $image $loadData[1];
	$mayaFile=`substitute "[.][a-z][a-z][a-z]" $image ".ma"`;
	$loadingMayaFile=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".ma"`;
	if (`file -q -ex $loadingMayaFile`)
		sysFile -cp $mayaFile $loadingMayaFile;
	$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
	$loadingJpg=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".jpg"`;
	if (`file -q -ex $loadingJpg`)
		sysFile -cp $jpg $loadingJpg;
	$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
	$loadingAvi=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".avi"`;
	if (`file -q -ex $loadingAvi`)
		sysFile -cp $avi $loadingAvi;
	$label=$loadData[2];
	$cmd=$loadData[3];
	if ($asfileLoading)
		$cmd=`substitute $loadData[0] $cmd $uiName`;
	$anim=$loadData[5];
	}
$numTok=`tokenize $cmd ";" $buffer`;
if ($numTok==2)
	$singleAttr=1;
setParent ($uiName+"GridLayout");
columnLayout ($uiName+"ColumnLayout"+$childNum);
gridLayout -e -pos ($uiName+"ColumnLayout"+$childNum) $childNum ($uiName+"GridLayout");
rowColumnLayout -ann $anim -nc 2 -cw 1 100 -cw 2 15 ($uiName+"RowColumnLayout"+$childNum);
	iconTextButton -w 100 -h 75 -i $image -c $cmd ($uiName+"IconTextButton"+$childNum);
	floatSlider -m 0 -w 10 -h 75 -hr 0 ($uiName+"FloatSlider"+$childNum);
	text -h 15 -al "center" -fn "smallBoldLabelFont" -l $label ($uiName+"Text"+$childNum);
if ($anim)
	text -e -bgc 1 0 0 ($uiName+"Text"+$childNum);
if ($loadData[0]=="" || $asfileLoading)
	{
	asPoserupdateGridBlock $uiName $childNum;
	iconTextButton -e -dgc asPoserDgc -dpc asPoserDpc ($uiName+"IconTextButton"+$childNum);
	}

//connectControl
string $connectToObj,$connectToAttr,$resolvedDestination;
string $allKeyableAttrs[];
if ($singleAttr)
	{
	tokenize $cmd "\"" $buffer;
	tokenize $buffer[1]  $buffer;
	tokenize $buffer[0] "." $buffer;
	$connectToObj=$buffer[0];
	$connectToAttr=$buffer[1];
	$resolvedObj=`asPoserResolveNameSpace $uiName $connectToObj`;
	if (`objExists $resolvedObj`)
		$allKeyableAttrs=`listAttr -k -m -sn $resolvedObj`;

	for ($allKeyableAttr in $allKeyableAttrs)
		if ($connectToAttr==$allKeyableAttr)
			if (`getAttr -se ($resolvedObj+"."+$connectToAttr)`)
					{
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						if (!`attributeQuery -n $resolvedObj -re $connectToAttr`)
							break;
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						$range=`attributeQuery -n $resolvedObj -r $connectToAttr`;
					else
						//probably a muli attr  e.g. blenShape target..using range 0->1
						$range={0,1};
					floatSlider -ann ($connectToObj+"."+$connectToAttr) -e -m 1 -min $range[0] -max $range[1] ($uiName+"FloatSlider"+$childNum);
					connectControl ($uiName+"FloatSlider"+$childNum) ($resolvedObj+"."+$connectToAttr);
					text -e -l $connectToAttr ($uiName+"Text"+$childNum);
					}
	}
setParent $setParent;
}

global proc asPoserUpdateGrid ()
{
int $nc=`intField -q -v asPoserNc`;
optionVar -iv asPoserNc $nc;
int $nr=`intField -q -v asPoserNr`;
optionVar -iv asPoserNr $nr;
string $poserText=`textField -q -tx asPoserTextField`;
optionVar -sv asPoserText $poserText;
int $onlySel=`checkBox -q -v asPoserOnlySel`;
optionVar -iv asPoserOnlySel $onlySel;
int $anim=`checkBox -q -v asPoserAnim`;
optionVar -iv asPoserAnim $anim;
int $renderView=`checkBox -q -v asPoserRenderView`;
optionVar -iv asPoserRenderView $renderView;

if ($nc<1)
	{
	intField -e -v 1 asPoserNc;
	asPoserUpdateGrid;
	return;
	}
if ($nr<1)
	{
	intField -e -v 1 asPoserNr;
	asPoserUpdateGrid;
	return;
	}
gridLayout -e -nc $nc -nr $nr -w (110*$nc) -h (90*$nr) asPoserDefaultGridLayout;
}

global proc asPoserRename (int $childNum)
{
if (!`text -q -ex ("asPoserDefaultText"+$childNum)`)
	error "Cant find `text` uiElement\n";
string $oldname=`text -q -l ("asPoserDefaultText"+$childNum)`;
string $result=`promptDialog -m "Name:" -tx $oldname -t ("AdvancedSkeleton") -b "Ok" -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($result=="Cancel")
	return;
string $newName=`promptDialog -q -tx`;
text -e -l $newName ("asPoserDefaultText"+$childNum);
}

global proc asPoserDeletePose (string $uiName, int $num)
{
string $image=`iconTextButton -q -i ($uiName+"IconTextButton"+$num)`;
$jpgImage=`substitute "[.]png" $image ".jpg"`;
$jpgImage=`substitute "[.]xpm" $jpgImage ".jpg"`;
sysFile -del $image;
sysFile -del $jpgImage;

evalDeferred ("deleteUI "+$uiName+"ColumnLayout"+$num);
}

global proc string asPoserSnapShoot (string $uiName, int $childNum, int $anim, int $updateIcon, int $updateMovie)
{
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
int $renderView=`checkBox -q -v asPoserRenderView`;
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;

int $curFrame=`currentTime -q`;
int $startFrame=$endFrame=$curFrame;
int $currFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
string $huds[]=`headsUpDisplay -listHeadsUpDisplays`;
int $hudStates[];
for ($i=0;$i<size($huds);$i++)
	{
	$hudStates[$i]=`headsUpDisplay -q -vis $huds[$i]`;
	headsUpDisplay -e -vis 0 $huds[$i];
	}
string $ext;
if (`asMayaVersionAsFloat`>=2011)
	{
	$ext="png";
	setAttr "defaultRenderGlobals.imageFormat" 32;
	}
else
	{
	$ext="xpm";
	setAttr -type "string" defaultRenderGlobals.imfPluginKey "xpm";
	setAttr defaultRenderGlobals.imageFormat 50;
	}
string $fileName=$iconDir+"untitled_"+$childNum;
string $iconImage=$fileName+"."+$ext;
string $blastImage=$fileName+"."+`asDoPadd $curFrame 4`;
string $blastMovie=$fileName+".avi";
string $largeImage=$fileName+".jpg";
string $bgImageFile32=$iconDir+"untitled_background32."+$ext;
int $iconExists;
if (`file -q -ex $iconImage`)
	$iconExists=1;
		
if ($renderView && $updateIcon)
	{
	if (`renderWindowEditor -q -nim renderView`<0)
		error ("No Image In RenderView\n");
	eval ("renderWindowEditor -e -wi \""+$iconImage+"\" renderView");
	asPoserResizeImage 100 75 $iconImage $iconImage;
	setAttr defaultRenderGlobals.imageFormat 8;
	evalEcho ("renderWindowEditor -e -wi \""+$largeImage+"\" renderView");
	}
if (!$renderView && $updateIcon)
	{
	playblast -w 100 -h 75 -compression "png" -p 100 -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $iconImage ($blastImage+"."+$ext);
	}

setAttr defaultRenderGlobals.imageFormat 8;

if ($anim && $updateMovie)
	playblast -p 100 -st `playbackOptions -q -min` -et `playbackOptions -q -max` -f $fileName -fmt movie -fo -clearCache 0 -viewer 0 -showOrnaments 0;
else if ($updateIcon)
	{
	playblast -p 100 -compression "png" -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $largeImage ($blastImage+".jpg");
	}
setAttr defaultRenderGlobals.imageFormat $currFormat;
for ($i=0;$i<size($huds);$i++)
	headsUpDisplay -e -vis $hudStates[$i] $huds[$i];


if (`about -linux`)
	$iconImage=`asConvertToXpm $iconImage`;

//32x32
if (!`file -q -ex $bgImageFile32`)
	{
	asPoserResizeImage 32 32 $iconImage $bgImageFile32;
	if (`about -linux`)
		asConvertToXpm $bgImageFile32;
	}

if ($iconExists)
	reloadImage $iconImage ($uiName+"IconTextButton"+$childNum);
return $iconImage;
}

global proc asPoserResizeImage (int $x, int $y, string $inputImage, string $outputImage)
{
string $sel[]=`ls -sl`;
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
string $uniqueFileName=`asUniqueFile $inputImage`;
string $fileNode=`createNode file`;
setAttr -type "string" ($fileNode+".fileTextureName") $uniqueFileName;
eval ("convertSolidTx -sp 1 -al 1 -rx "+$x+" -ry "+$y+" -n asTempSolidTx32 -fil \""+$buttonImageFileExt+"\" -fin \""+$outputImage+"\"");
delete $fileNode asTempSolidTx32;
sysFile -del $uniqueFileName;
select $sel;
}

global proc string asDoPadd (int $frameNr,int $padding)
{
string $frameName;
string $padd="";
string $neg="";
string $frameNrAsString=$frameNr;
for ($i=0;$i<$padding;$i++)
	$padd=$padd+"0";
//move the negative symbol to start of string//
if ($frameNr<0)
	$neg="-";
int $nr=`size ($frameNrAsString)`;
if ($padding>$nr)
	$frameName=$neg+`substring $padd ($nr+1) 999`+abs($frameNr);
else
	$frameName=$frameNr;
return $frameName;
}

global proc string[] asPoserDgc (string $dragControl, int $x, int $y, int $mods) 
{
string $return[];
$return[0]=$x;
$return[1]=$y;
$return[2]=$mods;
return $return;
}

global proc asPoserDpc (string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) 
{
//print ("$dragControl="+$dragControl+" $dropControl="+$dropControl+" $msgs[3]="+$msgs[3]+" $msgs[1]="+$msgs[1]+" $x="+$x+" $y="+$y+" $type="+$type+"\n");
string $iconDir=`internalVar -utd`+"AdvancedSkeleton/Poser/untitled/";
if (`gmatch $dropControl "*IconTextButton*"`)
	return;
int $left=$msgs[0];
int $top=$msgs[1];

int $nc=`intField -q -v asPoserNc`;
int $nr=`intField -q -v asPoserNr`;
	
string $match=`match "[0-9]+$" $dragControl`;
int $oldChildNum=$match;
int $newRowNum=ceil(($x+0.00)/110);
int $newColNum=ceil(($y+0.00)/90);
int $newChildNum=$newRowNum+(($newColNum-1)*$nc);
if ($newChildNum==$oldChildNum)
	return;
if ($newChildNum>($nc*$nr))
	error "out of grid, extend rows or columns !\n";
string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
if (`gmatch $gridOrder[$newChildNum-1] "asPoser*"`)
	error "grid position is occupied !\n";
gridLayout -e -pos ("asPoserDefaultColumnLayout"+$oldChildNum) $newChildNum asPoserDefaultGridLayout;

//rename UI elements
string $children[]=`layout -q -ca ("asPoserDefaultColumnLayout"+$oldChildNum)`;
$children[size($children)]="asPoserDefaultColumnLayout"+$oldChildNum;
string $grandChildren[]=`layout -q -ca $children[0]`;
string $allChildren[]=`stringArrayCatenate $children $grandChildren`;
string $tempString[];
string $cmd;
int $numDigitsInIldChildNum=size($match);
int $numDigitsInChild;
int $numDigitsInImage;
string $newChildName,$image,$animFile,$newAnimFile;
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
for ($child in $allChildren)
	{
	$numDigitsInChild=size($child);
	string $newChildName=`substring $child 1 ($numDigitsInChild-$numDigitsInIldChildNum)`+$newChildNum;
	renameUI $child $newChildName;

	//rename bitmaps
	if (!`iconTextButton -q -ex $newChildName`)
		continue;
	$image=`iconTextButton -q -i $newChildName`;
	$numDigitsInImage=size($image);
	$newImage=`substring ("\""+$image+"\"") 2 ($numDigitsInImage-3-$numDigitsInIldChildNum)`+$newChildNum+"."+$ext;
	if (`file -q -ex $image` && $newImage!=$image)
		{
		eval ("sysFile -ren \""+$newImage+"\"  \""+$image+"\"");
		iconTextButton -e -i $newImage $newChildName;
		reloadImage $newImage $newChildName;
		$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		if (`file -q -ex $jpg`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".jpg"` `substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		if (`file -q -ex $avi`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".avi"` `substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		}
	//rename anim files
	$animFile=$iconDir+"untitled_"+$oldChildNum+".ma";
	$newAnimFile=$iconDir+"untitled_"+$newChildNum+".ma";
	if (`file -q -ex $animFile` && $newAnimFile!=$animFile)
		eval ("sysFile -ren \""+$newAnimFile+"\"  \""+$animFile+"\"");
	//update animation command
	$cmd=`iconTextButton -q -c $newChildName`;
	tokenize $cmd $tempString;
	if ($tempString[0]=="asLoadAttrs")
		{
		$cmd=$tempString[0]+" "+$tempString[1]+" "+$newChildNum;
		iconTextButton -e -c $cmd $newChildName;
		}
	}
string $uiName="asPoserDefault";
asPoserupdateGridBlock $uiName $newChildNum;
}
//-- ASPoserDesigner Procedures Ends Here --//
//-- ASWalkDesigner Procedures Start Here --//
global proc asWalkDesigner ()
{
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
//create, connectControl, and delete, to disable.
int $mixerExisted=1;
if (!`objExists WalkDesignerMotionMixer`)
	{
	createNode -n WalkDesignerMotionMixer transform;
	addAttr -k 1 -dv 1 -ln "speed" -at double WalkDesignerMotionMixer;
	$mixerExisted=0;
	}
if (`window -q -ex asWalkDesigner`)
	deleteUI asWalkDesigner;
window -mb 1 -t WalkDesigner asWalkDesigner;
formLayout asWDFormLayout;
columnLayout;
optionMenu -w 200 asWalkDesignerOptionMenu;
button -l "Start" -c asWDStart;
columnLayout asWDMixerColumnLayout;
for($i=0;$i<size($motions);$i++)
	{
	if(!$mixerExisted)
		addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	rowLayout -nc 2 -cw2 240 100;
		floatSliderGrp -label $motions[$i] -field true -cw 1 80 -cw 2 50 -cw 3 100 -min 0 -max 1 ("asWDField"+$i);
		connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
		button -l "solo" -c ("asWDSolo "+$i);
		setParent..;
	}
floatSliderGrp -cc asWDSpeedChange -pre 2 -v 1 -label "speed" -field true -cw 1 40 -cw 2 40 -cw 3 180 -min 0.01 -max 2 asWDSpeedField;
connectControl asWDSpeedField WalkDesignerMotionMixer.speed;
if (`asIsMayaLT`)
	floatSliderGrp -e -en 0 asWDSpeedField;
setParent..;

frameLayout -w 279 -cll 1 -cl 1 -l "Baking";
columnLayout;
//text -l "baking:";
checkBox -cc asWDSpeedChange -l "loop animation (curves > post infinity > cycle)" -v 1 -onc "intField -e -en 0 asWDLoopsIntField" -ofc "intField -e -en 1 asWDLoopsIntField" asWDLoopCheckBox;
text -l "or";
rowLayout -nc 3;
	text -l "loop animation";
	intField -cc asWDSpeedChange -en 0 -w 30 -min 1 -v 1 asWDLoopsIntField;
	text -l "times";
	setParent..;
button -l "Ok, Bake keys onto character" -c asWDBake;
setParent..;
setParent..;
setParent..;
button -l "Cancel and Close" -c asWDFinish asWDClose;
formLayout -e 
	-attachForm asWDClose "bottom" 0
	-attachForm asWDClose "left" 0
	-attachForm asWDClose "right" 0
	asWDFormLayout;

asPopulateNameSpaceMenu "asWalkDesigner";
if(!$mixerExisted)
	delete WalkDesignerMotionMixer;
showWindow;
}

global proc asWDBake ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
select -cl;
string $allFkControls[];
for($i=0;$i<size($consts);$i++)
	{
	string $fkControl=$nameSpace+"FK"+$consts[$i];
	if ($consts[$i]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	$allFkControls[size($allFkControls)]=$fkControl;
	select -add $fkControl;
	}

if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}

bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "rx" -at "ry" -at "rz";
select ($nameSpace+"RootX_M");
bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "tx" -at "ty" -at "tz";
if (`checkBox -q -v asWDLoopCheckBox`)
	{
	select $allFkControls;
	setInfinity -poi cycle;
	}
asWDFinish;
}

global proc asWDSpeedChange ()
{
if (!`objExists WalkDesignerMotionMixer` || !`objExists walkDesignerClip`)
	return;
float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);
if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr walkDesignerClip.scale (1.0/$speed);
}

global proc asWDStart ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";
if (!`objExists ($nameSpace+"Main")`)
	error ("AdvancedSkeleton not found in your scene");
float $charHeight=`getAttr ($nameSpace+"Main.height")`;

string $motionFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asMotion.ma";
if (!`file -q -ex $motionFile`)
	error ("Not found:"+$motionFile);
if (`objExists WalkDesignerMotionMixer`)
	error ("\"WalkDesignerMotionMixer\", already exists, delete this object, before starting again");
if (!`file -q -ex $motionFile`)
	error ("Required motion file not found:\""+$motionFile+"\"");
string $tempString[]=`ls "asMotion:*"`;
if (size($tempString))
	delete $tempString;
if (`namespace -ex "asMotion"`)
	if (catchQuiet (`namespace -dnc -rm "asMotion"`))
		{ 
		//Maya2012 and older dont have namespace -dnc, so we work around the problems of empty nameSpaces not agknowlowdge their empty
		for($i=0;$i<99;$i++)
			if (!`namespace -ex ("tempNameSpace"+$i)`)
				break;
		namespace -ren asMotion ("tempNameSpace"+$i);
		}
if (`namespace -ex "asMotion"`)
	error "Unable to remove namespace \"asMotion\", try restarting Maya";
/*
$tempString=`listConnections time1.timewarpIn_Raw`;
if (size($tempString))
	delete $tempString;
if (!`asIsMayaLT`)
	AddTimeWarp;
*/

file -ns "asMotion" -i $motionFile;
setAttr asMotion:Group.v 0;
setAttr -type float3 asMotion:Group.s ($charHeight/12.0) ($charHeight/12.0) ($charHeight/12.0);

createNode -n WalkDesignerMotionMixer transform;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.tx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ty;setAttr -l 1 -k 0 WalkDesignerMotionMixer.tz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.rx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ry;setAttr -l 1 -k 0 WalkDesignerMotionMixer.rz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.sx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sy;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.v;
addAttr -k 1 -ln "speed" -dv 1 -at double WalkDesignerMotionMixer;
addAttr -k 0 -ln defaultEndTime -at double WalkDesignerMotionMixer;
parent "asMotion:Group" WalkDesignerMotionMixer;

select -hi "asMotion:Group";
select -d "asMotion:Group";
if (!`asIsMayaLT`)
	{
	character -name walkDesignerSet -excludeVisibility -excludeScale;
	clip -name walkDesignerClip -sc 1 -allAbsolute -animCurveRange walkDesignerSet;
	setAttr walkDesignerClip.postCycle 9999;
	}

if (`objExists ($nameSpace+"FKIKLeg_R")`) setAttr ($nameSpace+"FKIKLeg_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKLeg_L")`) setAttr ($nameSpace+"FKIKLeg_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_R")`) setAttr ($nameSpace+"FKIKArm_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_L")`) setAttr ($nameSpace+"FKIKArm_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKSpine_M")`) setAttr ($nameSpace+"FKIKSpine_M.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKShoulder_R")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_R")`) setAttr ($nameSpace+"FKShoulder_R.Global") 0;
if (`objExists ($nameSpace+"FKShoulder_L")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_L")`) setAttr ($nameSpace+"FKShoulder_L.Global") 0;
if (`objExists ($nameSpace+"FKWrist_R")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_R")`) setAttr ($nameSpace+"FKWrist_R.Global") 0;
if (`objExists ($nameSpace+"FKWrist_L")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_L")`) setAttr ($nameSpace+"FKWrist_L.Global") 0;
if (`objExists ($nameSpace+"FKHead_M")`) if (`attributeExists "Global"  ($nameSpace+"FKHead_M")`) setAttr ($nameSpace+"FKHead_M.Global") 0;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
string $orientConstraint,$pointConstraint;

for($i=0;$i<size($motions);$i++)
	{
	addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	for($y=0;$y<size($consts);$y++)
		{
		$fkControl=$nameSpace+"FK"+$consts[$y];
		if ($consts[$y]=="Root_M")
			{
			$fkControl=$nameSpace+"RootX_M";
			$tempString=`pointConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
			$pointConstraint=$tempString[0];
			}
		if (!`objExists $fkControl`)
			continue;
		$tempString=`orientConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
		$orientConstraint=$tempString[0];
		setAttr ($orientConstraint+".interpType") 2;

		if ($consts[$y]=="Root_M")
			{
			setAttr RootX_M_orientConstraint1.offsetX -90;
			setAttr RootX_M_orientConstraint1.offsetY -90;
			connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($pointConstraint+"."+$consts[$y]+"W"+$i);
			}
		connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($orientConstraint+"."+$consts[$y]+"W"+$i);
		}
	connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  $side="_R";
	if ($b==-1) $side="_L";
	setAttr ("FKHip"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKKnee"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKAnkle"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKToes"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKShoulder"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKElbow"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKWrist"+$side+"_orientConstraint1.offsetX") -90;
	}

connectControl asWDSpeedField WalkDesignerMotionMixer.speed;

if (`attributeExists walk_male WalkDesignerMotionMixer`)
	setAttr WalkDesignerMotionMixer.walk_male 1;
currentTime 0;
if (`objExists ($nameSpace+"FKAnkle_R")` && `objExists ($nameSpace+"Ankle")`)
	{
	float $anklePos[3]=`xform -q -ws -t ($nameSpace+"FKAnkle_R")`;
	float $fitAnklePos[3]=`xform -q -ws -t ($nameSpace+"Ankle")`;
	float $offset=$anklePos[1]-$fitAnklePos[1];
	setAttr asMotion:Group.ty ($offset*-1);
	}
float $tempFloats[]=`keyframe -index 1 -q  -tc asMotion:Group.timing`;
float $endTime=$tempFloats[0];
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr WalkDesignerMotionMixer.defaultEndTime $endTime;
select -cl;
}

global proc asWDSolo (int $num)
{
if (!`objExists WalkDesignerMotionMixer`)
	error ("WalkDesignerMotionMixer not found");
float $value;
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
for($i=0;$i<size($motions);$i++)
	{
	if ($i==$num)
		$value=1;
	else
		$value=0;
	floatSliderGrp -e -v $value ("asWDField"+$i);
	setAttr ("WalkDesignerMotionMixer."+$motions[$i]) $value;
	}
}

global proc asWDFinish ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

if (`objExists walkDesignerSet`)
	delete walkDesignerSet;
if (`objExists WalkDesignerMotionMixer`)
	delete WalkDesignerMotionMixer;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Chest_M","Chest_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $tempString[];
string $attrs[]={"tx","ty","tz","rx","ry","rz"};
for($y=0;$y<size($consts);$y++)
	{
	$fkControl=$nameSpace+"FK"+$consts[$y];
	if ($consts[$y]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	for($i=0;$i<size($attrs);$i++)
		{
		$tempString=`listConnections ($fkControl+"."+$attrs[$i])`;
		if (!size($tempString))
			setAttr ($fkControl+"."+$attrs[$i]) 0;
		}
	}
deleteUI asWalkDesigner;
}
//-- ASWalkDesigner Procedures Ends Here --//
//-- ASModelCleaner Procedures Starts Here --//
global proc asModelCleaner ()
{
if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

window -s 1 -title "Model Cleaner" modelCleaner;
columnLayout;
	separator -st none -h 10;
	text -l "This will cleanup your model.\n";
	if (!`pluginInfo -q -l objExport`)
		{
		text -l "The objExport plugin must be loaded:";
		button -l "load objExport plugin" -c "loadPlugin objExport;print (\"// OK, objExport plugin loaded\\n\")";
		separator -h 10 -st none;
		}
	text -l "Create top level group, called \"geo\":";
	button -c modelCleanGreateGeo -label "Create";
	separator -st none -h 10;
	text -l "Now ready for Clean.";
	text -fn "smallBoldLabelFont" -l "(Save your scene first, for safe keeping)\n";
	button -w 230 -c modelCleanGo -ann "clean model" -label "Clean";
showWindow modelCleaner;
}

global proc modelCleanGreateGeo ()
{
if (!`objExists |geo`)
	createNode -n geo transform;
string $tempString[];
string $topLevXforms[]=`ls -as -l`;
for($i=0;$i<size($topLevXforms);$i++)
	{
	if ($topLevXforms[$i]=="|geo")
		continue;
	$tempString=`listRelatives -s $topLevXforms[$i]`;
	if (`size ($tempString)`==0 || `objectType $tempString[0]`=="mesh")
		parent $topLevXforms[$i] |geo;
	}
select |geo;
}

global proc modelCleanGo ()
{
global string $gMainProgressBar;
global string $gMainPane;
string $sceneName=`file -q -sn`;
string $references[];
string $allReferences[]=`file -q -r`;
for ($i=0;$i<size($allReferences);$i++)
	if (!`file -q -deferReference $allReferences[$i]`)
		$references[size($references)]=$allReferences[$i];

select -cl;

string $sceneFile=`file -q -sn`;
string $tmpFile=`internalVar -utd`+"AdvancedSkeleton/modelCleaner/tmp.ma";
if (`asIsMayaLT`)
	$tmpFile=`internalVar -utd`+"AdvancedSkeleton/modelCleaner/tmp.mlt";
int $eyeCandy=0;
int $moreThanOneWithSameName;
string $plugins[]=`pluginInfo -q -ls`;
string $parent[],$tempString[],$longNames[],$buffer[],$oldShapeName[],$partitionPlugs[],$creaseMembers[],$objFileName[];
float $temp[];
float $perspPos[]=`getAttr persp.translate`;
float $perspRot[]=`getAttr persp.rotate`;
int $isGroup[];
int $doubleSided[];
for ($plug in $plugins)
	if (!`stringArrayCount "objExport" $plugins`)
	error "You Must Load the \"objExport\" plugin !";

string $tempDir=`internalVar -utd`+"AdvancedSkeleton/modelCleaner/";
if (!`file -q -ex $tempDir`)
	sysFile -md $tempDir;

//Pre Flight Check
if (!`objExists geo`)
	error "group \"geo\" does not exists !\n";
string $all[]=`ls -noIntermediate`;
for ($obj in $all)
	{
	if (`gmatch $obj "*|*"`)
		{
		$tempString=`listRelatives -ap $obj`;
		if (size($tempString)==1)
			{
			select -add $obj;
			$moreThanOneWithSameName=1;
			}
		}
	}
if ($moreThanOneWithSameName)
	modelCleanMakeUniqueNames;
if (`objExists "polySurface1"`)
	{
	select "polySurface1";
	error "Illegal objectName \"polySurface1\"";
	}

//delete imagePlanes
string $imagePlanes[]=`ls -type imagePlane`;
if (size($imagePlanes))
	delete $imagePlanes;

//delete unused refNodes
deleteUnusedRefNodes;

//unParent all place3dTextures
string $place3ds[]=`ls -type place3dTexture`;
for ($i=0;$i<size($place3ds);$i++)
{
$tempString=`listRelatives -p $place3ds[$i]`;
if(size($tempString))
	parent -w $place3ds[$i];
}

//remove old files
string $fileList[]=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size( $fileList);$i++)
{
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);
}

//Remove nameSpaces
$all=`ls -type transform`;
for ($i=0;$i<size($all);$i++)
    if (`gmatch $all[$i] "*:*"`)
        {
        tokenize $all[$i] ":" $tempString;
        rename $all[$i] $tempString[size($tempString)-1];
        }

//rename Shapes to match name of their Xform
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
    	$tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"TEMPShape");
    	}
$meshes=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
	    $tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"Shape");
    	}

DeleteAllHistory;

//createShaderAssigner
string $assigned[], $shadingEngines[], $namespaces[];
string $allTrns[]=`ls -type transform`;
string $place3dTextures[]=`ls -type place3dTexture`;
if (`objExists shaderAssign`) 
	delete shaderAssign;
createNode -n shaderAssign transform;
addAttr -ln notes -dt "string" shaderAssign;
$shadingEngines=`ls -type shadingEngine`;
string $connections = ("global proc cleanConnectFileNodes(string $namespace1, string $namespace2) {\n");
for ($i=0;$i<size($shadingEngines);$i++) {
	if (`gmatch $shadingEngines[$i] "initial*"`)
		continue;
	$assigned=`sets -q $shadingEngines[$i]`;
	for ($z=0;$z<size($assigned);$z++)
		{
		//per face assigment
//		tokenize $assigned[$z] "." $tempString;
//		$assigned[$z]=$tempString[0];
		}
	$assigned=`stringArrayRemoveDuplicates $assigned`;
	for ($z=0;$z<size($assigned);$z++) 
		{
//		$tempString=`listRelatives -p $assigned[$z]`;
//		$connections+=("catch(`sets -e -fe ($namespace1 + \"" +$shadingEngines[$i]+"\") ($namespace2 + \""+$tempString[0]+"\")`);\n");
		$connections+=("catch(`sets -e -fe ($namespace1 + \"" +$shadingEngines[$i]+"\") ($namespace2 + \""+$assigned[$z]+"\")`);\n");
		}
}
for ($z=0;$z<size($place3dTextures);$z++) {
	$tempString=`listConnections -p 1 ($place3dTextures[$z]+".worldInverseMatrix")`;
	$connections+=("catch(`connectAttr ($namespace2 + \"" +$place3dTextures[$z]+".worldInverseMatrix\") ($namespace1 + \""+$tempString[0]+"\")`);\n");
}
$connections += ("}\n");
setAttr -type "string" shaderAssign.notes $connections;

//exportShaders
string $hyperShadePanelMelFile="C:/Program Files/Autodesk/Maya2012/scripts/others/hyperShadePanel.mel";
if (`file -q -ex$hyperShadePanelMelFile `)
eval ("source \""+$hyperShadePanelMelFile+"\"");
hyperShadePanelMenuCommand("", "deleteUnusedNodes");
string $shadingNodes[]=`lsThroughFilter -na DefaultAllShadingNodesFilter`;
string $objectType;
select -cl;
for ($i=0;$i<size($shadingNodes);$i++)
	{
	$objectType=`objectType $shadingNodes[$i]`;
	if ($objectType=="camera" || `gmatch $objectType "*Light"`)
		continue;
	select -add -ne $shadingNodes[$i];
	}
select -add shaderAssign;
lockNode -l 0 renderPartition;
if (`file -q -ex $tmpFile`)
	sysFile -del $tmpFile;
if (`asIsMayaLT`)
	file -op "v=0;" -typ "mayaLT" -es $tmpFile;
else
	file -op "v=0;p=17" -typ "mayaAscii" -es $tmpFile;

//delete intermediateObjects meshes
$tempString=`ls -intermediateObjects -type mesh`;
if (size($tempString))
	delete $tempString;

// SelectAllPolygonGeometry;
select geo;
select -hi;
string $selAll[]=`ls -l -sl -type transform`;

// read all attribute + their values, to restore after obj import
 string $userAttrs[],$addAttrCmds[];
string $cmd,$sn,$ln,$at,$kk,$dv,$minMax;
float $range[2];
string $shapes[];
string $selAllInclShapes[]=$selAll;
for ($i=0;$i<size($selAll);$i++)
	{
	$tempString=`listRelatives -s $selAll[$i]`;
	if (`objExists $tempString[0]`)
		$shapes[`size($shapes)`]=$tempString[0];
	}
appendStringArray $selAllInclShapes $shapes `size($shapes)`;
for ($i=0;$i<size($selAllInclShapes);$i++)
	{
 	$userAttrs=`listAttr -ud -s $selAllInclShapes[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		if (`getAttr -type ($selAllInclShapes[$i]+"."+$userAttrs[$y])`=="message")
			continue;
		$tempString=`listAttr -sn ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if (`gmatch $at "*Array"` || `gmatch $at "*dataCompound"`)
			continue;
		$dv=`getAttr ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$kk=`getAttr -k ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$l=`getAttr -l ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		$minMax="";
		if (`attributeQuery -re -n $selAllInclShapes[$i] $ln`)
			{
			$range=`attributeQuery -r -n $selAllInclShapes[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		if ($at=="string")
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -dt \""+$at+"\" "+$minMax+" "+$selAllInclShapes[$i]+";"
					+"setAttr -l "+$l+" -type \"string\" "+$selAllInclShapes[$i]+"."+$sn+" \""+`encodeString $dv`+"\";";
		else
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$selAllInclShapes[$i]+";";
		}
	}

// read smooth level
$shapes=`ls -ni -type mesh`;
for ($y=0;$y<size($shapes);$y++)
	{
	if (!`attributeExists "displaySmoothMesh" $shapes[$y]`)
		continue;
	if (!`getAttr -l ($shapes[$y]+".displaySmoothMesh")`)
		continue;
	$smoothLevel=`getAttr ($shapes[$y]+".smoothLevel")`;
	$smoothLock=`getAttr -l ($shapes[$y]+".smoothLevel")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$smoothLock+" "+$shapes[$y]+".smoothLevel "+$smoothLevel+";";
	$dispResolution=`getAttr ($shapes[$y]+".dispResolution")`;
	$displaySmoothMesh=`getAttr ($shapes[$y]+".displaySmoothMesh")`;
	$displaySmoothMeshLock=`getAttr -l ($shapes[$y]+".displaySmoothMesh")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr "+$shapes[$y]+".dispResolution "+$dispResolution+";";
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$displaySmoothMeshLock+" "+$shapes[$y]+".displaySmoothMesh "+$displaySmoothMesh+";";
	}

// select non-instanced geometry
select geo;
select -hi;
string $sel[]=`ls -sl -type transform`;
string $selLong[]=`ls -l -sl -type transform`;
string $selShort[]=$sel;
string $children[];

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "ObjExporting" -bp -ii 1 -min 0 -max (size($sel)) $gMainProgressBar;
for ($i=0;$i<size($sel);$i++)
{
	if (`progressBar -q -ic $gMainProgressBar`)
	{
		break;progressBar -e -ep $gMainProgressBar;
	}
	progressBar -e -s 1 $gMainProgressBar;

	if (`gmatch $obj "*:*"`)
		continue;

	if (`gmatch $selShort[$i] "*|*"`)
		{
		tokenize $selShort[$i] "|" $tempString;
		$selShort[$i]=$tempString[size($tempString)-1];
		}
	select $sel[$i];
	$tempString=`listRelatives -s $sel[$i]`;
	$oldShapeName[$i]=$tempString[0];
	makeIdentity -a 1 -t 1 -r 1 -s 1 $sel[$i];
//		polySetToFaceNormal -setUserNormal;
	DeleteAllHistory;
	if (size(`ls -type nurbsCurve`))
		delete `ls -type nurbsCurve`;
	$tempString=`listRelatives -f -s $sel[$i]`;
	if (size($tempString)==0)
		$isGroup[$i]=1;
	$doubleSided[$i]=1;
	if (`objExists $tempString[0]`)
		if (`attributeExists doubleSided $tempString[0]`)
			$doubleSided[$i]=`getAttr ($tempString[0]+".doubleSided")`;
	$tempString=`listRelatives -p $sel[$i]`;
	if ($tempString[0]!="")
		$parent[$i]=$tempString[0];

	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		sysFile -del ($tempDir+$sel[$i]+".obj");
	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		print ("// Unable to delete "+$tempDir+$sel[$i]+".obj!\n");
	clear $children;
	$children=`listRelatives -f -type transform -c $sel[$i]`;
	if (size($children))
		$children=`parent -w $children`;
	select $sel[$i];
	$objFileName[$i]=`substituteAllString $selLong[$i] "|" "!"`;
	if (`gmatch $objFileName[$i] "!*"`)
		$objFileName[$i]=`substring $objFileName[$i] 2 999`;
	print ("// Exporting: "+$tempDir+$objFileName[$i]+".obj\n");
//		if ($eyeCandy)
//			FrameSelected;
	file -op "groups=0;ptgroups=0;materials=0;smoothing=1;normals=0;" -typ "OBJexport" -pr -es ($tempDir+$objFileName[$i]+".obj");
	if (size($children))
		parent $children $sel[$i];
}
progressBar -e -ep $gMainProgressBar;

//NewScene;
// select -all;delete;
string $filename = `file -q -exn`;
$mayaFileType = `file -q -type`;
file -f -new;
file -type $mayaFileType;
file -rn $filename;
setAttr -type float3 persp.translate $perspPos[0] $perspPos[1] $perspPos[2];
setAttr -type float3 persp.rotate $perspRot[0] $perspRot[1] $perspRot[2];
if ($eyeCandy)
	{
	setNamedPanelLayout "Single Perspective View";
	string $modelPanel=`paneLayout -q -p1 $gMainPane`;
	modelEditor -e -da "smoothShaded" $modelPanel;
	}

//Create groups
for ($i=0;$i<size($sel);$i++)
{
	if ($isGroup[$i])
		createNode -n $sel[$i] transform;
}
for ($i=0;$i<size($sel);$i++)
{
	if ($isGroup[$i])
		{
		if (`objExists $parent[$i]`)
			parent $sel[$i] $parent[$i];
		continue;
		}
print ("// importing: "+$tempDir+$objFileName[$i]+".obj\n");
file -i -type "OBJ" -rpr "DUP" -options "mo=0;lo=1" ($tempDir+$objFileName[$i]+".obj");
$existing[0]="polySurfaceShape1";
$tempString=`listRelatives -p $existing[0]`;
rename $tempString[0] $selShort[$i];

if (`objExists $parent[$i]`)
	parent ("|"+$selShort[$i]) $parent[$i];
if (!$doubleSided[$i])
	setAttr ($sel[$i]+".doubleSided") $doubleSided[$i];
select $sel[$i];
if ($eyeCandy)
	FrameSelected;

// restore original shape name
if (`objExists $sel[$i]`)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objExists $tempString[0]`)
		{
		setAttr ($tempString[0]+".visibleInReflections") 1;
		setAttr ($tempString[0]+".visibleInRefractions") 1;
		if ($tempString[0]!=$oldShapeName[$i])
			{
			print ("// Renaming "+$tempString[0]+" to "+$oldShapeName[$i]+"\n");
			rename $tempString[0] $oldShapeName[$i];
			}
		}
	}
}

// restore added attributes
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

// restore bits in sets
if (`gmatch $sceneName "*/library/set/*"`)
	file -import -type "mayaAscii" -ra false -rpr "export" -options "v=0"  -pr -loadReferenceDepth "all" ($tempDir+"setReferences.ma");

//remove files
$fileList=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size( $fileList);$i++)
{
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);
}

//Import & Assign texturess
file -i $tmpFile;
eval `getAttr shaderAssign.notes`;
cleanConnectFileNodes "" "";
delete shaderAssign;

//set default UI
select -cl;
setNamedPanelLayout "Four View";
FrameAllInAllViews;

if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

print ("// Cleaning finished.\n");
}


global proc deleteUnusedRefNodes ()
{
string $allReferences[]=`file -q -r`;

string $realRefNodes[];
for ($y=0;$y<size($allReferences);$y++)
    $realRefNodes[size($realRefNodes)]=`file -q -rfn $allReferences`;
string $refNodes[]=`ls -type reference`;
for ($y=0;$y<size($refNodes);$y++)
    if (!`stringArrayCount $refNodes[$y] $realRefNodes`)
        {
        lockNode -l 0 $refNodes[$y];
        delete $refNodes[$y];
        }
}

global proc modelCleanMakeUniqueNames ()
{
SelectAllGeometry;
string $alls[]=`ls -sl`;
string $alls2[],$tempString[];
string $suffix;
int $clash;
for ($i=0;$i<size($alls);$i++)
    {
    $break=0;
    SelectAllGeometry;
    select -d $alls[$i];
    $alls2=`ls -sl -sn`;
    $suffix="";
    $clash=0;
    tokenize $alls[$i] "|" $tempString;
    $newName=$tempString[size($tempString)-1]+$suffix;
    for ($z=0;$z<size($alls2);$z++)
        {
        tokenize $alls2[$z] "|" $tempString;
        if ($newName==$tempString[size($tempString)-1])
            {
            for ($aa=0;$aa<999;$aa++)
            if (!`objExists ($newName+$aa)`)
                {
                print("// rename "+$alls[$i]+" "+$alls[$i]+"1\n");                
                rename $alls[$i] ($newName+$aa);
                $break=1;
                break;         
                }
            if ($break)
                break;
            }
        if ($break)
            break;
        }
    }
}
//-- ASModelCleaner Procedures Ends Here --//
//-- ASFace Procedures Starts Here --//
global proc asCreateFaceFitSkeleton ()
{
if (`objExists FaceGroup`)
	if (`confirmDialog -t "Confirm"
	-m "FaceFitSkeleton already exists, this will reset the FaceFitSkeleton"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
if (`objExists FaceGroup`)
	delete FaceGroup;
createNode -n FaceGroup transform;
setAttr -l 1 FaceGroup.inheritsTransform 0;
if (`objExists "|Group"`)
	parent FaceGroup "|Group";
if (`objExists FaceFitSkeleton`)
	delete FaceFitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FaceFitSkeleton;
parent FaceFitSkeleton FaceGroup;
setAttr FaceFitSkeletonShape.overrideEnabled 1;
setAttr FaceFitSkeletonShape.overrideColor 13;
scale -r -p 0 0 0 0.5 0.5 0.5 FaceFitSkeleton.cv[0:7];
duplicate -n FaceFitSkeletonHeight FaceFitSkeleton;
parent FaceFitSkeletonHeight FaceFitSkeleton;
parent -add -s FaceFitSkeletonHeightShape FaceFitSkeleton;
delete FaceFitSkeletonHeight;
move -r 0 1.5 0 FaceFitSkeletonHeightShape.cv[0:7];
setAttr -k 0 -l 1 FaceFitSkeleton.tx;setAttr -k 1 -l 0 FaceFitSkeleton.ty 8;setAttr -k 0 -l 1 FaceFitSkeleton.tz;
setAttr -k 0 -l 1 FaceFitSkeleton.rx;setAttr -k 0 -l 1 FaceFitSkeleton.ry 0;setAttr -k 0 -l 1 FaceFitSkeleton.rz;
setAttr -k 0 FaceFitSkeleton.sx;setAttr -k 0 FaceFitSkeleton.rz;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sx;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sz;
if (`objExists Head_M` && `objExists Neck_M`)
	{
	float $temp1[]=`xform -q -ws -t Head_M`;
	float $temp2[]=`xform -q -ws -t Neck_M`;
	setAttr FaceFitSkeleton.ty (($temp1[1]+$temp2[1])/2.0);
	}
if (`objExists Main`)
	if (`attributeExists height Main`)
		setAttr FaceFitSkeleton.sy (`getAttr Main.height`/5.0);

asFaceEnsureFitBase;
select FaceFitSkeleton;
}

global proc asAnimateFaceFit ()
{
int $autoKeyState=`autoKeyframe -q -state`;
int $eyeBrowsCartoony=0;
if (`optionMenu -q -sl asFaceEyeBrowsStyleOptionMenu`==2)
	$eyeBrowsCartoony=1;
if (!$autoKeyState)
			autoKeyframe -state 1;
string $tempString[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
float $scale=`asFaceGetScale`*0.666;
float $posA[],$posB[];
playbackOptions -min 0 -max 60 -ast 0 -aet 60;
currentTime 0;
int $startStopFrames[];
string $locs[];
$locs={"EyeBrowMain0","EyeBrowMain3","EyeBrowMain6"};

if (`objExists FaceFitAnimateFit`)
	delete FaceFitAnimateFit;
createNode -n FaceFitAnimateFit -p FaceFitSkeleton transform;

spaceLocator -n templateLoc;
setAttr -type float3 templateLocShape.localScale (0.035*$scale) (0.035*$scale) (0.035*$scale);
setAttr templateLocShape.overrideEnabled 1;
setAttr templateLocShape.overrideColor 17;
parent templateLoc FaceFitAnimateFit;

rebuildCurve -n EyeBrowMainAnimateFitCurve -ch 0 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.01 EyeBrowMainCurve;
parent EyeBrowMainAnimateFitCurve FaceFitAnimateFit;
setAttr EyeBrowMainAnimateFitCurveShape.overrideEnabled 1;
setAttr EyeBrowMainAnimateFitCurveShape.overrideColor 13;//Red

for ($i=0;$i<size($locs);$i++)
	{
	duplicate -n $locs[$i] templateLoc;
	if ($i==0) $pos=`xform -q -ws -t EyeBrowMainAnimateFitCurve.cv[0]`;
	if ($i==1) $pos=`xform -q -ws -t EyeBrowMainAnimateFitCurve.cv[2]`;
	if ($i==2) $pos=`xform -q -ws -t EyeBrowMainAnimateFitCurve.cv[4]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $locs[$i];

	if ($i==0) select EyeBrowMainAnimateFitCurve.cv[0:1];
	if ($i==1) select EyeBrowMainAnimateFitCurve.cv[2];
	if ($i==2) select EyeBrowMainAnimateFitCurve.cv[3:4];
	$tempString=`newCluster " -envelope 1"`;
	rename $tempString[0] ($locs[$i]+"Cluster");
	rename $tempString[1] ($locs[$i]+"ClusterHandle");
	$tempString=`listConnections ($locs[$i]+"Cluster.message")`;
	rename $tempString[0] ($locs[$i]+"ClusterSet");
	parent ($locs[$i]+"ClusterHandle") $locs[$i];
	setAttr -l 1 ($locs[$i]+"ClusterHandle.v") 0;
	}
delete templateLoc;

setAttr EyeBrowMainAnimateFitCurve.v 0;
wire -n EyeBrowMainAnimateFitWire -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w EyeBrowMainAnimateFitCurve EyeBrowMainCurve;

if (`objExists EyeBrowMain0`)
	{
	for ($i=0;$i<size($locs);$i++)
		if (!$eyeBrowsCartoony)
			geometryConstraint $geometry $locs[$i];
	$startStopFrames={0,10,20,30,40,50,60};
	for ($a=0;$a<size($startStopFrames);$a++)
		for ($i=0;$i<size($locs);$i++)
			{
			currentTime $startStopFrames[$a];
			setKeyframe ($locs[$i]+".t");
			}
	currentTime 5;refresh;
	for ($i=0;$i<size($locs);$i++)
		move -r 0 (0.0853434*$scale) (-0.0151578*$scale) $locs[$i];
	currentTime 15;refresh;
	for ($i=0;$i<size($locs);$i++)
		move -r 0 (-0.0853434*$scale) 0 $locs[$i];
	currentTime 25;refresh;
	move -r 0 (0.0853434*$scale) 0 EyeBrowMain0;
	currentTime 35;refresh;
	move -r (0.0487867*$scale) (-0.0853434*$scale) 0 EyeBrowMain0;
	currentTime 45;refresh;
	for ($i=0;$i<size($locs);$i++)
		move -r (0.050709*$scale) 0 0 $locs[$i];
	currentTime 55;refresh;
	move -r (-0.0451116*$scale) (0.0709945*$scale) (-0.0499044*$scale) EyeBrowMain6;
	}

if (`objExists EyeBrowMain0`)
	for ($i=0;$i<size($locs);$i++)
		if (!$eyeBrowsCartoony)
			delete ($locs[$i]+"_geometryConstraint1");

if (!$autoKeyState)
			autoKeyframe -state 0;
currentTime 0;
if (`checkBox -q -ex asFaceFitAnimateFit`)
	checkBox -e -ed 1 -v 1 asFaceFitAnimateFit;
}

global proc asFaceFitJawCurves ()
{
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $lowerEyeLidOuterNumCVs=`getAttr lowerEyeLidOuterCurve.spans`+1;
float $pos[],$posA[],$posB[],$posC[];
float $scale=`asFaceGetScale`;
string $curveCmd;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];

createNode -n FaceFitJawCurves -p FaceFitSkeleton transform;

//create Jaw weight-curves : JawCurve
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t JawCorner`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t Jaw`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurve;
setAttr JawCurveShape.overrideEnabled 1;
setAttr JawCurveShape.overrideColor 14;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 3 -d 3 -tol 0.01 JawCurve;
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t JawCurve.cv[1]`;
xform -ws -t $posA[0] $posB[1] $posA[2] JawCurve.cv[1];
$posA=`xform -q -ws -t cheek`;
$posB=`xform -q -ws -t JawCurve.cv[3]`;
xform -ws -t $posA[0] $posB[1] $posA[2] JawCurve.cv[3];
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t JawCurve.cv[4]`;
xform -ws -t $posB[0] $posB[1] $posA[2] JawCurve.cv[4];
asCurveOffsetMesh JawCurve $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurve50
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t cheek`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveMid;
setAttr JawCurveMidShape.overrideEnabled 1;
setAttr JawCurveMidShape.overrideColor 13;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.01 JawCurveMid;
/*
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t JawCurveMid.cv[1]`;
xform -ws -t $posA[0] $posB[1] $posB[2] JawCurveMid.cv[1];
$posA=`xform -q -ws -t cheekRaiser`;
$posB=`xform -q -ws -t JawCurveMid.cv[3]`;
xform -ws -t $posA[0] $posB[1] $posA[2] JawCurveMid.cv[2];
$posA=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
$posB=`xform -q -ws -t JawCurveMid.cv[4]`;
xform -ws -t $posB[0] $posB[1] $posA[2] JawCurveMid.cv[3];
*/
asCurveOffsetMesh JawCurveMid $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurveTop
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t noseCorner`;
$posC=`xform -q -ws -t cheek`;
$posD=`xform -q -ws -t cheekRaiser`;
$curveCmd+=" -p "+(($posA[0]+$posC[0])/2.0)+" "+(($posA[1]+$posD[1])/2.0)+" "+(($posA[2]+$posC[2])/2.0)+" ";
$posA=`xform -q -ws -t cheekRaiser`;
$curveCmd+=" -p "+(($posA[0]+$posC[0])/2.0)+" "+$posD[1]+" "+(($posA[2]+$posC[2])/2.0)+" ";
$pos=`xform -q -ws -t noseCorner`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t NoseUnder`;
$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveTop;
setAttr JawCurveTopShape.overrideEnabled 1;
setAttr JawCurveTopShape.overrideColor 6;
asCurveOffsetMesh JawCurveTop $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurveBottom
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t JawCurve.cv[1]`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+($pos[2]-($scale/20.0))+" ";
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$posB[0]+" "+$posA[1]+" "+($pos[2]-($scale/20.0))+" ";
$pos=`xform -q -ws -t Throat`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveBottom;
setAttr JawCurveBottomShape.overrideEnabled 1;
setAttr JawCurveBottomShape.overrideColor 6;
asCurveOffsetMesh JawCurveBottom $geometry ($scale/150.0);

parent JawCurve JawCurveMid JawCurveTop JawCurveBottom FaceFitJawCurves;

if (`checkBox -q -ex asFaceFitJawCurves`)
	checkBox -e -ed 1 -v 1 asFaceFitJawCurves;
select -cl;
}

global proc asFaceToggleClusterSetup ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $isOn=`getAttr ClustersRegion.v`;

if (!$isOn)
	showRegion Clusters;
else
	showRegion Normal;
}

global proc asFaceDesignMouthOpen ()
{
float $scale=`asFaceGetScale`;
//float $posA[]=`xform -q -ws -t lowerLipMain0`;
int $lowerLipMainNumCVs=`getAttr lowerLipMainCurve.spans`+1;
float $posA[]=`xform -q -ws -t lowerLipMainCurve.cv[0]`;
float $posB[]=`xform -q -ws -t lowerLipMainCurve.cv[$lowerLipMainNumCVs]`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];

createNode -n LipDeformations -p RegionDeformations transform;
if (`objExists tempTargetFullMesh`)
	duplicate -n LipDeform tempTargetFullMesh;
else
	duplicate -n LipDeform tempTarget;
setAttr LipDeform.v 1;
parent LipDeform LipDeformations;
sets -e -forceElement initialShadingGroup LipDeform;
//$posA[0]=$scale/3.0;
setAttr LipDeform.tx $posA[0];

select -r LipDeform;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
rename $tempString[0] mouthOpenSoftMod;
rename $tempString[1] mouthOpenSoftModHandle;
$tempString=`listConnections mouthOpenSoftMod.message`;
rename $tempString[0] mouthOpenSoftModSet;
setAttr -type float3 mouthOpenSoftModHandleShape.origin $posA[0] $posA[1] $posA[2];
setAttr mouthOpenSoftMod.falloffCenter $posA[0] $posA[1] $posA[2];
xform -piv $posA[0] $posA[1] $posA[2] mouthOpenSoftModHandle;
setAttr mouthOpenSoftMod.falloffMode 1;
setAttr mouthOpenSoftMod.falloffRadius ((0-$posB[0])*2);

//topVtx pos before move softMod
createNode -n closestSampler2 closestPointOnMesh;
connectAttr -f LipDeform.outMesh closestSampler2.inMesh;
$posA=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
setAttr -type float3 closestSampler2.inPosition $posA[0] $posA[1] $posA[2];
string $topVtx="LipDeform.vtx["+`getAttr closestSampler2.result.closestVertexIndex`+"]";
$posA=`xform -q -ws -t $topVtx`;
delete closestSampler2;

setAttr mouthOpenSoftModHandle.ty ($scale/-10.0);
setAttr "mouthOpenSoftMod.falloffCurve[1].falloffCurve_FloatValue" 1;

//increase radius, until topVtx is included
setAttr mouthOpenSoftMod.falloffRadius 0;
$posA=`xform -q -ws -t $topVtx`;
float $radius=(0-$posB[0])*2;
setAttr mouthOpenSoftMod.falloffRadius $radius;
for ($i=0;$i<99;$i++)
	{
	$posB=`xform -q -ws -t $topVtx`;
	if ($posB[1]-$posA[1]!=0)
		break;
	$radius+=($scale/1000.0)*$i;
	setAttr mouthOpenSoftMod.falloffRadius $radius;
	}
setAttr "mouthOpenSoftMod.falloffCurve[1].falloffCurve_FloatValue" 0.05;
setAttr "mouthOpenSoftMod.falloffCurve[0].falloffCurve_FloatValue" 0.95;

//Delete `all-except-lips` from LipDeform
select lipArea;
$tempString=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	select -add `substitute $geometry $tempString[$i] LipDeform`;
ConvertSelectionToContainedFaces;
InvertSelection;
delete;

setAttr mouthOpenSoftModHandle.ty 0;
parentConstraint -mo FKJaw_M mouthOpenSoftModHandle;
scaleConstraint FKJaw_M mouthOpenSoftModHandle;

//Hide lips from JawOpenRegion
//shadingNode -n asBlank -asShader lambert;
//sets -renderable true -noSurfaceShader true -empty -name asBlankSG;
//connectAttr -f asBlank.outColor asBlankSG.surfaceShader;
//setAttr asBlank.transparency -type double3 1 1 1;
select lipArea;
$tempString=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	select -add `substitute $geometry $tempString[$i] JawOpenRegion`;
ConvertSelectionToContainedFaces;
delete;
//sets -e -forceElement "asBlankSG" `ls -sl`;
string $historyNodes[]=`listHistory JawOpenRegion`;
for ($y=0;$y<size($historyNodes);$y++)
	if (`nodeType $historyNodes[$y]`=="deleteComponent")
		rename $historyNodes[$y] JawOpenRegionDeleteComponent;

select mouthOpenSoftModHandle;
}

global proc asFaceAssist (string $section)
{
int $spans,$degree,$numCVs;
float $scale=`asFaceGetScale`;
string $tempString[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $part="Main";
if ($section=="Lip") $part="Outer";

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	$spans=`getAttr ($upperLower+$section+$part+"Curve.spans")`;
	$degree=`getAttr ($upperLower+$section+$part+"Curve.degree")`;
	$numCVs=$spans+$degree;
	$middleCvNr=($numCVs-1)/2;
	float $posA[]=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv["+$middleCvNr+"]")`;
//	float $posA[]=`xform -q -ws -t ($upperLower+$section+$part+"3")`;
	if ($section=="Lip")
		$posA=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv[0]")`;
	float $posB[]=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv["+($numCVs-1)+"]")`;
	select -r $geometry;
	$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
	rename $tempString[0] ($upperLower+"TempSoftMod");
	rename $tempString[1] ($upperLower+"TempSoftModHandle");
	setAttr -type float3 ($upperLower+"TempSoftModHandleShape.origin") $posA[0] $posA[1] $posA[2];
	setAttr ($upperLower+"TempSoftMod.falloffCenter") $posA[0] $posA[1] $posA[2];
	xform -piv $posA[0] $posA[1] $posA[2] ($upperLower+"TempSoftModHandle");
	setAttr ($upperLower+"TempSoftMod.falloffMode") 1;
	setAttr ($upperLower+"TempSoftMod.falloffRadius") ($posA[0]-$posB[0]);
	move -r 0 ($scale/30.0*$upperLowerFactor) ($scale/10.0) ($upperLower+"TempSoftModHandle");
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_FloatValue") 1;
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_Position") 0.5;
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_Interp") 2;
	}
}

/*
global proc asFaceFitProject (string $section,string $part,int $upAndLo)
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
float $scale=`asFaceGetScale`;
spaceLocator -n tempLoc;
string $locs[]=`listRelatives -c ("FaceFit"+$section+$part+"Loc")`;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if ($upAndLo==0) $upperLower="";
	if ($upAndLo==0 && $upperLowerFactor==-1)
		continue;

	if (`objExists ($upperLower+$section+$part+"4")`)
		$locs[size($locs)]=($upperLower+$section+$part+"4");
	if (`objExists ($upperLower+$section+$part+"1")`)
		$locs[size($locs)]=($upperLower+$section+$part+"1");
	}

for ($a=0;$a<size($locs);$a++)
	{
	parent tempLoc $locs[$a];
	setAttr -type float3 tempLoc.t 0 0 0;
	geometryConstraint $geometry tempLoc;
	for ($i=0;$i<10;$i++)
	  {
		setAttr tempLoc.tx 0;
		setAttr tempLoc.ty 0;
		}
	float $pos[]=`xform -q -ws -t tempLoc`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $locs[$a];
	}
delete tempLoc;
select $sel;
}
*/

global proc asCreateFaceFit (string $section,string $part,int $upAndLo,int $mainAndOuter,int $isSphere)
{
if (`objExists ("FaceFit"+$section+$part)`)
	error ("FaceFit"+$section+$part+" Already Exists");

string $geometry=`textField -q -tx asFaceGeometryTextField`;

if ($section=="Tongue")
	select -cl;

string $sel[]=`ls -sl -fl`;
int $numSelEdges[];
if (!`gmatch $sel[0] "*[.]*"` && $section!="Tongue")
	{
	error "No edge or vertex selected";
	$numSelEdges=`polyEvaluate -edgeComponent`;
	}

if (`objExists upperTempSoftModHandle`) delete upperTempSoftModHandle;
if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;

int $edgeSelection,$vertexSelection,$startVxtSelected,$endVxtSelected;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*[.]e*"`)
		$edgeSelection=1;
	if (`gmatch $sel[$i] "*[.]vtx*"`)
		{
		$vertexSelection=1;
		if ($startVxtSelected)
			$endVxtSelected=1;
		$startVxtSelected=1;
		}
	}

int $nr;
float $scale=`asFaceGetScale`;
float $dist,$dist2;
float $pos[],$posA[],$posB[];
string $upperLower;
string $tempString[],$tempString2[];
currentTime 0;

if ($section=="Jaw" && `objExists FKJaw_M`)
	if (!`asFaceRemoveBodyJaw`)
		return;

if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;

asFitModeEnsureShaders;

spaceLocator -n templateLoc;
setAttr -type float3 templateLocShape.localScale (0.035*$scale) (0.035*$scale) (0.035*$scale);
setAttr templateLocShape.overrideEnabled 1;
setAttr templateLocShape.overrideColor 17;

createNode -n ("FaceFit"+$section+$part) -p FaceFitSkeleton transform;
addAttr -k 1 -min 0 -dv 1 -ln radius -at double ("FaceFit"+$section+$part);
if ($section=="EyeBrow")
	setAttr ("FaceFit"+$section+$part+".radius") 2.5;
createNode -n ("FaceFit"+$section+$part+"Geo") -p ("FaceFit"+$section+$part) transform;
if (!$isSphere)
	setAttr ("FaceFit"+$section+$part+"Geo.inheritsTransform") 0;
createNode -n ("FaceFit"+$section+$part+"Curve") -p ("FaceFit"+$section+$part) transform;
setAttr ("FaceFit"+$section+$part+"Curve.inheritsTransform") 0;
//setAttr ("FaceFit"+$section+$part+"Curve.v") 0;
createNode -n ("FaceFit"+$section+$part+"Loc") -p ("FaceFit"+$section+$part) transform;

if ($isSphere)
	{
	duplicate -n $section templateLoc;
	parent ($section) ("FaceFit"+$section+$part);

	sphere -n ($section+"Sphere") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r (0.02*$scale) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0;
	parent ($section+"Sphere") ("FaceFit"+$section+$part);
	connectAttr ($section+".t") ($section+"Sphere.t");
	connectAttr ($section+".r") ($section+"Sphere.r");
	connectAttr ($section+".s") ($section+"Sphere.s");
	setAttr ($section+"SphereShape.overrideEnabled") 1;
	setAttr ($section+"SphereShape.overrideDisplayType") 2;

	addAttr -k 1 -min 0 -dv 1 -ln "falloffRadius" -at double $section;
	addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 $section;
	}

if (`checkBox -q -ex ("asFaceFit"+$section+$part)`)
	checkBox -e -ed 1 -v 1 ("asFaceFit"+$section+$part);

if ($section=="Tongue")
	{
	$pos=`xform -q -ws -t FaceFitSkeleton`;
	$tempString[0]=`curve -d 1 
		-p 0 ($pos[1]+$scale/10.0) 0
		-p 0 ($pos[1]+$scale/5.0) ($scale/5.0)
		-p 0 ($pos[1]+$scale/5.0) ($scale/3.0)
		-p 0 ($pos[1]+$scale/5.5) ($scale/2.5)
		-p 0 ($pos[1]+$scale/7.0) ($scale/2.2)`;
	rename $tempString[0] TongueCurve;
	parent TongueCurve FaceFitTongue;
//	setAttr TongueCurveShape.dispCV 1;
	setAttr TongueCurveShape.overrideEnabled 1;
	setAttr TongueCurveShape.overrideColor 13;//Yellow
	for ($i=0;$i<5;$i++)
		{
		duplicate -n ("Tongue"+$i) templateLoc;
		parent ("Tongue"+$i) FaceFitTongueLoc;
		$pos=`xform -q -ws -t ("TongueCurve.cv["+$i+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i);
		connectAttr -f ("Tongue"+$i+"Shape.worldPosition[0]") ("TongueCurveShape.controlPoints["+$i+"]");
		}
	select -cl;
	for ($i=0;$i<5;$i++)
		select -add ("Tongue"+$i);
	}

delete templateLoc;

//EdgeSelection based placement
if (!$edgeSelection && !$vertexSelection)
	return;

addAttr -ln selection -dt "string" ("FaceFit"+$section+$part);
$tempString[0]="";
for ($i=0;$i<size($sel);$i++)
	$tempString[0]=$tempString[0]+$sel[$i]+" ";
setAttr -type "string" ("FaceFit"+$section+$part+".selection") $tempString[0];

int $around;
float $minPos[3]={999,999,999};
float $maxPos[3]={-999,-999,-999};
string $minXVtx,$maxXVtx,$minYVtx,$maxYVtx,$minZVtx,$maxZVtx;

if ($isSphere)
	{
	for ($i=0;$i<size($sel);$i++)
		{
		if (!$vertexSelection && `gmatch $sel[$i] "*[.]e*"`)
			{
			select $sel[$i];ConvertSelectionToVertices;$tempString=`ls -sl`;
			$pos=`xform -q -ws -t $tempString[0]`;
			}
		if ($vertexSelection && `gmatch $sel[$i] "*[.]vtx*"`)
			$pos=`xform -q -ws -t $sel[$i]`;
		}
	if ($section=="Nose" || $section=="Jaw" || $section=="NoseUnder" || $section=="Throat")
		$pos[0]=0;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($section+$part);
	sets -e -forceElement "asBlue2SG" ($section+"Sphere");
	select -cl;
	return;
	}

//if ($section=="Lip" && $part=="Main")//special case, LipMain, Open mouth, to correctly distinguish upper from lower
//	asFaceAssist Lip;

select $sel;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;

if ($section=="Lip" && $part=="Outer")//special case, Outer Lip: deselect `lowest half` of vtx, to ensure $maxXVtx not found on lowerLip
	asFaceDeselectLowestHalfOfVtx;

for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	if ($pos[0]<$minPos[0]) {$minPos[0]=$pos[0];$minXVtx=$tempString[$y];}
	if ($pos[1]<$minPos[1]) {$minPos[1]=$pos[1];$minYVtx=$tempString[$y];}
	if ($pos[2]<$minPos[2]) {$minPos[2]=$pos[2];$minZVtx=$tempString[$y];}
	if ($pos[0]>$maxPos[0] && $pos[0]<0.001) {$maxPos[0]=$pos[0];$maxXVtx=$tempString[$y];}
	if ($pos[1]>$maxPos[1] && $pos[0]<0.001) {$maxPos[1]=$pos[1];$maxYVtx=$tempString[$y];}
	if ($pos[2]>$maxPos[2] && $pos[0]<0.001) {$maxPos[2]=$pos[2];$maxZVtx=$tempString[$y];}
	}


//special case, LipMain, cleanup assist
if (`objExists upperTempSoftModHandle`) delete upperTempSoftModHandle;
if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;

string $startVxt=$maxXVtx;
string $endVxt=$minXVtx;
if ($section=="Nose") {$startVxt=$maxYVtx;$endVxt=$minYVtx;}
if ($section=="Tongue") {$startVxt=$minZVtx;$endVxt=$maxZVtx;}
if ($section=="EyeBrow" || $section=="Nose"  || $section=="Tongue")
	$endVxt=""; // mean we will find $endVxt while traversing the edge-selection
//fake a `spesified vtx`, for `Main` & `Inner` to match `Outer`.
if (($part=="Main" || $part=="Inner") && `objExists ($section+"Outer0")` && !$startVxtSelected && $section!="EyeBrow")
	{
	string $closestSampler=`createNode -n closestSampler closestPointOnMesh`;
	connectAttr ($geometry+".outMesh") ($closestSampler+".inMesh");
	$posA=`xform -q -ws -t ("upper"+$section+"Outer0")`;
	setAttr -type float3 ($closestSampler+".inPosition") $posA[0] $posA[1] $posA[2];
	string $outerStartVtx=$geometry+".vtx["+`getAttr ($closestSampler+".result.closestVertexIndex")`+"]";
	delete $closestSampler;
	float $closestDist=999;//$closestDist is numEdges to reach
	select $sel;
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl -fl`;
	for ($i=0;$i<size($loopVtxs);$i++)
		{
//		$posB=`xform -q -ws -t $loopVtxs[$i]`;
//		float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		select $loopVtxs[$i];
		for ($y=0;$y<10;$y++)
			{
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d $loopVtxs[$i];
			$tempString=`ls -sl -fl`;
			for ($z=0;$z<size($tempString);$z++)
				{
				if ($tempString[$z]==$outerStartVtx)
					{
					if ($y<$closestDist)
						{
						$startVxt=$loopVtxs[$i];
						$closestDist=$y;
						}
					break;
					}
				}
			}
		}
	select $sel;
	select -add $startVxt;
	$startVxtSelected=1;
	$sel=`ls -sl -fl`;//Update $sel, as if the vtx was selected to start with
	}
//$startVxt(& end) spesified as a vtx selected
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*[.]vtx*"`)
		{
		if ($startVxt!="" && $endVxtSelected)
			$endVxt=$startVxt;
		if ($startVxtSelected)
			$startVxt=$sel[$i];
		}
//Ensure start&end are not swapped
if ($startVxt!="" && $endVxt!="")
	{
	$posA=`xform -q -ws -t $startVxt`;
	$posB=`xform -q -ws -t $endVxt`;
	if ($posA[0]<$posB[0])
		{
		$tempString[0]=$startVxt;
		$startVxt=$endVxt;
		$endVxt=$tempString[0];
		}
	}
string $vtxs[],$previousVtxs[];
$around=0;
if ($startVxt!="" && ($section=="EyeBrow" || $section=="Nose"  || $section=="Tongue"))
	{
	//find new $endVxt, by traversing the edge-selection
	select $startVxt;
	for ($y=0;$y<99;$y++)
		{
		ConvertSelectionToEdges;
		$tempString=`ls -sl -fl`;
		for ($z=0;$z<size($tempString);$z++)
			if (!`stringArrayCount $tempString[$z] $sel`)
				select -d $tempString[$z];
		if (size(`ls -sl -fl`)==$numSelEdges[0])
			$around=1;
		
		ConvertSelectionToVertices;
		$vtxs=`ls -sl -fl`;
		if ($around)
			{
			select $vtxs;
			select -d $previousVtxs;
			$tempString=`ls -sl -fl`;
			$endVxt=$tempString[0];
			break;
			}
		$previousVtxs=$vtxs;
		}
	}

select $startVxt;
ConvertSelectionToEdges;
$tempString=`ls -sl -fl`;
for ($y=0;$y<size($tempString);$y++)
	{
	if (!`stringArrayCount $tempString[$y] $sel`)
		select -d $tempString[$y];
	}
$tempString=`ls -sl -fl`;
string $edge1=$tempString[0];
string $edge2=$tempString[1];

//start leftwards
if ($edge2!="")
	{
	$posA=`xform -q -ws -t $edge1`;
	$posB=`xform -q -ws -t $edge2`;
	if (($posA[0]+$posA[3]) > ($posB[0]+$posB[3]))
		{
		$tempString[0]=$edge1;
		$edge1=$edge2;
		$edge2=$tempString[0];
		}
	}

string $prevVtxs[],$vtxs1[],$vtxs2[];

//get $edges1[]
$curveCmd="curve -n faceLoopCurve1 -d 1 ";
$pos=`xform -q -ws -t $startVxt`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
select $startVxt;
$prevVtxs[0]=$startVxt;
$vtxs1[size($vtxs1)]=$startVxt;
string $coveredEdges[];

$around=0;
for ($i=0;$i<199;$i++)
	{
	ConvertSelectionToEdges;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge2)
			select -d $tempString[$y];
		}
	$tempString=`ls -sl -fl`;
	$coveredEdges[size($coveredEdges)]=$tempString[0];
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	if ($endVxt=="")
		{
		if  (size($coveredEdges)==size($sel))
			$around=1;
		}
	else
		{
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $endVxt $tempString`)
				$around=1;
		}
	select -d $prevVtxs;
	$prevVtxs=$tempString;
	$tempString2=`ls -sl -fl`;
	if ($tempString2[0]=="")
		break;
	$vtxs1[size($vtxs1)]=$tempString2[0];
	$pos=`xform -q -ws -t $tempString2[0]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	select $tempString;
	if ($around)
		{
		if ($endVxt=="")
			$endVxt=$tempString2[0];
		break;
		}
	}

ConvertSelectionToContainedEdges;
string $edges1[]=`ls -sl -fl`;
eval $curveCmd;

if ($upAndLo)
	{
	//get $edges2[]
	$curveCmd="curve -n faceLoopCurve2 -d 1 ";
	$around=0;
	select $startVxt;
	$pos=`xform -q -ws -t $startVxt`;
	if ($section!="Lip")
		{
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$prevVtxs[0]=$startVxt;
		$vtxs2[size($vtxs2)]=$startVxt;
		}
	for ($i=0;$i<199;$i++)
		{
		ConvertSelectionToEdges;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge1)
				select -d $tempString[$y];
			}
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $endVxt $tempString`)
				$around=1;
		select -d $prevVtxs;
		$prevVtxs=$tempString;
		$tempString2=`ls -sl -fl`;
		if (!`size($tempString2)`)
			error "Not a complete edgeloop";
		$pos=`xform -q -ws -t $tempString2[0]`;
		if ($pos[0]<0.001)
			$vtxs2[size($vtxs2)]=$tempString2[0];
		if ($section=="Lip" && $pos[0]>0.001) //only rightSide for Lip-curve
			;
		else
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		select $tempString;
		if ($around)
			break;
		}

	ConvertSelectionToContainedEdges;
	eval $curveCmd;

	$tempString=`listRelatives -s faceLoopCurve1`;
	rename $tempString[0] faceLoopCurve1Shape;
	$tempString=`listRelatives -s faceLoopCurve2`;
	rename $tempString[0] faceLoopCurve2Shape;

	int $OneIsUpper;
	select $edges1;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $maxYVtx $tempString`)
			$OneIsUpper=1;

	//Special case detection of $OneIsUpper, on LipMain, as LowerVtx can be higher than UpperVtx
	if ($section=="Lip" && $part=="Main" && `objExists upperLipOuterCurve`)
		{
		$tempString[0]=`asGetFaceFitSelection upperLipOuterCurve`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		string $upperOuterLipVtxZero=$tempString[0];
		select $upperOuterLipVtxZero;
		for ($y=0;$y<10;$y++)
			{
			GrowPolygonSelectionRegion;
			$tempString=`ls -sl -fl`;
			if (`stringArrayCount $vtxs1[0] $tempString`)
				{
				$OneIsUpper=1;
				break;
				}
			if (`stringArrayCount $vtxs2[0] $tempString`)
				{
				$OneIsUpper=0;
				break;
				}
			}
		}

	string $upperVtxs[],$lowerVtxs[];
	if ($OneIsUpper)
		{
		$upperVtxs=$vtxs1;
		$lowerVtxs=$vtxs2;
		rename faceLoopCurve1 ("upper"+$section+$part+"Curve");
		rename faceLoopCurve2 ("lower"+$section+$part+"Curve");
		}
	else
		{
		$upperVtxs=$vtxs2;
		$lowerVtxs=$vtxs1;
		rename faceLoopCurve1 ("lower"+$section+$part+"Curve");
		rename faceLoopCurve2 ("upper"+$section+$part+"Curve");
		}
/*
	addAttr -ln upperSelection -dt "string" ("FaceFit"+$section+$part);
	addAttr -ln lowerSelection -dt "string" ("FaceFit"+$section+$part);
	$tempString[0]="";
	for ($i=0;$i<size($upperVtxs);$i++)
		$tempString[0]=$tempString[0]+$upperVtxs[$i]+" ";
	setAttr -type "string" ("FaceFit"+$section+$part+".upperSelection") $tempString[0];
	$tempString[0]="";
	for ($i=0;$i<size($lowerVtxs);$i++)
		$tempString[0]=$tempString[0]+$lowerVtxs[$i]+" ";
	setAttr -type "string" ("FaceFit"+$section+$part+".lowerSelection") $tempString[0];
*/
	}
if (!$upAndLo)
	{
	$tempString=`listRelatives -s faceLoopCurve1`;
	rename $tempString[0] faceLoopCurve1Shape;
	rename faceLoopCurve1 ($section+$part+"Curve");
	}


for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if (!$upAndLo) $upperLower="";
	if (!$upAndLo && $upperLowerFactor==-1) continue;

	parent ($upperLower+$section+$part+"Curve") ("FaceFit"+$section+$part+"Curve");
	makeIdentity -a 1 -t 1 -r 1 -s 1 ("FaceFit"+$section+$part);
//	setAttr ($upperLower+$section+$part+"CurveShape.dispCV") 1;
	setAttr ($upperLower+$section+$part+"CurveShape.overrideEnabled") 1;
	setAttr ($upperLower+$section+$part+"CurveShape.overrideColor") 17;//Yellow

	//Colors
	if ($part=="Main")
		setAttr ($upperLower+$section+$part+"CurveShape.overrideColor") 13;//Red
	if ($part=="Outer")
		setAttr ($upperLower+$section+$part+"CurveShape.overrideColor") 14;//Green
	if ($part=="Inner")
		setAttr ($upperLower+$section+$part+"CurveShape.overrideColor") 15;//Blue

	}


if ($mainAndOuter==0) $part="";
else $parts={"Main","Outer"};
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if ($upAndLo==0) $upperLower="";
	if ($upAndLo==0 && $upperLowerFactor==-1)
		continue;
	if ($isSphere)
		continue;

	if ($upperLower=="upper" || !$upAndLo)
		{
		$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r ($scale/400.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
		rename $tempString[0] ($section+"Profile"+$part);
		parent ($section+"Profile"+$part) ("FaceFit"+$section+$part+"Curve");
		connectAttr -f ("FaceFit"+$section+$part+".radius") ($section+"Profile"+$part+".sx");
		connectAttr -f ("FaceFit"+$section+$part+".radius") ($section+"Profile"+$part+".sy");
		connectAttr -f ("FaceFit"+$section+$part+".radius") ($section+"Profile"+$part+".sz");
		}
	extrude -n ($upperLower+$section+"Cylinder"+$part) -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 0 ($section+"Profile"+$part) ($upperLower+$section+$part+"Curve");
	setAttr ($upperLower+$section+"Cylinder"+$part+".overrideEnabled") 1;
	setAttr ($upperLower+$section+"Cylinder"+$part+".overrideDisplayType") 2;

	setAttr ($upperLower+$section+"Cylinder"+$part+"Shape.curvePrecisionShaded") 4;
	parent ($upperLower+$section+"Cylinder"+$part) ("FaceFit"+$section+$part+"Geo");

	//Colors
	if ($part=="Main")
		{
		sets -e -forceElement "asRedSG" ($upperLower+$section+"Cylinder"+$part);
		if ($upperLower=="lower")
			sets -e -forceElement "asRed2SG" ($upperLower+$section+"Cylinder"+$part);
		}

	if ($part=="Outer")
		{
		sets -e -forceElement "asGreenSG" ($upperLower+$section+"Cylinder"+$part);
		if ($upperLower=="lower")
			sets -e -forceElement "asGreen2SG" ($upperLower+$section+"Cylinder"+$part);
		}

	if ($part=="Inner")
		{
		sets -e -forceElement "asBlueSG" ($upperLower+$section+"Cylinder"+$part);
		if ($upperLower=="lower")
			sets -e -forceElement "asBlue2SG" ($upperLower+$section+"Cylinder"+$part);
		}

	if ($section=="Tongue")
		sets -e -forceElement "asRedSG" TongueCylinder;
	}

select ("FaceFit"+$section+$part);
print ("// FaceFit"+$section+$part+" created.\n");
}

global proc asFaceDeselectLowestHalfOfVtx ()
{
$tempString=`ls -sl -fl`;
float $tys[];
float $tysAverage;
for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	$tys[$y]=$pos[1];
	$tysAverage+=$tys[$y];
	}
$tysAverage=$tysAverage/size($tempString);
select -cl;
for ($y=0;$y<size($tempString);$y++)
	if ($tys[$y]>$tysAverage)
		select -add $tempString[$y];
}

global proc int asFaceRemoveBodyJaw ()
{
int $return=0;
string $dialog=`confirmDialog -t "Confirm"
	-m "This will replace the Jaw from the Body-setup"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog=="OK")
	$return=1;

string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
	if (`objExists Jaw_M`) asRemoveInfluence Jaw_M $skinClusters[$i];

if (`objExists FKOffsetJaw_M`) delete FKOffsetJaw_M;
if (`objExists Jaw_M`) delete Jaw_M;
if (`objExists Jaw`) delete Jaw;

asRemoveUnusedfromBuildPose bodySetup;
return $return;
}

global proc int asCanBuild (string $section)
{
int $canBuild=0;
if ($section=="EyeBall")
	if (`objExists FitEyeBall`)
		$canBuild=1;
if ($section=="EyeLid")
	if (`objExists FaceFitEyeLidMain` && `objExists FitEyeBall`)
		$canBuild=1;
if ($section=="EyeBrow")
	if (`objExists FaceFitEyeBrowMain` && `objExists FaceFitEyeLidMain` && `objExists FitEyeBall`)
		$canBuild=1;
if ($section=="Jaw")
	if (`objExists JawPivot` && `objExists FaceFitEyeLidMain` && `objExists FitEyeBall`
	 && `objExists FitEyeBall` && `objExists FaceFitLipMain` && `objExists  NoseUnder`
	 && `objExists noseCorner` && `objExists cheek`)
		$canBuild=1;
if ($section=="Cheek")
	if (`objExists FaceFitLipMain` && `objExists noseCorner` && `objExists cheek`)
		$canBuild=1;
if ($section=="Lip")
	if (`objExists FaceFitLipMain`)
		$canBuild=1;
if ($section=="Tongue")
	if (`objExists FaceFitTongue`)
		$canBuild=1;
return $canBuild;
}

global proc asDeleteAdvancedFace ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $tempString[],$faceSCs[];
if (!`objExists FaceMotionSystem`)
	return;

int $undoState=`undoInfo -q -state`;
undoInfo -state 0;

if (`checkBox -q -v asFaceKeepBlendShapes` && `objExists asFaceBS`)
	asKeepBlendShapes;

//Add headJoint as inf, if all bound joints will be deleted, to keep skinCluster.
int $haveKeepJoint;
$tempString=`ls -type skinCluster`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im FaceAllSet $tempString[$i]`)
		$faceSCs[size($faceSCs)]=$tempString[$i];
for ($i=0;$i<size($faceSCs);$i++)
	{
	$tempString=`listConnections ($faceSCs[$i]+".matrix")`;
	$haveKeepJoint=0;
	for ($y=0;$y<size($tempString);$y++)
		if (!`sets -im FaceAllSet $tempString[$y]`)
			$haveKeepJoint=1;
	if (!$haveKeepJoint)
		{
		skinCluster -e -ai $headJoint -lw false -wt 1 $faceSCs[$i];
		}
	}

//lockWeights all but headJoint
$tempString=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!=$headJoint)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 1;
//remove previous inf`s
//select `listRelatives -ad -type joint $headJoint`;
//$tempString=`ls -sl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im FaceAllSet $tempString[$i]`)
		{
		select $geometry $tempString[$i];
		RemoveInfluence;
		skinPercent -normalize 1 $skinCluster $geometry;
		}
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists lockInfluenceWeights $tempString[$i]`)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
delete `sets -q -nodesOnly FaceAllSet`;
if (`objExists FaceAllSet`)
	delete `sets -q -nodesOnly FaceAllSet`;

//Normalize SkinClusters
$tempString=`ls -type skinCluster`;
for ($i=0;$i<size($tempString);$i++)
	skinPercent -normalize 1 $tempString[$i] `ls -type mesh`;

//intermediateObject
/*
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	if ($allFaceGeo[$i]==$geometry)
		continue;
	$tempString=`listRelatives -s $allFaceGeo[$i]`;
	for ($y=1;$y<size($tempString);$y++)
		delete $tempString[$y];
	if (size($tempString))
		setAttr ($tempString[0]+".intermediateObject") 0;
	}
*/

if ($undoState)
	undoInfo -state 1;
asUpdateButtonEnables;
print "// Existing AdvancedFace removed.\n";
}

global proc asStepBuildComplete (int $stepBuild)
{
if ($stepBuild==0)
	return;
print ("// Face step:"+$stepBuild+" complete.\n");
rowLayout -e -bgc 0.2 0.2 0.2 ("asStepBuildRowLayout"+$stepBuild);
}

global proc asBuildAdvancedFace ()
{
global string $gMainProgressBar;
global string $gSelect;
global int $stepBuild;
setToolTo $gSelect;
//int $faceReBuild=`objExists FaceMotionSystem`;
//if ($stepBuild!=0) $faceReBuild=0;
int $modifier=`getModifiers`;
int $buildEyeBall=`asCanBuild EyeBall`;
int $buildEyeLid=`asCanBuild EyeLid`;
int $buildEyeBrow=`asCanBuild EyeBrow`;
//int $buildJaw=`asCanBuild Jaw`;
int $buildCheek=`asCanBuild Cheek`;
int $buildLip=`asCanBuild Lip`;
int $buildTongue=`asCanBuild Tongue`;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[],$tempFloat[];
string $tempString[],$allFaceGeo[],$cmds[],$deformJointsList[];
string $cmd;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`objExists FaceFitSkeleton`)
	error "Face FitSkeleton not found";
if (!`objExists $geometry`)
	error ("Face Geometry:\""+$geometry+"\" not found");
if ($stepBuild==1 || $stepBuild==0)
	{
	if (`objExists Eye_R`) error "Object called \"Eye_R\" exists, rename this to another name before building face-setup";
	if (`objExists Eye_L`) error "Object called \"Eye_L\" exists, rename this to another name before building face-setup";
	}
if (`objExists EyeBrowMainCurve`)
	if (!`objExists EyeBrowMainAnimateFitCurve`)
		error "No Fit Animation Found, Click the \"Animate Fit\" button, before building the face";
if (!`asConfirmIfNotInBuildPose`)
	return;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
currentTime 0;

//allBeforeFaceBuild
if (($stepBuild==1 || $stepBuild==0) && !`objExists allBeforeFaceBuild`)
	{
	select -ne `ls -o`;
	select -ne -d `ls -type objectSet`;
	select -ne -d `ls -type partition`;
	sets -n allBeforeFaceBuild;
	select -cl;
	}

asSetFixedWrapOptions;
asFaceEnsureAdvancedBase;

if (!`objExists faceMaskSet`) asDetermineGeometryFaces; //make faceMaskSet (if number of face-faces are less than half of all faces)
string $geometryFaces=`asGetGeometryFaces`;

if ($stepBuild==0 && $modifier%8 && !`objExists PausedForSim1` && !`objExists PausedForSim2`)
	{
	print "// CTRL key detected, this will pause at nCloth simulation steps, to allow for ncloth paramter adjustments.\n";
	undoInfo -state 0;evalDeferred ("undoInfo -state 1;");
	$stepBuild=1;asBuildAdvancedFace;
	$stepBuild=2;asBuildAdvancedFace;
	$stepBuild=3;asBuildAdvancedFace;
	$stepBuild=4;asBuildAdvancedFace;
	$stepBuild=5;asBuildAdvancedFace;
	$stepBuild=6;asBuildAdvancedFace;
	$stepBuild=7;asBuildAdvancedFace;
	$stepBuild=8;asBuildAdvancedFace;
	createNode -n PausedForSim1 transform;
	print "// Paused before NCloth sim, you may adjust Ncloth before proceeding. Click \"build AdvancedFace\" again, to continue the build.\n.";
	return;
	}

if (`objExists PausedForSim1`)
	{
	undoInfo -state 0;evalDeferred ("undoInfo -state 1;");
	delete PausedForSim1;
	$stepBuild=9;asBuildAdvancedFace;
	$stepBuild=10;asBuildAdvancedFace;
	$stepBuild=11;asBuildAdvancedFace;
	$stepBuild=12;asBuildAdvancedFace;
	$stepBuild=13;asBuildAdvancedFace;
	$stepBuild=14;asBuildAdvancedFace;
	playbackOptions -min 0 -max 190 -ast 0 -aet 190;
	select -cl;
	progressBar -e -ep $gMainProgressBar;
	createNode -n PausedForSim2 transform;
	print "// Paused before NCloth sim, you may adjust Ncloth before proceeding. Click \"build AdvancedFace\" again, to continue the build.\n.";
	return;
	}

if (`objExists PausedForSim2`)
	{
	undoInfo -state 0;
	delete PausedForSim2;
	$stepBuild=15;asBuildAdvancedFace;
	$stepBuild=16;asBuildAdvancedFace;
	$stepBuild=17;asBuildAdvancedFace;
	$stepBuild=18;asBuildAdvancedFace;
	$stepBuild=19;asBuildAdvancedFace;
	$stepBuild=20;asBuildAdvancedFace;
	$stepBuild=21;asBuildAdvancedFace;
	undoInfo -state 1;
	return;
	}

if ($stepBuild==0)
	{
	int $undoState=`undoInfo -q -state`;
	undoInfo -state 0;
	if ($undoState)
		evalDeferred ("undoInfo -state 1;");
	}

if ($stepBuild==1 || $stepBuild==0)
	{
	//faceHeadJoint
	select -cl;
	joint -n faceHeadJoint;
	parent faceHeadJoint FaceDeformationSystem;
	asAlign faceHeadJoint $headJoint 1 1 0 1;

	//Make sure defined skinCluster is correct
	$tempString=`listHistory $geometry`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			if ($tempString[$y]!=$skinCluster)
				{
				print ("// Updated SkinCluster info, used to be:\""+$skinCluster+"\", now it is:\""+$tempString[$y]+"\".\n");
				$skinCluster=$tempString[$y];
				textField -e -tx $skinCluster asFaceSkinClusterTextField;
				}

	//Disable any deltaMush
	$tempString=`listHistory $geometry`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="wbDeltaMush" || `objectType $tempString[$y]`=="deltaMush")
			setAttr ($tempString[$y]+".envelope") 0;
	
	//teethSets, for tracking on cut-out objects
	sets -em -n upperTeethSet;
	sets -em -n lowerTeethSet;
	sets -add FaceBuildingSets upperTeethSet lowerTeethSet;
	if ($upperTeeth!="") {eval ("select "+$upperTeeth);sets -add upperTeethSet;}
	if ($lowerTeeth!="") {eval ("select "+$lowerTeeth);sets -add lowerTeethSet;}

	// Unlock All SkinInfluences
	if (`objExists DeformSet`)
		{
		$deformJointsList=`sets -q "DeformSet"`;
		for ($i=0;$i<size($deformJointsList);$i++)
			if (`attributeExists lockInfluenceWeights $deformJointsList[$i]`)
				if (`getAttr ($deformJointsList[$i]+".lockInfluenceWeights")`)
					setAttr ($deformJointsList[$i]+".lockInfluenceWeights") 0;
		}

	select $geometry;
	blendShape -n asFaceBS -frontOfChain;

	//vtxsFromLipToNose
	if (!`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
		addAttr -ln "vtxsFromLipToNose" -at long -dv 3 FaceFitSkeleton;
	createNode -n closestSamplerFitSelection closestPointOnMesh;
	connectAttr -f ($geometry+".outMesh") closestSamplerFitSelection.inMesh;
	$pos=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
	setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
	int $vtxNrA=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
	$pos=`xform -q -ws -t NoseUnder`;
	setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
	int $vtxNrB=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
	delete closestSamplerFitSelection;
	$vtxsFromLipToNose=1;
	select ($geometry+".vtx["+$vtxNrA+"]");
	for ($i=0;$i<25;$i++)
		{
		GrowPolygonSelectionRegion;
		$tempString=`ls -sl -fl`;
		if (`stringArrayCount ($geometry+".vtx["+$vtxNrB+"]") $tempString`)
			break;
		if ($i>0)
			$vtxsFromLipToNose++;
		}
	select -cl;
	setAttr FaceFitSkeleton.vtxsFromLipToNose $vtxsFromLipToNose;

	setAttr -l 0 FaceFitSkeleton.v;
	setAttr -l 1 FaceFitSkeleton.v 0;

//	blendShape -n regionsBS -frontOfChain;
	asUpdateButtonEnables;
	select FaceGroup;
	asStepBuildComplete $stepBuild;
	}

if ($stepBuild==2 || $stepBuild==0)
	{
	asFaceCtrlBox;
	spaceLocator -n tempLoc;
	setAttr tempLoc.v 0;
	createNode -n tempLocFlip -p FaceMotionSystem transform;
	parent tempLoc tempLocFlip;
	select -cl;
	asStepBuildComplete $stepBuild;
	}

if ($stepBuild==3 || $stepBuild==0)
	{	
	//create faceTargets by wrapping
	createNode -n faceTargets transform;
	setAttr faceTargets.v 0;
	duplicate -n tempTarget $geometry;
	asLockAttr tempTarget 0 0 0 0;
	//sets -remove jawArea tempTarget.vtx[0:99999];
	parent tempTarget faceTargets;
	$tempString=`listRelatives -s tempTarget`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
	if ($geometryFaces!="")
		{
		duplicate -n tempTargetFullMesh tempTarget;
		select -cl;
		tokenize $geometryFaces $tempString;
		for ($i=0;$i<size($tempString);$i++)
			select -add `substitute $geometry $tempString[$i] tempTarget`;
		InvertSelection;
		delete;
		setAttr tempTargetFullMesh.v 0;
		}
	setAttr tempTarget.v 0;
	duplicate -n target_default tempTarget;
	createNode -n tempNearestPointOnCurve nearestPointOnCurve;
	select -cl;
	asStepBuildComplete $stepBuild;
	}

//EyeBall
if ($stepBuild==4 || $stepBuild==0)
	if ($buildEyeBall)
		{
		asAdvancedEyeBall;
		select -r ctrlEye_R ctrlEye_L;
		asStepBuildComplete $stepBuild;
		}


//EyeLid
if ($stepBuild==5 || $stepBuild==0)
	if ($buildEyeLid)
		{
		asAdvancedEyeLid;
		asStepBuildComplete $stepBuild;
		}

//EyeBrow detect
if ($stepBuild==6 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		asAdvancedEyeBrowPartA;
		asStepBuildComplete $stepBuild;
		}

//EyeBrow Cutout
if ($stepBuild==7 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		asAdvancedEyeBrowPartB;
		select -cl;
		asStepBuildComplete $stepBuild;
		}

//EyeBrow Ncloth Prep
if ($stepBuild==8 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		asAdvancedEyeBrowPartC;
		playbackOptions -min 0 -max 60 -ast 0 -aet 60;
		asStepBuildComplete $stepBuild;
		}

//EyeBrow Ncloth Sim
if ($stepBuild==9 || $stepBuild==0)
	if ($buildEyeBrow)
		{
		asNClothSim;
		asStepBuildComplete $stepBuild;
		}

//Detect Lip
if ($stepBuild==10 || $stepBuild==0)
	{
	asDetectLip;
	asStepBuildComplete $stepBuild;
	}

//Setup Lip
if ($stepBuild==11 || $stepBuild==0)
	{
	asFaceLipSetup;
	cheekRaiser;
	asStepBuildComplete $stepBuild;
	}

//Setup Jaw
if ($stepBuild==12 || $stepBuild==0)
	{
	asAdvancedJaw;
	asFaceBsSdk ctrlMouth_M.ty -1 FKSDK1Jaw_M.rx 15;
	asFaceBsSdk ctrlMouth_M.ty -1 FKSDK1Jaw_M.ty ($scale/-30);
	asFaceBsSdk ctrlMouth_M.ty -1 FKSDK1Jaw_M.tz ($scale/30);
	asFaceBsSdk ctrlMouth_M.ty -1 FKSDK1Jaw_M.sx 0.8;
	asFaceDesignMouthOpen;
	asWeightLips JawOpenRegion;
	asFaceUpdateJawWeightsFromCurves JawOpenRegion;
	parent -w FaceFitJawCurves;
	select -cl;
	asStepBuildComplete $stepBuild;
	}

//Up / Low Face
if ($stepBuild==13 || $stepBuild==0)
	{
	asSetupStickyLips;
	asStepBuildComplete $stepBuild;
	}

if ($stepBuild==14 || $stepBuild==0)
	{
	asSetupZipperLips;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==15 || $stepBuild==0)
	{
	asSetupChin;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==16 || $stepBuild==0)
	{
	asSetupEyeRegion;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==17 || $stepBuild==0)
	{
	asSetupSmile;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==18 || $stepBuild==0)
	{
	asSetupFrown;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==19 || $stepBuild==0)
	{
	asSetupCheekRaiser;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==20 || $stepBuild==0)
	{
	asFaceCheekAndMouthShapes;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==21 || $stepBuild==0)
	{
	asAdvancedTongue;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==22 || $stepBuild==0)
	{
	asFaceSquintByLattice;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==23 || $stepBuild==0)
	{
	asFaceConnectBlendShapes;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==24 || $stepBuild==0)
	{
	asFaceBrowSetup;
	asStepBuildComplete $stepBuild;
	}
if ($stepBuild==25 || $stepBuild==0)
	{
	asFaceFinish;
	//Re-Enable any deltaMush
	$tempString=`listHistory $geometry`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="wbDeltaMush" || `objectType $tempString[$y]`=="deltaMush")
			setAttr ($tempString[$y]+".envelope") 1;
	asStepBuildComplete $stepBuild;
	}



//Post Rebuild
if ($stepBuild==0)
	for ($cmd in $cmds)
		if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
}

global proc asFaceConnectBlendShapes ()
{
global string $gMainProgressBar;
int $modifier=`getModifiers`;
int $buildEyeBall=`asCanBuild EyeBall`;
int $buildEyeLid=`asCanBuild EyeLid`;
int $buildEyeBrow=`asCanBuild EyeBrow`;
//int $buildJaw=`asCanBuild Jaw`;
int $buildCheek=`asCanBuild Cheek`;
int $buildLip=`asCanBuild Lip`;
int $buildTongue=`asCanBuild Tongue`;
int $tempInts[];
float $scale=`asFaceGetScale`;
float $pos[];
string $upperLower,$lidJoint,$eyeJoint;
string $tempString[],$tempString2[],$deformJoints[],$lidJoints[],$lipJoints[],$insideVtxs[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;

//Finish Squint
select eye_squint_R;
DeleteHistory;
parent eye_squint_R faceTargets;
setAttr eye_squint_R.v 0;
setAttr ($geometry+".v") 1;

cycleCheck -e off;

if (`objExists PausedForSim2`)
	delete PausedForSim2;


//Keep Blendshapes
if (`checkBox -q -v asFaceKeepBlendShapes` && `objExists keepTweakedBlendShapes`)
	{
	string $shps[];
	string $keepShpsXforms[]=`listRelatives -c keepTweakedBlendShapes`;
	for ($i=0;$i<size($keepShpsXforms);$i++)
		$shps[size($shps)]=`substitute "_tweaked" $keepShpsXforms[$i] ""`;
	for ($i=0;$i<size($shps);$i++)
		if (`objExists $shps[$i]`)
			connectAttr ($shps[$i]+"_tweaked.outMesh") ($shps[$i]+".inMesh");
	}


//Special BS for $geometryFaces!="", to make targets `FullMeshes`
if ($geometryFaces!="")
	{
	createNode -n faceTargets2 transform;
	parent tempTarget tempTargetFullMesh faceTargets2;

	select `listRelatives -c faceTargets`;
	select -add tempTarget;
	$tempString=`blendShape -frontOfChain`;
	rename $tempString asFaceBSTEMP;

	select -r tempTargetFullMesh;
	select -add tempTarget;
	$tempString=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
	rename $tempString[0] tempWrap;
	setAttr tempWrap.autoWeightThreshold 0;
	setAttr tempWrap.maxDistance 0.001;
	setAttr tempWrap.exclusiveBind 1;	

	string $targets[]=`listRelatives -c faceTargets`;
	delete $targets;

	parent tempTarget tempTargetFullMesh faceTargets;
	for ($i=0;$i<size($targets);$i++)
		{
		setAttr ("asFaceBSTEMP."+$targets[$i]) 1;
		if ($i>0)
			setAttr ("asFaceBSTEMP."+$targets[($i-1)]) 0;
		duplicate -n $targets[$i] tempTargetFullMesh;
		}
	delete faceTargets2;
	}

//Mirror targets
int $doMirror;
string $leftTarget;
string $faceTargets[]=`listRelatives -c faceTargets`;
for ($i=0;$i<size($faceTargets);$i++)
	{
	$doMirror=0;
	$leftTarget="";
	if (`gmatch $faceTargets[$i] "*_R"`)
		{
		$leftTarget=`substitute "_R" $faceTargets[$i] "_L"`;
		if (!`objExists $leftTarget`)
			$doMirror=1;
		}
	if (!$doMirror)
		continue;

	duplicate -n $leftTarget target_default;
	duplicate -n ($leftTarget+"TEMP") target_default;
	createNode -n flipGroup transform;
	parent ($leftTarget+"TEMP") flipGroup;
	setAttr flipGroup.sx -1;
	select $leftTarget ($leftTarget+"TEMP");
	$tempString=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
	//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
	rename $tempString[0] tempWrap;
	setAttr tempWrap.exclusiveBind 1;
	select $faceTargets[$i] ($leftTarget+"TEMP");
	$tempString=`blendShape -n TempBS`;
	setAttr TempBS.w[0] 1;
	select $leftTarget;
	DeleteHistory;
	delete flipGroup;
	}

//asFaceBS blendShape
delete tempTarget target_default;
$faceTargets=`listRelatives -c faceTargets`;
for ($i=0;$i<size($faceTargets);$i++)
	blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` $faceTargets[$i] 1 asFaceBS;

//asFaceBsSdk
for ($a=0;$a<2;$a++)
	{
	if ($a==0)	$side="_R";
	if ($a==1)	$side="_L";

	if ($buildEyeBrow)
		{
		asFaceBsSdk ("ctrlBrow"+$side+".ty")  1 ("asFaceBS.brow_raiser"+$side) 1;
		setAttr ("asFaceBS_brow_raiser"+$side+".preInfinity") 1; // no neg weight when drive<0
	
		asFaceBsSdk ("ctrlBrow"+$side+".ty") -1 ("asFaceBS.brow_lowerer"+$side) 1;
		setAttr ("asFaceBS_brow_lowerer"+$side+".postInfinity") 0; // no neg weight when drive>0
	
		asFaceBsSdk ("ctrlBrow"+$side+".tx")  1 ("asFaceBS.brow_innerRaiser"+$side) 1;
		setAttr ("asFaceBS_brow_innerRaiser"+$side+".preInfinity") 1; // no neg weight when drive<0
	
		asFaceBsSdk ("ctrlBrow"+$side+".tx") -1 ("asFaceBS.brow_innerLowerer"+$side) 1;
		setAttr ("asFaceBS_brow_innerLowerer"+$side+".postInfinity") 0; // no neg weight when drive>0
	
		if (!`attributeExists squeeze ("ctrlBrow"+$side)`)
			addAttr -ln "squeeze"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
		asFaceBsSdk ("ctrlBrow"+$side+".squeeze") 10 ("asFaceBS.brow_squeeze"+$side) 1;
	
		if (!`attributeExists outerUpDown ("ctrlBrow"+$side)`)
			addAttr -ln "outerUpDown"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
		asFaceBsSdk ("ctrlBrow"+$side+".outerUpDown") 10 ("asFaceBS.brow_outerRaiser"+$side) 1;
		//	setAttr ("asFaceBS_brow_outerRaiser"+$side+".preInfinity") 1; // no neg weight when drive<0
		}

	if ($buildEyeBall)
		{
		if (!`attributeExists squint ("ctrlEye"+$side)`)
			addAttr -ln "squint"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
		asFaceBsSdk ("ctrlEye"+$side+".squint") 10 ("asFaceBS.eye_squint"+$side) 1;
		}

	if ($buildCheek)
		{
		asFaceBsSdk ("ctrlCheek"+$side+".ty") 1 ("asFaceBS.cheek_raiser"+$side) 1;
		setAttr ("asFaceBS_cheek_raiser"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlCheek"+$side+".tx") 1 ("asFaceBS.cheek_puff"+$side) 1;
		setAttr ("asFaceBS_cheek_puff"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlCheek"+$side+".tx") -1 ("asFaceBS.cheek_suck"+$side) 1;
		setAttr ("asFaceBS_cheek_suck"+$side+".postInfinity") 0; // no neg weight when drive>0
		}

	if ($buildCheek)
		{
		asFaceBsSdk ("ctrlNose"+$side+".ty") 1 ("asFaceBS.nose_wrinkler"+$side) 1;
		setAttr ("asFaceBS_nose_wrinkler"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlNose"+$side+".tx") 1 ("asFaceBS.nose_dilator"+$side) 1;
		setAttr ("asFaceBS_nose_dilator"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlNose"+$side+".tx") -1 ("asFaceBS.nose_compressor"+$side) 1;
		setAttr ("asFaceBS_nose_compressor"+$side+".postInfinity") 0; // no neg weight when drive>0
		}
	}

if ($buildCheek)
	{
	asFaceBsSdk ctrlMouth_M.tx 1 asFaceBS.mouth_smile_C 1;
	setAttr ("asFaceBS_mouth_smile_C.preInfinity") 1; // no neg weight when drive<0
	
	asFaceBsSdk ctrlMouth_M.tx -1 asFaceBS.mouth_narrow_C 1;
	setAttr ("asFaceBS_mouth_narrow_C.postInfinity") 0; // no neg weight when drive>0
	}

/*
if ($buildJaw)
	{
	if (!`attributeExists JAW ctrlMouth_M`)
		addAttr -k 0 -ln "JAW" -at "double" ctrlMouth_M;setAttr -l 1 -cb 1 ctrlMouth_M.JAW;
	if (!`attributeExists jawSide ctrlMouth_M`)
		addAttr -ln "jawSide"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.jawSide 10 FKSDK1Jaw_M.ry ($scale*4.0);
	asFaceBsSdk ctrlMouth_M.jawSide -10 FKSDK1Jaw_M.ry ($scale*-4.0);	
	if (!`attributeExists jawForward ctrlMouth_M`)
		addAttr -ln "jawForward"  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.jawForward 10 FKSDK1Jaw_M.tx ($scale/35.0);
	asFaceBsSdk ctrlMouth_M.jawForward -10 FKSDK1Jaw_M.tx ($scale/-35.0);
	if (!`attributeExists CHIN ctrlMouth_M`)
		addAttr -k 0 -ln "CHIN" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.CHIN;
	if (!`attributeExists chinRaiser ctrlMouth_M`)
		addAttr -ln "chinRaiser"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.chinRaiser 10 asFaceBS.chinRaiser_C 1;
	}
*/
if ($buildCheek)
	{
/*
	if (!`attributeExists LIP_PRESS ctrlMouth_M`)
		addAttr -k 0 -ln "LIP_PRESS" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.LIP_PRESS;
	if (!`attributeExists lipPress_R ctrlMouth_M`)
		addAttr -ln "lipPress_R"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	if (!`attributeExists lipPress_L ctrlMouth_M`)
		addAttr -ln "lipPress_L"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	asFaceBsSdk ctrlMouth_M.lipPress_R 10 asFaceBS.mouth_presser_R 1;
	asFaceBsSdk ctrlMouth_M.lipPress_L 10 asFaceBS.mouth_presser_L 1;

	for ($a=0;$a<2;$a++) {if ($a==0)	$side="_R";if ($a==1)	$side="_L";
		if (!`attributeExists LIP_ROLL ctrlMouth_M`)
			addAttr -k 0 -ln "LIP_ROLL" -at "double" ctrlMouth_M; setAttr -l 1 -cb 1 ctrlMouth_M.LIP_ROLL;
		if (!`attributeExists ("lipUpperRoll"+$side) ctrlMouth_M`)
			addAttr -ln ("lipUpperRoll"+$side)  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
		asFaceBsSdk ("ctrlMouth_M.lipUpperRoll"+$side) -10 ("asFaceBS.mouth_rollInUpper"+$side) 1;
		setAttr ("asFaceBS_mouth_rollInUpper"+$side+".postInfinity") 0; // no neg weight when drive>0
		asFaceBsSdk ("ctrlMouth_M.lipUpperRoll"+$side) 10 ("asFaceBS.mouth_rollOutUpper"+$side) 1;
		setAttr ("asFaceBS_mouth_rollOutUpper"+$side+".preInfinity") 1; // no neg weight when drive<0
		}
	for ($a=0;$a<2;$a++) {if ($a==0)	$side="_R";if ($a==1)	$side="_L";
		if (!`attributeExists ("lipLowerRoll"+$side) ctrlMouth_M`)
			addAttr -ln ("lipLowerRoll"+$side)  -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
		asFaceBsSdk ("ctrlMouth_M.lipLowerRoll"+$side) -10 ("asFaceBS.mouth_rollInLower"+$side) 1;
		setAttr ("asFaceBS_mouth_rollInLower"+$side+".postInfinity") 0; // no neg weight when drive>0
		asFaceBsSdk ("ctrlMouth_M.lipLowerRoll"+$side) 10 ("asFaceBS.mouth_rollOutLower"+$side) 1;
		setAttr ("asFaceBS_mouth_rollOutLower"+$side+".preInfinity") 1; // no neg weight when drive<0
		}
*/
	for ($a=0;$a<2;$a++)
		{
		if ($a==0)	$side="_R";if ($a==1)	$side="_L";
		asFaceBsSdk ("ctrlMouthCorner"+$side+".tx") 1 ("asFaceBS.mouth_wide"+$side) 1;
		setAttr ("asFaceBS_mouth_wide"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlMouthCorner"+$side+".tx") -1 ("asFaceBS.mouth_narrow"+$side) 1;
		setAttr ("asFaceBS_mouth_narrow"+$side+".postInfinity") 0; // no neg weight when drive>0
		asFaceBsSdk ("ctrlMouthCorner"+$side+".ty") 1 ("asFaceBS.mouth_smile"+$side) 1;
		setAttr ("asFaceBS_mouth_smile"+$side+".preInfinity") 1; // no neg weight when drive<0
		asFaceBsSdk ("ctrlMouthCorner"+$side+".ty") -1 ("asFaceBS.mouth_frown"+$side) 1;
		setAttr ("asFaceBS_mouth_frown"+$side+".postInfinity") 0; // no neg weight when drive>0
		}
	}
//if (`objExists faceTargets`)
//	delete faceTargets;
}


global proc asFaceBrowSetup ()
{
int $modifier=`getModifiers`;
int $buildEyeBrow=`asCanBuild EyeBrow`;
float $pos[];
string $tempString[],$tempString2[],$deformJoints[],$lidJoints[],$lipJoints[],$insideVtxs[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;

//PingPongs
if ($buildEyeBrow)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
	
		asPingPong EyeBrowMain0 browInner $b $side 6 1 1;
		asPingPong EyeBrowMain3 browHalf $b $side 10 1 1;
		asPingPong EyeBrowMain6 browOuter $b $side 6 1 1;
		}
	//Weighting PingPongs via a skinCage(foreHeadMesh)
	rebuildCurve -n EyeBrowOuterCurveReBuilt -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.000393701 EyeBrowOuterCurve;
	rebuildCurve -n EyeBrowMainCurveReBuilt -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.000393701 EyeBrowMainCurve;
	rebuildCurve -n upperEyeLidOuterCurveReBuilt -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.000393701 upperEyeLidOuterCurve;
//	loft -n foreHeadLoftNurbs -ch 0 -u 1 -c 0 -ar 0 -d 1 -ss 1 -rn 0 -po 0 -rsn true EyeBrowOuterCurve EyeBrowMainCurve upperEyeLidOuterCurve;
	loft -n foreHeadLoftNurbs -ch 0 -u 1 -c 0 -ar 0 -d 1 -ss 1 -rn 0 -po 0 -rsn true EyeBrowOuterCurveReBuilt EyeBrowMainCurveReBuilt upperEyeLidOuterCurveReBuilt;
	nurbsToPoly -n foreHeadLoft -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs;
	duplicate -n foreHeadLoft2 foreHeadLoft;
	setAttr foreHeadLoft2.sx -1;
	loft -n foreHeadLoftNurbs3 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true foreHeadLoft2.e[13] foreHeadLoft.e[13];
	nurbsToPoly -n foreHeadLoft3 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs3;
	loft -n foreHeadLoftNurbs4 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true foreHeadLoft2.e[15] foreHeadLoft.e[15];
	nurbsToPoly -n foreHeadLoft4 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs4;
	loft -n foreHeadLoftNurbs5 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true foreHeadLoft.e[17] foreHeadLoft.e[0];
	nurbsToPoly -n foreHeadLoft5 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs5;
	loft -n foreHeadLoftNurbs6 -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true foreHeadLoft2.e[17] foreHeadLoft2.e[0];
	nurbsToPoly -n foreHeadLoft6 -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 foreHeadLoftNurbs6;
	delete foreHeadLoftNurbs foreHeadLoftNurbs3 foreHeadLoftNurbs4 foreHeadLoftNurbs5 foreHeadLoftNurbs6 EyeBrowOuterCurveReBuilt EyeBrowMainCurveReBuilt upperEyeLidOuterCurveReBuilt;
	polyUnite -n foreHeadMesh -ch 0 -mergeUVSets 1 foreHeadLoft foreHeadLoft foreHeadLoft2 foreHeadLoft3 foreHeadLoft4 foreHeadLoft5 foreHeadLoft6;
	polyMergeVertex -d 0.01 -am 1 -ch 0 foreHeadMesh;
	spaceLocator -n tempGeoSnapLoc;
	spaceLocator -n tempGeoSnapLocOffset;
	parent tempGeoSnapLoc tempGeoSnapLocOffset;
	int $popOutVtxNrs[]={29,30};
	for ($a=0;$a<size($popOutVtxNrs);$a++)
		{
		$pos=`xform -q -ws -t ("foreHeadMesh.vtx["+$popOutVtxNrs[$a]+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempGeoSnapLocOffset;
		geometryConstraint $geometry tempGeoSnapLoc;
		for ($i=0;$i<10;$i++)
		  {
			setAttr tempGeoSnapLoc.tx 0;
			setAttr tempGeoSnapLoc.ty 0;
			}
		$pos=`xform -q -ws -t tempGeoSnapLoc`;
		xform -ws -t 0 $pos[1] $pos[2] ("foreHeadMesh.vtx["+$popOutVtxNrs[$a]+"]");
		}
	delete tempGeoSnapLocOffset;
	
	select foreHeadMesh $headJoint;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] foreHeadSC;
	string $browJoints[]={"browInnerJoint_R","browHalfJoint_R","browOuterJoint_R","browInnerJoint_L","browHalfJoint_L","browOuterJoint_L"};
	int $browJointVtxNrs[]={7,6,11,21,20,25};
	for ($i=0;$i<size($browJoints);$i++)
		{
		skinCluster -e -ai $browJoints[$i] -lw false -wt 0 foreHeadSC;
		skinPercent -tv $browJoints[$i] 1 foreHeadSC ("foreHeadMesh.vtx["+$browJointVtxNrs[$i]+"]");
		}
	skinPercent -tv browInnerJoint_R 0.5 -tv browHalfJoint_R 0.5 foreHeadSC foreHeadMesh.vtx[9];
	skinPercent -tv browInnerJoint_L 0.5 -tv browHalfJoint_L 0.5 foreHeadSC foreHeadMesh.vtx[23];
	skinPercent -tv browHalfJoint_R 0.5 -tv browOuterJoint_R 0.5 foreHeadSC foreHeadMesh.vtx[13];
	skinPercent -tv browHalfJoint_L 0.5 -tv browOuterJoint_L 0.5 foreHeadSC foreHeadMesh.vtx[27];
	skinPercent -tv browInnerJoint_R 0.5 -tv browInnerJoint_L 0.5 foreHeadSC foreHeadMesh.vtx[29];

	//select geoVtxs that are within BoundingBox of foreHeadMesh
	float $bbs[]=`xform -q -bb foreHeadMesh`;
	select $geometry;
	polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbs[4]-$bbs[1])/2.0) -dp 0 (($bbs[4]+$bbs[1])/2.0) 0 -da 0 1 0;
	string $selinBBY[]=`ls -sl`;
	polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbs[3]-$bbs[0])/2.0) -dp 0 (($bbs[3]+$bbs[0])/2.0) 0 -da 1 0 0;
	string $selinBBX[]=`ls -sl`;
	polySelectConstraint -m 0;
	select $selinBBX;InvertSelection;
	string $selinBBXInvert[]=`ls -sl`;
	select $selinBBY;select -d $selinBBXInvert;
	select -d `sets -q eyeLidVtxs`;
	string $selinBB[]=`ls -sl`;

	select -r foreHeadMesh.vtx[0:28];
	select -add $selinBB;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
//	delete foreHeadMesh;
	setAttr foreHeadMesh.v 0;
	}

select -r $geometry;
doPruneSkinClusterWeightsArgList 1 { "0.001" };
copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
}

global proc asFaceLipSetup ()
{
global string $gSelect;
global string $artSelectObject;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
int $outerNumCv,$ctrlNr,$color;
int $vtxsFromLipToNose=3;
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
int $innerVtxNr[],$outerVtxNr[],$mainVtxNr[];
float $scale=`asFaceGetScale`;
float $dist;
float $pos[],$posA[],$posB[],$posC[];
string $startVtx,$endVtx,$inOutMain,$side;
string $tempString[],$tempString2[],$completedVtxs[],$endingVtxs[],$allLoopVtxs[],$aboveLipWeightedVtxs[],$belowLipWeightedVtxs[];

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
if (`objExists tempTargetFullMesh`)
	duplicate -n LipRegion tempTargetFullMesh;
else
	duplicate -n LipRegion tempTarget;
setAttr LipRegion.v 1;
parent LipRegion RegionDeformations;
sets -e -forceElement initialShadingGroup LipRegion;
duplicate -n LipRotateRegion LipRegion;
duplicate -n LipScaleRegion LipRegion;
string $lipArea[]=`asobjSetCast lipArea {} LipRegion`;
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr LipRegion.outMesh closestSampler.inMesh;
createNode -n closestNurbsSampler closestPointOnSurface;
createNode -n LipConstruction transform;
createNode -n LipSetup transform;
parent LipSetup FaceMotionSystem;

select -cl;
joint -n LipJoints_M;
select lipArea;
$pos=`xform -q -bb`;
xform -ws -t (($pos[0]+$pos[3])/2.0) (($pos[1]+$pos[4])/2.0) (($pos[2]+$pos[5])/2.0) LipJoints_M;
parent LipJoints_M LipSetup;
duplicate -n LipsRotateJoints_M LipJoints_M;
duplicate -n LipsScaleJoints_M LipJoints_M;

blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` LipRegion 1 asFaceBS;
setAttr asFaceBS.LipRegion 1;
blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` LipRotateRegion 1 asFaceBS;
setAttr asFaceBS.LipRotateRegion 1;
blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` LipScaleRegion 1 asFaceBS;
setAttr asFaceBS.LipScaleRegion 1;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	//Create BuildCurves (based on ordered selection)
	for ($a=0;$a<3;$a++)
		{
		if ($a==0) $inOutMain="Inner";if ($a==1) $inOutMain="Outer";if ($a==2) $inOutMain="Main";

		$curveCmd="curve -d 1 ";
//		eval ("select "+`getAttr ("FaceFitLip"+$inOutMain+"."+$upperLower+"Selection")`);
		eval ("select "+`asGetFaceFitSelection ($upperLower+"Lip"+$inOutMain+"Curve")`);

		string $loopVtxs[]=`ls -sl -fl`;
		clear $completedVtxs;
//		$tempString[0]=`getAttr ("FaceFitLip"+$inOutMain+"."+$upperLower+"Selection")`;
		$tempString[0]=`asGetFaceFitSelection ($upperLower+"Lip"+$inOutMain+"Curve")`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		select $tempString[0];
		for ($i=0;$i<size($loopVtxs);$i++)
			{
			$tempString=`ls -sl -fl`;
			$completedVtxs=`stringArrayCatenate $completedVtxs $tempString`;
			$pos=`xform -q -ws -t`;
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			$tempString=`ls -sl -fl`;
			for ($y=0;$y<size($tempString);$y++)
				if (!`stringArrayCount $tempString[$y] $loopVtxs`)
					select -d $tempString[$y];
			select -d $completedVtxs;
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"Lip"+$inOutMain+"BuildCurve");
		parent ($upperLower+"Lip"+$inOutMain+"BuildCurve") LipConstruction;
		}
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	//Create Joints & CenterCurve
	$curveCmd="curve -d 1 ";
	for ($i=0;$i<$outerNumCv;$i++)
		{
		select LipJoints_M;
		joint -n ($upperLower+"LipJoint"+$i);
		$posA=`xform -q -ws -t ($upperLower+"LipOuterBuildCurve.cv["+$i+"]")`;
		$posB=`xform -q -ws -t ($upperLower+"LipInnerBuildCurve.cv["+$i+"]")`;
		$posC=`xform -q -ws -t ($upperLower+ "LipMainBuildCurve.cv["+$i+"]")`;
		$pos={(($posA[0]+$posB[0]+$posC[0])/3.0),(($posA[1]+$posB[1]+$posC[1])/3.0),(($posA[2]+$posB[2]+$posC[2])/3.0)};
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipJoint"+$i);
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		}
	$tempString[0]=`eval ($curveCmd)`;
	rename $tempString[0] ($upperLower+"LipCenterBuildCurve");
	parent ($upperLower+"LipCenterBuildCurve") LipConstruction;
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	//Mirror joints 
	for ($i=0;$i<$outerNumCv;$i++)
		{
		if ($i==0) $side="_M";
		else $side="_R";
	
		rename ($upperLower+"LipJoint"+$i) ($upperLower+"LipJoint"+$i+$side);
		if ($side=="_R")
			{
			duplicate -n ($upperLower+"LipJoint"+$i+"_L") ($upperLower+"LipJoint"+$i+"_R");
			$pos=`xform -q -ws -t ($upperLower+"LipJoint"+$i+"_L")`;
			xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] ($upperLower+"LipJoint"+$i+"_L");
//			skinCluster -e -lw false -wt 0 -ai ($upperLower+"LipJoint"+$i+"_L") LipSC;
			}
		}
	}

createNode -n LipFollicles transform;
parent LipFollicles LipJoints_M;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	//Ribbon
	duplicate -n ($upperLower+"LipCenterBuildCurve_L") ($upperLower+"LipCenterBuildCurve");
	setAttr ($upperLower+"LipCenterBuildCurve_L.sx") -1;
	attachCurve -ch 0 -n ($upperLower+"LipCenterBuildCurve_M") -rpo 0 -kmk 1 -m 1 -bb 0.5 -bki 0 -p 0.1 ($upperLower+"LipCenterBuildCurve_L") ($upperLower+"LipCenterBuildCurve");
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.000393701 ($upperLower+"LipCenterBuildCurve_M");
	offsetCurve -ch 1 -n ($upperLower+"LipCenterBuildCurveA_M") -rn false -cb 2 -st true -cl true -cr 0 -d ($scale/38.0)  -tol 1 -sd 5 -ugn false ($upperLower+"LipCenterBuildCurve_M");
	offsetCurve -ch 1 -n ($upperLower+"LipCenterBuildCurveB_M") -rn false -cb 2 -st true -cl true -cr 0 -d ($scale/-38.0) -tol 1 -sd 5 -ugn false ($upperLower+"LipCenterBuildCurve_M");
	loft -ch 0 -n ($upperLower+"LipCenterPlane") -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true ($upperLower+"LipCenterBuildCurveA_M") ($upperLower+"LipCenterBuildCurveB_M");
	parent ($upperLower+"LipCenterPlane") LipSetup;
	connectAttr -f ($upperLower+"LipCenterPlaneShape.worldSpace[0]") closestNurbsSampler.inputSurface;
	parent ($upperLower+"LipCenterBuildCurve_M") ($upperLower+"LipCenterBuildCurveA_M") ($upperLower+"LipCenterBuildCurveB_M") LipConstruction;

	for ($b=1;$b>-2;$b=$b-2)
		{
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;

			$tempString[0]=`createNode follicle`;
			$tempString=`listRelatives -p $tempString[0]`;
			rename $tempString[0] ($upperLower+"follicle"+$i+$side);
			parent ($upperLower+"follicle"+$i+$side) LipFollicles;
			setAttr ($upperLower+"follicle"+$i+$side+".collide") 0;
			connectAttr ($upperLower+"LipCenterPlane.local") ($upperLower+"follicle"+$i+$side+".inputSurface");
			connectAttr ($upperLower+"LipCenterPlane.worldMatrix[0]") ($upperLower+"follicle"+$i+$side+".inputWorldMatrix");
			connectAttr -f ($upperLower+"follicle"+$i+$side+".outTranslate") ($upperLower+"follicle"+$i+$side+".t");
			connectAttr -f ($upperLower+"follicle"+$i+$side+".outRotate") ($upperLower+"follicle"+$i+$side+".r");

			$pos=`xform -q -ws -t ($upperLower+"LipJoint"+$i+$side)`;
			setAttr -type float3 closestNurbsSampler.inPosition $pos[0] $pos[1] $pos[2];
			setAttr ($upperLower+"follicle"+$i+$side+".parameterU") `getAttr closestNurbsSampler.parameterU`;
			setAttr ($upperLower+"follicle"+$i+$side+".parameterV") `getAttr closestNurbsSampler.parameterV`;
//			parent ($upperLower+"LipJoint"+$i+$side) ($upperLower+"follicle"+$i+$side);
			pointConstraint ($upperLower+"follicle"+$i+$side) ($upperLower+"LipJoint"+$i+$side);
			orientConstraint ($upperLower+"follicle"+$i+$side) ($upperLower+"LipJoint"+$i+$side);
			delete `orientConstraint ($upperLower+"follicle"+$i+$side) ($upperLower+"LipJoint"+$i+$side)`;
			makeIdentity -a 1 -t 0 -r 1 -s 0 ($upperLower+"LipJoint"+$i+$side);
			duplicate -n ($upperLower+"LipRotateJoint"+$i+$side) ($upperLower+"LipJoint"+$i+$side);
			delete `listRelatives -c -f ($upperLower+"LipRotateJoint"+$i+$side)`;
			parent ($upperLower+"LipRotateJoint"+$i+$side) LipsRotateJoints_M;
//			orientConstraint ($upperLower+"follicle"+$i+$side) ($upperLower+"LipRotateJoint"+$i+$side);
//			setAttr -type float3 ($upperLower+"LipJoint"+$i+$side+".jointOrient") 0 0 0;
			duplicate -n ($upperLower+"LipScaleJoint"+$i+$side) ($upperLower+"LipRotateJoint"+$i+$side);
			parent ($upperLower+"LipScaleJoint"+$i+$side) LipsScaleJoints_M;
			}
		}
	}

//Bind
select `listRelatives -ad -type joint LipJoints_M`;
select -add LipJoints_M LipRegion;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] LipSC;
skinPercent -tv LipJoints_M 1 LipSC LipRegion;

//Bind-rotate
select `listRelatives -ad -type joint LipsRotateJoints_M`;
select -add LipsRotateJoints_M LipRotateRegion;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] LipRotateSC;
skinPercent -tv LipsRotateJoints_M 1 LipRotateSC LipRotateRegion;

//Bind-scale
select `listRelatives -ad -type joint LipsScaleJoints_M`;
select -add LipsScaleJoints_M LipScaleRegion;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] LipScaleSC;
skinPercent -tv LipsScaleJoints_M 1 LipScaleSC LipScaleRegion;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	for ($b=1;$b>-2;$b=$b-2)
		{
		//Hard weights
		for ($a=0;$a<3;$a++)
			{
			if ($a==0) $inOutMain="Inner";if ($a==1) $inOutMain="Outer";if ($a==2) $inOutMain="Main";
	
			for ($i=0;$i<$outerNumCv;$i++)
				{
				if ($b==1) $side="_R";
				else $side="_L";
				if ($i==0) $side="_M";
				if ($i==0 && $b==-1) continue;

				$pos=`xform -q -ws -t ($upperLower+"Lip"+$inOutMain+"BuildCurve.cv["+$i+"]")`;
				setAttr -type float3 closestSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
				select ("LipRegion.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
				skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 LipSC `ls -sl`;
	
				if ($inOutMain=="Inner") $innerVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				if ($inOutMain=="Outer") $outerVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				if ($inOutMain=="Main") $mainVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				}
			}
	
		//shortestEdgePath vtxs
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;

			polySelect -shortestEdgePath $outerVtxNr[$i] $mainVtxNr[$i];//outer -> main
			ConvertSelectionToVertices;
			skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 LipSC `ls -sl`;
			polySelect -shortestEdgePath $innerVtxNr[$i] $mainVtxNr[$i];//inner -> main
			ConvertSelectionToVertices;
			skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 LipSC `ls -sl`;
			}
		}
	}
//hammer any leftovers
select -cl;
for ($i=0;$i<size($lipArea);$i++)
	{
	if (`skinPercent -transform LipJoints_M -ignoreBelow 1 -query -value LipSC $lipArea[$i]`)
		select -add $lipArea[$i];
	}
if (size(`ls -sl`))
	weightHammerVerts;

copySkinWeights -ss LipSC -ds LipSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//rotate joints weights
select LipRegion LipRotateRegion;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
eval ("select "+`asGetFaceFitSelection upperLipOuterCurve`);
$tempString=`ls -sl -fl`;
eval ("select -add "+`asGetFaceFitSelection lowerLipOuterCurve`);
select -add $tempString;
$tempString=`ls -sl -fl`;
select `asobjSetCast "" $tempString LipRotateRegion`;
for ($i=0;$i<$vtxsFromLipToNose;$i++)
	GrowPolygonSelectionRegion;
select -d `asobjSetCast lipArea {} LipRotateRegion`;
asSmoothFlood LipsRotateJoints_M "" 100;
//Move `up` RotateJoints, for improved pivot behaviour
$posA=`xform -q -ws -t upperLipOuterBuildCurve.cv[0]`;
$posB=`xform -q -ws -t upperLipRotateJoint0_M`;
float $offset=($posA[1]-$posB[1])*2;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;
	for ($b=1;$b>-2;$b=$b-2)
		{
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;
			move -r 0 ($offset*$upperLowerFactor) 0 ($upperLower+"LipRotateJoint"+$i+$side);
			}
		}
	}

freezeSkinCluster LipRotateSC;
dgdirty -a;
copySkinWeights -ss LipRotateSC -ds LipRotateSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//create clusters & pingPongs
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	for ($i=0;$i<7;$i++)
		{
		if ($i<3) $side="_L";
		if ($i==3) $side="_M";
		if ($i>3) $side="_R";
		int $clusterNr=abs(3-$i);
		if ($i==0) {$ctrlNr=6;$color=7;}
		if ($i==2) {$ctrlNr=3;$color=10;}
		if ($i==3) {$ctrlNr=0;$color=7;}
		if ($i==4) {$ctrlNr=3;$color=10;}
		if ($i==6) {$ctrlNr=6;$color=7;}

		$posA=`xform -q -ws -t ($upperLower+"LipCenterPlane.cv["+$i+"][0]")`;
		$posB=`xform -q -ws -t ($upperLower+"LipCenterPlane.cv["+$i+"][3]")`;
		$pos={(($posA[0]+$posB[0])/2.0),(($posA[1]+$posB[1])/2.0),(($posA[2]+$posB[2])/2.0)};
		if (`objExists TempPos`) delete TempPos;
		createNode -n TempPos transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;

		select -r ($upperLower+"LipCenterPlane.cv["+$i+"][0:3]");
		$tempString=`newCluster " -envelope 1"`;
		rename $tempString[0] ($upperLower+"Lip"+$clusterNr+"Cluster"+$side);
		rename $tempString[1] ($upperLower+"Lip"+$clusterNr+"ClusterHandle"+$side);
		parent ($upperLower+"Lip"+$clusterNr+"ClusterHandle"+$side) LipSetup;

		if ($i==1 || $i==5)
			continue;
		if (($i==0 || $i==6) && $upperLower=="lower")
			continue;
		string $ctrl=$upperLower+"Lip"+$ctrlNr;
		if ($i==0 || $i==6) $ctrl="Lip"+$ctrlNr;
		//avoid PingPong stuck to wrong upper/lower lip
		if ($upperLower=="upper")
			setAttr lowerLipCenterPlane.ty ($scale*-5);
		if ($upperLower=="lower")
			setAttr upperLipCenterPlane.ty ($scale*5);
		asPingPong TempPos $ctrl 1 $side $color 1 0;
		setAttr upperLipCenterPlane.ty 0;
		setAttr lowerLipCenterPlane.ty 0;
		delete ($ctrl+"JointOffset"+$side);
		delete TempPos;
		setAttr ($ctrl+$side+".rotateOrder") 1;
		if ($clusterNr!=3)
			{
			connectAttr ($ctrl+$side+".t") ($upperLower+"Lip"+$clusterNr+"ClusterHandle"+$side+".t");
			connectAttr ($ctrl+$side+".r") ($upperLower+"Lip"+$clusterNr+"ClusterHandle"+$side+".r");
			}
		if ($i==2 || $i==4)
			scale -r -p $pos[0] $pos[1] $pos[2] 0.5 0.5 0.5 ($ctrl+$side+".cv[0:6][0:7]");
		move -r 0 0 ($scale/38.0) ($ctrl+$side+".cv[0:6][0:7]");
		}
	}
if (`objExists TempPos`) delete TempPos;

//Scale
createNode -n upperScaleLip0_M -p LipSetup transform;connectAttr upperLip0_M.s upperScaleLip0_M.s;
createNode -n lowerScaleLip0_M -p LipSetup transform;connectAttr lowerLip0_M.s lowerScaleLip0_M.s;
createNode -n ScaleLip6_R -p LipSetup transform;connectAttr Lip6_R.s ScaleLip6_R.s;
createNode -n ScaleLip6_L -p LipSetup transform;connectAttr Lip6_L.s ScaleLip6_L.s;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;
	for ($b=1;$b>-2;$b=$b-2)
		{
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;
			scaleConstraint ($upperLower+"ScaleLip0_M") ScaleLip6_R ScaleLip6_L ($upperLower+"LipScaleJoint"+$i+$side);
			float $middleWeight=1-((1/($outerNumCv-1.0))*$i);
			float $rightWeight=(1/($outerNumCv-1.0))*$i;
			$middleWeight=`smoothstep 0 1 $middleWeight`;
			$rightWeight=`smoothstep 0 1 $rightWeight`;
			float $leftWeight=$rightWeight;
			if ($side=="_R") $leftWeight=0;
			if ($side=="_L") $rightWeight=0;
//			connectAttr ($upperLower+"Lip0_M.s") ($upperLower+"LipScaleJoint"+$i+$side+".s");
			setAttr ($upperLower+"LipScaleJoint"+$i+$side+"_scaleConstraint1."+$upperLower+"ScaleLip0_MW0") $middleWeight;
			setAttr ($upperLower+"LipScaleJoint"+$i+$side+"_scaleConstraint1."+"ScaleLip6_RW1") $rightWeight;
			setAttr ($upperLower+"LipScaleJoint"+$i+$side+"_scaleConstraint1."+"ScaleLip6_LW2") $leftWeight;
			}
		}
	}

//LipCornerGrp
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";else $side="_L";
	createNode -n ("LipCornerGrpT"+$side) -p LipSetup transform;
	createNode -n ("LipCornerGrpR"+$side) -p ("LipCornerGrpT"+$side) transform;
	delete `pointConstraint ("upperLip3ClusterHandle"+$side) ("LipCornerGrpR"+$side)`;
	connectAttr ("Lip6"+$side+".t") ("LipCornerGrpT"+$side+".t");
	connectAttr ("Lip6"+$side+".r") ("LipCornerGrpR"+$side+".r");
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";else $upperLower="lower";
		createNode -n ($upperLower+"LipCornerGrp"+$side) -p ("LipCornerGrpR"+$side) transform;
		parent ($upperLower+"Lip2ClusterHandle"+$side) ($upperLower+"Lip3ClusterHandle"+$side) ($upperLower+"LipCornerGrp"+$side);

		createNode -n TempPos transform;
		delete `pointConstraint Lip6_R TempPos`;
		move -r 0 ($scale*0.02*$upperLowerFactor) ($scale/25.0) TempPos;
		asPingPong TempPos ($upperLower+"Lip5") $b $side 10 0 0;
		delete TempPos;
		$pos=`xform -q -ws -t ($upperLower+"Lip5"+$side)`;
		scale -r -p $pos[0] $pos[1] $pos[2] 0.3 0.3 0.3 ($upperLower+"Lip5"+$side+".cv[0:6][0:7]");
		connectAttr ($upperLower+"Lip5"+$side+".t") ($upperLower+"LipCornerGrp"+$side+".t");
		connectAttr ($upperLower+"Lip5"+$side+".r") ($upperLower+"LipCornerGrp"+$side+".r");
		}
	}
/*
//Corner special case
connectAttr Lip6_R.t lowerLip3ClusterHandle_R.t;
connectAttr Lip6_R.r lowerLip3ClusterHandle_R.r;
connectAttr Lip6_L.t lowerLip3ClusterHandle_L.t;
connectAttr Lip6_L.r lowerLip3ClusterHandle_L.r;


//These will later be rotateable
connectAttr Lip6_R.t upperLip2ClusterHandle_R.t;
connectAttr Lip6_R.t lowerLip2ClusterHandle_R.t;
connectAttr Lip6_L.t upperLip2ClusterHandle_L.t;
connectAttr Lip6_L.t lowerLip2ClusterHandle_L.t;
*/

//lip4 to partially follow 3 & 6  (2 follow 3 & 0 on Left)
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";
		createNode -n ($upperLower+"1Inbetween"+$side) -p LipSetup transform;
		$pos=`xform -q -ws -piv ($upperLower+"Lip3"+$side)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"1Inbetween"+$side);
		parentConstraint -mo ($upperLower+"Lip0ClusterHandle_M") ($upperLower+"Lip3ClusterHandle"+$side) ($upperLower+"1Inbetween"+$side);
		createNode -n ($upperLower+"1InbetweenOffset"+$side) transform;
		parent ($upperLower+"1InbetweenOffset"+$side) ($upperLower+"1Inbetween"+$side);
		parent ($upperLower+"Lip"+"1ClusterHandle"+$side) ($upperLower+"1InbetweenOffset"+$side);
		}
	}

//LipRotateJoint
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;
	addAttr -k 1 -ln ($upperLower+"Roll") -at double -dv 0 ctrlMouth_M;
	createNode -n ($upperLower+"RollPlus") plusMinusAverage;
	//Roll attribute driver
	createNode -n ($upperLower+"RollAUnitConversion") unitConversion;
	connectAttr ("ctrlMouth_M."+$upperLower+"Roll") ($upperLower+"RollAUnitConversion.input");
	setAttr ($upperLower+"RollAUnitConversion.conversionFactor") (0.1*$upperLowerFactor);
	connectAttr ($upperLower+"RollAUnitConversion.output") ($upperLower+"RollPlus.input1D[0]");
	//Lip0_M rotation driver
	createNode -n ($upperLower+"RollBUnitConversion") unitConversion;
	connectAttr ($upperLower+"Lip0_M.rx") ($upperLower+"RollBUnitConversion.input");
	setAttr ($upperLower+"RollBUnitConversion.conversionFactor") (-1*$upperLowerFactor*$upperLowerFactor);
	connectAttr ($upperLower+"RollBUnitConversion.output") ($upperLower+"RollPlus.input1D[1]");

	for ($b=1;$b>-2;$b=$b-2)
		{
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;
			createNode -n ($upperLower+"LipRotate"+$i+$side) unitConversion;
			float $amount=`smoothstep 0 1 (1-((1/($outerNumCv-1.0)*$i)))`;
			setAttr ($upperLower+"LipRotate"+$i+$side+".conversionFactor") $amount;
			connectAttr ($upperLower+"RollPlus.output1D") ($upperLower+"LipRotate"+$i+$side+".input");
			connectAttr ($upperLower+"LipRotate"+$i+$side+".output") ($upperLower+"LipRotateJoint"+$i+$side+".rx");
			}
		}
	}

//scale joints weights
select LipRegion LipScaleRegion;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
eval ("select "+`asGetFaceFitSelection upperLipOuterCurve`);
$tempString=`ls -sl -fl`;
eval ("select "+`asGetFaceFitSelection lowerLipOuterCurve`);
select -add $tempString;
$tempString=`ls -sl -fl`;
select `asobjSetCast "" $tempString LipScaleRegion`;
for ($i=0;$i<$vtxsFromLipToNose;$i++)
	GrowPolygonSelectionRegion;
//select -d `asobjSetCast lipArea {} LipScaleRegion`;
asSmoothFlood LipsScaleJoints_M "" 100;
/*
//Move `down` ScaleJoints, for improved pivot behaviour
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;
	for ($b=1;$b>-2;$b=$b-2)
		{
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;
			$pos=`xform -q -ws -t ($upperLower+"LipMainBuildCurve.cv["+$i+"]")`;
			xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($upperLower+"LipScaleJoint"+$i+$side);
			}
		}
	}
freezeSkinCluster LipScaleSC;
*/

//Smooth weights around mouth
eval ("select "+`asGetFaceFitSelection upperLipOuterCurve`);
$tempString=`ls -sl -fl`;
string $upperOuterVtxs[]=`asobjSetCast "" $tempString LipRegion`;
eval ("select "+`asGetFaceFitSelection lowerLipOuterCurve`);
$tempString=`ls -sl -fl`;
string $lowerOuterVtxs[]=`asobjSetCast "" $tempString LipRegion`;

for ($i=0;$i<size($upperOuterVtxs);$i++)
	{
	select $upperOuterVtxs[$i];
	$tempString=`skinPercent -ignoreBelow 0.001 -q -t LipSC`;
	string $inf=$tempString[0];
	$posA=`xform -q -ws -t NoseUnder`;
	$posB=`xform -q -ws -t $upperOuterVtxs[$i]`;
	$dist=$posA[1]-$posB[1];
	for ($y=0;$y<99;$y++)
		{
		asWsPickWalk 0 1 0;
//		refresh;
		$posB=`xform -q -ws -t`;
		if ($posB[1]>$posA[1])
			break;
		skinPercent -tv $inf (($posA[1]-$posB[1])/$dist) LipSC `ls -sl`;
		$tempString=`ls -sl`;
		$aboveLipWeightedVtxs[size($aboveLipWeightedVtxs)]=$tempString[0];
		}
	}
for ($i=0;$i<size($lowerOuterVtxs);$i++)
	{
	select $lowerOuterVtxs[$i];
	$tempString=`skinPercent -ignoreBelow 0.001 -q -t LipSC`;
	string $inf=$tempString[0];
	$posB=`xform -q -ws -t $lowerOuterVtxs[$i]`;
	$posA={0.0,$posB[1]-$dist,0.0};
	for ($y=0;$y<99;$y++)
		{
		asWsPickWalk 0 -1 0;
//		refresh;
		$posB=`xform -q -ws -t`;
		if ($posB[1]<$posA[1])
			break;
		skinPercent -tv $inf (($posB[1]-$posA[1])/$dist) LipSC `ls -sl`;
		$tempString=`ls -sl`;
		$belowLipWeightedVtxs[size($belowLipWeightedVtxs)]=$tempString[0];
		}
	}

//Hammer inbetween vtx that might been missed.
select $aboveLipWeightedVtxs;
GrowPolygonSelectionRegion;
select -d $aboveLipWeightedVtxs $belowLipWeightedVtxs $lipArea;
if (size(`ls -sl`))
	weightHammerVerts;
select $belowLipWeightedVtxs;
GrowPolygonSelectionRegion;
select -d $aboveLipWeightedVtxs $belowLipWeightedVtxs $lipArea;
if (size(`ls -sl`))
	weightHammerVerts;

//Hammer large area around mouthCorner
$pos=`xform -q -ws -t Lip6_R`;
$posA=$pos;
$posB=`xform -q -ws -t noseCorner`;
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
select LipRegion;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $dist -dp $pos[0] $pos[1] $pos[2];
polySelectConstraint -m 0;
select -d $aboveLipWeightedVtxs $belowLipWeightedVtxs $lipArea;
weightHammerVerts;
copySkinWeights -ss LipSC -ds LipSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//Temp for Degbugging
/*
select $aboveLipWeightedVtxs;
sets -n aboveLipWeightedVtxs;
select $belowLipWeightedVtxs;
sets -n belowLipWeightedVtxs;
select $lipArea;
sets -n lipArea2;
select -cl;
*/

setAttr LipSetup.v 0;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;
setAttr LipRegion.v 0;
setAttr LipRotateRegion.v 0;
setAttr LipScaleRegion.v 0;

delete LipConstruction;

//cheek & noseCorner
$outerNumCv=`getAttr upperEyeLidOuterCurve.spans`+1;
select upperEyeLidOuterCurve.cv[$outerNumCv-1];
$posA=`xform -q -ws -t upperEyeLidOuterCurve.cv[$outerNumCv-1]`;
$posB=`xform -q -ws -t cheek`;
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
setAttr cheek.falloffRadius $dist;
$outerNumCv=`getAttr lowerEyeLidOuterCurve.spans`+1;
$posA=`xform -q -ws -t lowerEyeLidOuterCurve.cv[($outerNumCv-1)/2]`;
//$posB=`xform -q -ws -t cheekBone`;
$posB=`xform -q -ws -t Nose`;
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
setAttr noseCorner.falloffRadius (`getAttr noseCorner.tx`*-2);
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";
	softCluster cheek cheek $b $side;
	softCluster noseCorner noseCorner $b $side;
	}
//Advanced Cheek weighting
//percent -v 0 cheekCluster_R ClustersRegion;
select `asobjSetCast eyeLidVtxs {} ClustersRegion`;
string $eyeLidVtxs[]=`ls -sl -fl`;
select `asobjSetCast lipArea {} ClustersRegion`;
string $lipVtxs[]=`ls -sl -fl`;
string $aboveLipVtxs[]=`asobjSetCast "" $aboveLipWeightedVtxs ClustersRegion`;
string $belowLipVtxs[]=`asobjSetCast "" $belowLipWeightedVtxs ClustersRegion`;
$pos=`xform -q -ws -t noseCorner`;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
select ("ClustersRegion.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
GrowPolygonSelectionRegion;
string $noseCnrVtxs[]=`ls -sl -fl`;
select ClustersRegion;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 ($pos[0]*-1) -dp 0 0 0 -da 1 0 0;
string $noseCnrToCenterVtxs[]=`ls -sl -fl`;
polySelectConstraint -m 0;
select ClustersRegion;
ConvertSelectionToVertices;
select -d $eyeLidVtxs $lipVtxs $aboveLipVtxs $belowLipVtxs $noseCnrVtxs $noseCnrToCenterVtxs;
string $wtxsToSmooth[]=`ls -sl`;
InvertSelection;
percent -v 0 cheekCluster_R;
select -cl;
artAttrToolScript 4 "cluster";
$artSelectObject="";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cheekCluster_R.weights\")");
select $wtxsToSmooth;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster.cheekCluster_R.weights\")");
artAttrPaintOperation artAttrCtx Smooth;
for ($i=0;$i<20;$i++)
	artFloodSurfaces;
select cheek_R;
asFaceMirrorControllerWeights;
setAttr ClustersRegion.v 0;
select -cl;
setToolTo $gSelect;
}

global proc cheekRaiser ()
{
global string $gSelect;
global string $artSelectObject;
string $tempString[],$cheekRaiserVtxs[];
string $side;
//float $posA[]=`xform -q -ws -t EyeLidOuter0`;
//float $posB[]=`xform -q -ws -t EyeLidOuter6`;

int $upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`+1;
float $posA[]=`xform -q -ws -t upperEyeLidOuterCurve.cv[0]`;
float $posB[]=`xform -q -ws -t upperEyeLidOuterCurve.cv[$upperEyeLidOuterNumCVs]`;
float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;

/*
//$tempString[0]=`getAttr FaceFitEyeLidOuter.lowerSelection`;
$tempString[0]=`asGetFaceFitSelection lowerEyeLidOuterCurve`;
string $lowerOuterVtxs[]=`stringToStringArray $tempString[0] " "`;
int $half=(size($lowerOuterVtxs)/2)-1;
select $lowerOuterVtxs[$half];
for ($i=0;$i<4;$i++)
	asWsPickWalk 0 -1 0;
$tempString=`ls -sl -fl`;
$tempString=`asobjSetCast "" $tempString ClustersRegion`;
$cheekRaiserVtxs[0]=$tempString[0];
//select $cheekRaiserVtxs[0];
asCreateFaceFit cheekRaiser "" 0 0 1;
setAttr cheekRaiser.falloffRadius $dist;
*/

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr ClustersRegion.outMesh closestSampler.inMesh;
$posA=`xform -q -ws -t cheekRaiser`;
setAttr -type float3 closestSampler.inPosition $posA[0] $posA[1] $posA[2];
$cheekRaiserVtxs[0]="ClustersRegion.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete closestSampler;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";
	softCluster cheekRaiser cheekRaiser $b $side;
	}

percent -v 0 cheekRaiserCluster_R ClustersRegion;
select $cheekRaiserVtxs[0];
for ($i=0;$i<2;$i++)
	{
	asWsPickWalk 1 0 0;
	$tempString=`ls -sl -fl`;
	$tempString=`asobjSetCast "" $tempString ClustersRegion`;
	$cheekRaiserVtxs[size($cheekRaiserVtxs)]=$tempString[0];
	}
select $cheekRaiserVtxs[0];
for ($i=0;$i<2;$i++)
	{
	asWsPickWalk -1 0 0;
	$tempString=`ls -sl -fl`;
	$tempString=`asobjSetCast "" $tempString ClustersRegion`;
	$cheekRaiserVtxs[size($cheekRaiserVtxs)]=$tempString[0];
	}
percent -v 1 cheekRaiserCluster_R $cheekRaiserVtxs;

select ClustersRegion;
ConvertSelectionToVertices;
select -d `asobjSetCast eyeLidVtxs {} ClustersRegion`;
select -d $cheekRaiserVtxs;
string $wtxsToSmooth[]=`ls -sl`;

select -cl;
artAttrToolScript 4 "cluster";
$artSelectObject="";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cheekRaiserCluster_R.weights\")");
select $wtxsToSmooth;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster.cheekRaiserCluster_R.weights\")");
artAttrPaintOperation artAttrCtx Smooth;
for ($i=0;$i<20;$i++)
	artFloodSurfaces;
select $cheekRaiserVtxs;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster.cheekRaiserCluster_R.weights\")");
artAttrPaintOperation artAttrCtx Smooth;
for ($i=0;$i<4;$i++)
	artFloodSurfaces;
select cheekRaiser_R;
asFaceMirrorControllerWeights;
select -cl;
setToolTo $gSelect;
}

global proc string asGetFaceFitSelection (string $object)
{
int $form,$spans,$degrees,$numCv,$vtxNr;
float $pos[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $selection;
string $tempString[],$curves[],$groupChildren[];
$tempString=`listRelatives -s $object`;
if ($tempString[0]=="")
	{
	$groupChildren=`listRelatives -c $object`;
	for ($i=0;$i<size($groupChildren);$i++)
		{
		$tempString=`listRelatives -s $groupChildren[$i]`;
		if (`gmatch $groupChildren[$i] "*Profile*"`)
			continue;
		if ($tempString[0]!="")
			$curves[size($curves)]=$groupChildren[$i];
		}
	}
else
	$curves[0]=$object;

if (`objExists closestSamplerFitSelection`) delete closestSamplerFitSelection;
createNode -n closestSamplerFitSelection closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSamplerFitSelection.inMesh;

for ($i=0;$i<size($curves);$i++)
	{
	$spans=`getAttr ($curves[$i]+".spans")`;
	$degrees=`getAttr ($curves[$i]+".degree")`;
	$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
		$selection+=($geometry+".vtx["+$vtxNr+"] ");
		}
	}

delete closestSamplerFitSelection;
return $selection;
}

global proc string[] asobjSetCast (string $set, string $components[], string $destObj)
{
string $sel[]=`ls -sl`;

if ($set!="")
	select $set;
else
	select $components;

//If Faces received, temporay convert to Vtx`s
/*int $componentsAreFaces=0;
if (`gmatch $components[0] "*[.]f*"`)
	{
	$componentsAreFaces=1;
	ConvertSelectionToVertices;
	}
*/

string $tempString[]=`ls -sl -fl`;
string $tempString2[];
tokenize $tempString[0] "[.]" $tempString2;
string $sourceObj=$tempString2[0];
select -cl;
for ($i=0;$i<size($tempString);$i++)
	{
	select -add `substitute $sourceObj $tempString[$i] $destObj`;
	}

//if ($componentsAreFaces)
//	ConvertSelectionToFaces;

string $return[]=`ls -sl -fl`;
select $sel;
return $return;
}

/*
global proc asFaceLipSetup ()
{
int $buildLip=`asCanBuild Lip`;
int $buildCheek=`asCanBuild Cheek`;
if ($buildCheek)
	{
	//SoftModPingPongs
	//determine default radius if first build
	if (`getAttr cheek.falloffRadius`==1)
		{
	  float $posA[]=`xform -q -ws -t cheek`;
	  float $posB[]=`xform -q -ws -t Lip6`;
	  float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	  setAttr cheek.falloffRadius $dist;
		}
	if (`getAttr noseCorner.falloffRadius`==1)
		{
	  float $posA[]=`xform -q -ws -t noseCorner`;
	  float $posB[]=`xform -q -ws -t Nose6`;
	  float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	  setAttr noseCorner.falloffRadius $dist;
		}
	
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		softCluster cheek cheek $b $side;
		softCluster noseCorner noseCorner $b $side;
		}
	}
	

//Lip
if ($buildLip)
	asAdvancedLip;
}
*/

global proc asAdvancedEyeBall ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $eyeBallPos[3]=`xform -q -ws -t FitEyeBall`;
float $pos[3];
float $scale=`asFaceGetScale`;
string $tempString[];

createNode -n EyeSetup -p FaceMotionSystem transform;
string $eye,$eyeBallSkinCluster;
string $eyeGeos[];

//EyeAimSetup
createNode -n EyeAimSetup -p EyeSetup transform;
createNode -n EyeAimFollowHead -p EyeAimSetup transform;
parentConstraint $headJoint EyeAimFollowHead;
scaleConstraint $headJoint EyeAimFollowHead;
$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] AimEye_M;
setAttr AimEye_MShape.overrideEnabled 1;
setAttr AimEye_MShape.overrideColor 17;
sets -add FaceControlSet AimEye_M;
scale -r -p 0 0 0 ($scale/10.0) ($scale/10.0) ($scale/10.0) AimEye_M.cv[0:4];
createNode -n AimAimAt -p EyeAimSetup transform;
xform -ws -t 0 $eyeBallPos[1] $eyeBallPos[2] AimAimAt;
//aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject AimAimAt AimAimAt AimEye_M;
//setAttr -k 0 AimEye_M.rx;setAttr -k 0 AimEye_M.ry;setAttr -k 0 AimEye_M.rz;
createNode -n AimEyeOffset_M transform;
createNode -n AimEyeFollow_M transform;
parent AimEyeFollow_M AimEyeOffset_M;
parent AimEye_M AimEyeFollow_M;
parent AimEyeOffset_M Aimcontrols;
xform -ws -t 0 $eyeBallPos[1] ($eyeBallPos[2]+$scale) AimEyeOffset_M;
createNode -n AimEyeUpVec -p FitEyeBall transform;
parent AimEyeUpVec EyeAimFollowHead;

addAttr -k 1 -ln aim -at double -min 0 -max 10 -dv 0 AimEye_M;
createNode -n eyeAimSetRange setRange;
setAttr eyeAimSetRange.minX 0;
setAttr eyeAimSetRange.maxX 1;
setAttr eyeAimSetRange.oldMinX 0;
setAttr eyeAimSetRange.oldMaxX 10;
connectAttr AimEye_M.aim eyeAimSetRange.value.valueX;

addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 AimEye_M;
createNode -n eyeAimFollowSetRange setRange;
setAttr eyeAimFollowSetRange.minX 0;setAttr eyeAimFollowSetRange.minY 1;
setAttr eyeAimFollowSetRange.maxX 1;setAttr eyeAimFollowSetRange.maxY 0;
setAttr eyeAimFollowSetRange.oldMinX 0;setAttr eyeAimFollowSetRange.oldMinY 0;
setAttr eyeAimFollowSetRange.oldMaxX 10;setAttr eyeAimFollowSetRange.oldMaxY 10;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueX;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueY;
parentConstraint -mo $headJoint FaceGroup AimEyeFollow_M;
connectAttr eyeAimFollowSetRange.outValue.outValueY AimEyeFollow_M_parentConstraint1.FaceGroupW1;
connectAttr eyeAimFollowSetRange.outValue.outValueX ("AimEyeFollow_M_parentConstraint1."+$headJoint+"W0");

for ($b=1;$b>-2;$b=$b-2)
	{
	if (!`objExists FitEyeBall`)
		continue;
	if ($b==1) $side="_R"; else $side="_L";

	select FaceDeformationFollowHead;
	joint -n ("Eye"+$side);
	setAttr ("Eye"+$side+".rotateOrder") 2;
	xform -ws -t ($eyeBallPos[0]*$b) $eyeBallPos[1] $eyeBallPos[2] ("Eye"+$side);
	delete `orientConstraint FitEyeBall  ("Eye"+$side)`;
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("Eye"+$side);
	setAttr ("Eye"+$side+".segmentScaleCompensate") 0;
//	setAttr ("Eye"+$side+".jointOrientX") 180;
//	if ($side=="_L")
//		{
//		setAttr Eye_L.jointOrientY (`getAttr Eye_R.jointOrientY`*-1);
//		}
	joint -n ("EyeEnd"+$side);
	if (`objExists DeformSet`)
		sets -add DeformSet ("EyeEnd"+$side);
	setAttr ("EyeEnd"+$side+".tx") (`getAttr FitEyeBall.sx`*1.55);

	$eyeJoint="Eye"+$side;
	$eye=`textField -q -tx ("asFaceEye"+$side+"TextField")`;
	if ($eye=="")
		continue;
	tokenize $eye " " $tempString;
	clear $eyeGeos;
	for ($i=0;$i<size($tempString);$i++)
		$eyeGeos[$i]=$tempString[$i];

	for ($i=0;$i<size($eyeGeos);$i++)
		{
		$haveSkinCluster=0;
		$historyNodes=`listHistory $eyeGeos[$i]`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$eyeBallSkinCluster=$historyNodes[$y];
				}
	
		if ($haveSkinCluster)
			{
			skinCluster -e -lw true -wt 0 -ai $eyeJoint $eyeBallSkinCluster;
			if (`attributeExists lockInfluenceWeights $eyeJoint`)
				setAttr ($eyeJoint+".lockInfluenceWeights") 0;
			skinPercent -tv $eyeJoint 1 $eyeBallSkinCluster $eyeGeos[$i];
			}
		else
			{
			select $eyeJoint $eyeGeos[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			for ($y=0;$y<size($tempString);$y++)
				rename $tempString[$y] ("eyeSC"+$side);
			}
		}
//	connectAttr ("ctrlEye"+$side+".sx") ($eyeJoint+".sz");
//	connectAttr ("ctrlEye"+$side+".sy") ($eyeJoint+".sy");
//	connectAttr ("ctrlEye"+$side+".sz") ($eyeJoint+".sx");
	//SDK
	asFaceBsSdk ("ctrlEye"+$side+".tx") 1 ($eyeJoint+".ry") -30;
	asFaceBsSdk ("ctrlEye"+$side+".tx") -1 ($eyeJoint+".ry") 30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") 1 ($eyeJoint+".rz") -30;
	asFaceBsSdk ("ctrlEye"+$side+".ty") -1 ($eyeJoint+".rz") 30;
	//Look-at
	createNode -n ("EyeOffset"+$side) -p ("Eye"+$side) transform;
	parent ("EyeOffset"+$side) EyeAimFollowHead;

	createNode -n ("AimOffsetEye"+$side) -p AimEye_M transform;
//	duplicate -n ("AimOffsetEye"+$side) ("EyeOffset"+$side);
	parent ("AimOffsetEye"+$side) ("Eye"+$side);
	setAttr ("AimOffsetEye"+$side+".tx") $scale;
	parent ("AimOffsetEye"+$side) AimEye_M;

	duplicate -n ("AimEye"+$side) AimEye_M;
	delete `listRelatives -c -fullPath -type transform ("AimEye"+$side)`;
	parent -r ("AimEye"+$side) ("AimOffsetEye"+$side);

	$pos=`xform -q -ws -t AimEye_MShape.cv[4]`;
	$pos[0]*=$b;
	xform -ws -t $pos[0] ($pos[1]+($scale*0.03)) $pos[2] ("AimEye"+$side+".cv[0]");
	xform -ws -t $pos[0] ($pos[1]+($scale*-0.03)) $pos[2] ("AimEye"+$side+".cv[1]");
	xform -ws -t $pos[0] $pos[1] $pos[2] ("AimEye"+$side+".cv[2]");
	xform -ws -t ($pos[0]+($scale*0.03)) $pos[1] $pos[2] ("AimEye"+$side+".cv[3]");
	xform -ws -t ($pos[0]+($scale*-0.03)) $pos[1] $pos[2] ("AimEye"+$side+".cv[4]");

/*
	duplicate -n ("EyeAimTargetOff"+$side) ("EyeAimTargetOn"+$side);
	parent ("EyeAimTargetOff"+$side) EyeAimFollowHead;
	parent ("EyeAimTargetOn"+$side) AimEye_M;
*/

	duplicate -n ("EyeAim"+$side) ("EyeOffset"+$side);
	setAttr ("EyeAim"+$side+".rotateOrder") `getAttr ("Eye"+$side+".rotateOrder")`;
	parent ("EyeAim"+$side) ("EyeOffset"+$side);
	createNode -n ("EyeAimBlend"+$side) blendColors;
	connectAttr ("EyeAim"+$side+".rotate") ("EyeAimBlend"+$side+".color1");
	connectAttr ("Eye"+$side+"_rotateY.output") ("EyeAimBlend"+$side+".color2G");
	connectAttr ("Eye"+$side+"_rotateZ.output") ("EyeAimBlend"+$side+".color2B");
	connectAttr -f ("EyeAimBlend"+$side+".outputR") ("Eye"+$side+".rx");
	connectAttr -f ("EyeAimBlend"+$side+".outputG") ("Eye"+$side+".ry");
	connectAttr -f ("EyeAimBlend"+$side+".outputB") ("Eye"+$side+".rz");

	aimConstraint -aimVector 1 0 0 -worldUpType objectrotation -worldUpObject AimEyeUpVec -worldUpVector 0 1 0 ("AimEye"+$side) ("EyeAim"+$side);
	parent -w ("EyeAim"+$side);
	asAlign ("EyeOffset"+$side) ("EyeAim"+$side) 1 1 0 0;
	parent ("EyeAim"+$side) ("EyeOffset"+$side);
	connectAttr eyeAimSetRange.outValue.outValueX ("EyeAimBlend"+$side+".blender");
	}
}

global proc string asGetGeometryFaces ()
{
string $geometryFaces;
string $tempString[];
if (`objExists faceMaskSet`)
	{
	$tempString=`sets -q faceMaskSet`;
	$geometryFaces=`stringArrayToString $tempString " "`;
	}
return $geometryFaces;
}

global proc asDetermineGeometryFaces ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];
float $xMin=0;
float $yMin=9999;
float $yMax=0;
float $zMin=999;
float $zMax=0;
float $pos[];
string $fitLocShapes[]=`listRelatives -ad -type locator FaceFitSkeleton`;
for ($i=0;$i<size($fitLocShapes);$i++)
	{
	$tempString=`listRelatives -p $fitLocShapes[$i]`;
	$pos=`xform -q -ws -t $tempString[0]`;
	if ($pos[0]<$xMin) $xMin=$pos[0];
	if ($pos[1]<$yMin) $yMin=$pos[1];
	if ($pos[1]>$yMax) $yMax=$pos[1];
	if ($pos[2]<$zMin) $zMin=$pos[2];
	if ($pos[2]>$zMax) $zMax=$pos[2];
	}
select $geometry;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 ($xMin*-1.1) -dp 0 0 0 -da 1 0 0;
polySelectConstraint -m 0;
if (size(`ls -sl`)) InvertSelection; else return;
string $xInvSet[]=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 ((($yMax-$yMin)/2.0)*1.1) -dp 0 (($yMax+$yMin)/2.0) 0 -da 0 1 0;
polySelectConstraint -m 0;
if (size(`ls -sl`)) InvertSelection; else return;
string $yInvSet[]=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 ((($zMax-$zMin)/2.0)*1.1) -dp 0 0 (($zMax+$zMin)/2.0) -da 0 0 1;
polySelectConstraint -m 0;
if (size(`ls -sl`)) InvertSelection; else return;
string $zInvSet[]=`ls -sl`;
select  ($geometry+".vtx[0:99999]");
select -d $xInvSet $yInvSet $zInvSet;
ConvertSelectionToFaces;
$tempString=`ls -sl -fl`;
int $numFaceFaces=size($tempString);
int $tempInts[]=`polyEvaluate -f $geometry`;
//use Cutout of face-faces, only if they amount to less than 50% of all-faces
if (($tempInts[0]/2)<$numFaceFaces)
	sets -em -n faceMaskSet;
else
	sets -n faceMaskSet;
sets -add FaceBuildingSets faceMaskSet;
select $sel;
}

global proc asAdvancedEyeLid ()
{
global string $gMainProgressBar;
int $tempInts[];
float $pos[],$posA[],$posB[],$values[];
float $maxValue,$maxValue2;
string $upperLower,$lidJoint,$eyeJoint,$maxTransform,$maxTransform2;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$infs[],$transforms[];
//string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`;

setAttr ctrlEye_L.tx 0;setAttr ctrlEye_L.ty 0;
setAttr ctrlEye_R.tx 0;setAttr ctrlEye_R.ty 0;

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;

if (`objExists tempTargetFullMesh`)
	duplicate -n EyeLidRegion tempTargetFullMesh;
else
	duplicate -n EyeLidRegion tempTarget;
setAttr EyeLidRegion.v 1;
parent EyeLidRegion RegionDeformations;
sets -e -forceElement initialShadingGroup EyeLidRegion;
select faceHeadJoint EyeLidRegion;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] EyeLidSC;
setAttr EyeLidSC.skinningMethod 1;

createNode -n LidSetup -p FaceMotionSystem transform;
createNode -n LidJoints -p LidSetup transform;
//parentConstraint $headJoint LidJoints;
//scaleConstraint $headJoint LidJoints;
setAttr -l 1 LidSetup.v 0;
select faceHeadJoint;
joint -n faceLid;
setAttr -l 1 faceLid.v 0;
setAttr faceLid.segmentScaleCompensate 0;
skinCluster -e -wt 0 -ai faceLid  -lw true EyeLidSC;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	createNode -n ("LidSetup"+$side) transform;
	asAlign ("LidSetup"+$side) ("Eye"+$side) 1 1 0 0;
	parent ("LidSetup"+$side) faceLid;
	}

//Setup Lid
int $numLid;
//int $numLidUpper=20;
//int $numLidLower=20;
string $selectionMainVtxs[],$selectionMainVtxsAll[],$selectionOuterVtxs[],$selectionOuterVtxsAll[];
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
progressBar -e -st ("Setup EyeLid") -bp -ii 0 -min 0 -max 4 $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	$eyeJoint="Eye"+$side;

	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blink"+$side) -at double LidSetup;
	addAttr -dv 0.2 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blinkCenter"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLid"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLid"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidOut"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidOut"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidFollow"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidFollow"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidOutAuto"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidOutAuto"+$side) -at double LidSetup;

	createNode -n ("blinkCenterReverse"+$side) reverse;
	connectAttr ("LidSetup.blinkCenter"+$side) ("blinkCenterReverse"+$side+".inputX");

	createNode -n ("LidLocs"+$side) transform;
	setAttr ("LidLocs"+$side+".inheritsTransform") 0;
	parent ("LidLocs"+$side) LidSetup;
	setAttr -l 1 ("LidLocs"+$side+".v") 0;
	createNode -n ("LidCurves"+$side) transform;
	parent ("LidCurves"+$side) LidSetup;

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		progressBar -e -s 1 $gMainProgressBar;
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

/*
		if (`attributeExists selection FaceFitEyeLidMain`)
			{
			$tempString[0]=`getAttr ("FaceFitEyeLidMain."+$upperLower+"Selection")`;
			tokenize $tempString[0] $selectionMainVtxs;
			$selectionMainVtxsAll=`stringArrayCatenate $selectionMainVtxsAll $selectionMainVtxs`;
			$numLid=size($selectionMainVtxs);
			if ($upperLower=="upper")
				$numLidUpper=$numLid;
			else
				$numLidLower=$numLid;
			$tempString[0]=`getAttr ("FaceFitEyeLidOuter."+$upperLower+"Selection")`;
			tokenize $tempString[0] $selectionOuterVtxs;
			$selectionOuterVtxsAll=`stringArrayCatenate $selectionOuterVtxsAll $selectionOuterVtxs`;
			}
*/
		duplicate -n ($upperLower+"LidCurve2"+$side) ($upperLower+"EyeLidMainCurve");
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.004 ($upperLower+"LidCurve2"+$side);	
/*
		$pos=`xform -q -ws -t ($upperLower+"EyeLidMainCurve.cv[2]")`;xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[1]");
		$pos=`xform -q -ws -t ($upperLower+"EyeLidMainCurve.cv[3]")`;xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[2]");
		$pos=`xform -q -ws -t ($upperLower+"EyeLidMainCurve.cv[4]")`;xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[3]");
		if ($side=="_R")
			{
			//find best position for cv[2,1&3]
			int $nudgeVtxNrs[]={2,1,3};
			for ($i=0;$i<size($nudgeVtxNrs);$i++)
				{
				connectAttr -f ($upperLower+"LidCurve2"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;
				$pos=`xform -q -ws -t ($upperLower+"LidCurve2"+$side+".cv["+$nudgeVtxNrs[$i]+"]")`;
				setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
				$posA=`getAttr tempNearestPointOnCurve.position`;
				connectAttr -f ($upperLower+"EyeLidMainCurve.worldSpace[0]") tempNearestPointOnCurve.inputCurve;
				$posB=`getAttr tempNearestPointOnCurve.position`;
				move -r (($posB[0]-$posA[0])*2) (($posB[1]-$posA[1])*2) (($posB[2]-$posA[2])*2) ($upperLower+"LidCurve2"+$side+".cv["+$nudgeVtxNrs[$i]+"]");
				}
			}
*/

		//rebuild another curve, for getting good placements for the cv`s
		rebuildCurve -n ($upperLower+"EyeLidMainRebuiltSamplerCurve") -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.0001 ($upperLower+"EyeLidMainCurve") ;
		connectAttr -f ($upperLower+"EyeLidMainRebuiltSamplerCurveShape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		setAttr tempPointOnCurveInfo.parameter 0.25;
		$pos=`getAttr tempPointOnCurveInfo.position`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[1]");
		setAttr tempPointOnCurveInfo.parameter 0.75;
		$pos=`getAttr tempPointOnCurveInfo.position`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidCurve2"+$side+".cv[3]");
		disconnectAttr ($upperLower+"EyeLidMainRebuiltSamplerCurveShape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		delete ($upperLower+"EyeLidMainRebuiltSamplerCurve");

		//Might need to flip over Left curve here
		if ($side=="_L")
			scale -r -p 0 0 0 -1 1 1 ($upperLower+"LidCurve2"+$side+".cv[0:4]");
		parent ($upperLower+"LidCurve2"+$side) ("LidCurves"+$side);

		//make Tweaked-Shape, so each cv is zero position at the correct place
		createNode -n ($upperLower+"LidCurve2"+$side+"TweakedShape") -p ($upperLower+"LidCurve2"+$side) nurbsCurve;
		connectAttr -f ($upperLower+"LidCurve2"+$side+"Shape.worldSpace[0]") ($upperLower+"LidCurve2"+$side+"TweakedShape.create");
		setAttr ($upperLower+"LidCurve2"+$side+"Shape.intermediateObject") 1;

/*
		connectAttr -f ($upperLower+"LidCurve2"+$side+"Shape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		$curveCmd="curve -d 1 ";
		for ($i=0;$i<$numLid;$i++)
			{
			setAttr tempPointOnCurveInfo.parameter ($i/($numLid-1.00));
			$pos=`getAttr tempPointOnCurveInfo.position`;
			if (`attributeExists selection FaceFitEyeLidMain`)
				{
				$pos=`xform -q -ws -t $selectionMainVtxs[$i]`;
				$pos[0]=$pos[0]*$b;
				}
			$eyeJoint="Eye"+$side;
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"LidCurve1"+$side);
*/
		duplicate -n ($upperLower+"LidCurve1"+$side) ($upperLower+"EyeLidMainCurve");
		parent -w ($upperLower+"LidCurve1"+$side);
		if ($side=="_L")
			scale -r -p 0 0 0 -1 1 1 ($upperLower+"LidCurve1"+$side+".cv[0:999]");

		duplicate -n ($upperLower+"EyeLidMainCurve1"+$side) ($upperLower+"LidCurve1"+$side);
		parent ($upperLower+"LidCurve1"+$side) ("LidCurves"+$side);

		//EyeLidOuterCurve1 (for loft)
/*
		connectAttr -f ($upperLower+"EyeLidOuterCurveShape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		$curveCmd="curve -d 1 ";
		
		int $numLowerLid=20;
		if (`attributeExists selection FaceFitEyeLidMain`)
			$numLowerLid=size($selectionOuterVtxs);
		for ($i=0;$i<$numLowerLid;$i++)
			{
			setAttr tempPointOnCurveInfo.parameter ($i/($numLid-1.00));
			$pos=`getAttr tempPointOnCurveInfo.position`;
			if (`attributeExists selection FaceFitEyeLidMain`)
				{
				$pos=`xform -q -ws -t $selectionOuterVtxs[$i]`;
				$pos[0]=$pos[0]*$b;
				}
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"EyeLidOuterCurve1"+$side);
*/
		duplicate -n ($upperLower+"EyeLidOuterCurve1"+$side) ($upperLower+"EyeLidOuterCurve");
		parent -w ($upperLower+"EyeLidOuterCurve1"+$side);
		if ($side=="_L")
			scale -r -p 0 0 0 -1 1 1 ($upperLower+"EyeLidOuterCurve1"+$side+".cv[0:999]");

//		$spans=`getAttr ($upperLower+"EyeLidMainCurve1"+$side+".spans")`;
//		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 1 -tol 0.004 ($upperLower+"EyeLidOuterCurve1"+$side);	

		$numLid=`getAttr ($upperLower+"EyeLidMainCurve.spans")`+1;
		for ($i=0;$i<$numLid;$i++)
			{
			spaceLocator -n ($upperLower+"LidLoc"+$i+$side);
			parent ($upperLower+"LidLoc"+$i+$side) ("LidLocs"+$side);
			createNode -n ($upperLower+"LidPoci"+$i+$side) pointOnCurveInfo;
			setAttr ($upperLower+"LidPoci"+$i+$side+".turnOnPercentage") 1;
			setAttr ($upperLower+"LidPoci"+$i+$side+".parameter") ($i/($numLid-1.00));
			connectAttr ($upperLower+"LidPoci"+$i+$side+".position") ($upperLower+"LidLoc"+$i+$side+".translate");
			connectAttr ($upperLower+"LidCurve1"+$side+"Shape.worldSpace[0]") ($upperLower+"LidPoci"+$i+$side+".inputCurve");

			createNode -n ($upperLower+"LidMain"+$i+"Aim"+$side) transform;
			parent ($upperLower+"LidMain"+$i+"Aim"+$side) ("LidSetup"+$side);
			setAttr -type float3 ($upperLower+"LidMain"+$i+"Aim"+$side+".t") 0 0 0;
			aimConstraint -worldUpType objectrotation -worldUpObject faceHeadJoint -worldUpVector 1 0 0 ($upperLower+"LidLoc"+$i+$side) ($upperLower+"LidMain"+$i+"Aim"+$side);
			select -cl;
			joint -n ($upperLower+"LidMain"+$i+$side);
			setAttr ($upperLower+"LidMain"+$i+$side+".radius") 0.1;
			$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$i+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidMain"+$i+$side);
			parent ($upperLower+"LidMain"+$i+$side) ($upperLower+"LidMain"+$i+"Aim"+$side);

			//LidOut
			if ($i>0 && $i<$numLid-1)
				{
				createNode -n ($upperLower+"LidOutMult"+$i+$side) multiplyDivide;
				float $factor;
				if ($i<($numLid/2)) $factor=`smoothstep 0 $numLid $i`;
				else $factor=`smoothstep 0 $numLid ($numLid-1-$i)`;
				$factor=$factor*($scale/3.0);
				setAttr ($upperLower+"LidOutMult"+$i+$side+".input1X") $factor;
				connectAttr ("LidSetup."+$upperLower+"LidOut"+$side) ($upperLower+"LidOutMult"+$i+$side+".input2X");

				createNode -n ($upperLower+"LidOutMultAutoA"+$i+$side) multiplyDivide;
				setAttr ($upperLower+"LidOutMultAutoA"+$i+$side+".input1X") $factor;
				connectAttr ("LidSetup."+$upperLower+"LidOutAuto"+$side) ($upperLower+"LidOutMultAutoA"+$i+$side+".input2X");

				createNode -n ($upperLower+"LidOutMultAutoB"+$i+$side) multiplyDivide;
				connectAttr ($upperLower+"LidOutMultAutoA"+$i+$side+".outputX") ($upperLower+"LidOutMultAutoB"+$i+$side+".input1X");
				connectAttr ("LidSetup.blink"+$side) ($upperLower+"LidOutMultAutoB"+$i+$side+".input2X");

				createNode -n ($upperLower+"LidOut"+$i+$side) plusMinusAverage;
				setAttr ($upperLower+"LidOut"+$i+$side+".input1D[0]") `getAttr ($upperLower+"LidMain"+$i+$side+".tx")`;
				connectAttr ($upperLower+"LidOutMult"+$i+$side+".outputX") ($upperLower+"LidOut"+$i+$side+".input1D[1]");
				connectAttr ($upperLower+"LidOutMultAutoB"+$i+$side+".outputX") ($upperLower+"LidOut"+$i+$side+".input1D[2]");

				connectAttr ($upperLower+"LidOut"+$i+$side+".output1D") ($upperLower+"LidMain"+$i+$side+".tx");
				}
			}
	
		if ($upperLower=="upper")
			duplicate -n ("closedLidCurve2"+$side) ("upperLidCurve2"+$side);
		if ($upperLower=="lower")
			{
			select -r ("upperLidCurve2"+$side) ("lowerLidCurve2"+$side) ("closedLidCurve2"+$side);
			blendShape -n ("closedLidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;
			connectAttr ("LidSetup.blinkCenter"+$side) ("closedLidCurveCloseBS"+$side+".upperLidCurve2"+$side);
			connectAttr ("blinkCenterReverse"+$side+".outputX") ("closedLidCurveCloseBS"+$side+".lowerLidCurve2"+$side);
			}
		duplicate -n ($upperLower+"LidCurveClose"+$side) ($upperLower+"LidCurve2"+$side);
		select -r ($upperLower+"LidCurve2"+$side) ("closedLidCurve2"+$side) ($upperLower+"LidCurveClose"+$side);
		blendShape -n ($upperLower+"LidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;

		createNode -n ($upperLower+"CloseLidCurveMixer"+$side) plusMinusAverage;
		connectAttr ("LidSetup.blink"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[0]");
		connectAttr ("LidSetup."+$upperLower+"Lid"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[1]");
		connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"LidCurveCloseBS"+$side+".closedLidCurve2"+$side);

		createNode -n ($upperLower+"blinkReverse"+$side) reverse;
		connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"blinkReverse"+$side+".inputX");
		connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"LidCurveCloseBS"+$side+"."+$upperLower+"LidCurve2"+$side);

		//wireDeform in WorldSpace, since wireDefomer does not work well with 180 rotation, and extreme scaling.
		createNode -n ("LidWireWS"+$side) -p ("LidCurves"+$side) transform;
//		parentConstraint $headJoint ("LidWireWS"+$side);
//		scaleConstraint $headJoint ("LidWireWS"+$side);
		duplicate -n ($upperLower+"LidCurve1OS"+$side) ($upperLower+"LidCurve1"+$side);
		parent ($upperLower+"LidCurve1"+$side) ("LidWireWS"+$side);
		wire -n ($upperLower+"LidCurveWire"+$side) -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ($upperLower+"LidCurveClose"+$side) ($upperLower+"LidCurve1OS"+$side);
		connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"LidCurveWire"+$side+".scale[0]");
		setAttr ($upperLower+"LidCurveWire"+$side+".dropoffDistance[0]") 20;
		connectAttr ($upperLower+"LidCurve1OS"+$side+"Shape.create") ($upperLower+"LidCurve1"+$side+"Shape.create");

		if ($b==1 && $upperLowerFactor==1)
			connectAttr -f tempNearestPointOnCurve.position tempLoc.translate;
		connectAttr -f ($upperLower+"LidCurve1"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;

		if ($upperLower=="upper")
			{
			asPingPong ("upperLidCurve2"+$side+".ep[0]") "LidCorner1" 1 $side 7 1 0;
			asPingPong ("upperLidCurve2"+$side+".ep[2]") "LidCorner2" 1 $side 7 1 0;
			}

		//$upperLower (1)
		$pos=`xform -q -ws -t ($upperLower+"LidCurve2"+$side+".ep[1]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		//snapToClosestVtx for better atttachemtEdge
		$parameter=`getAttr tempNearestPointOnCurve.parameter`;
		$closestVtxNr=`asRoundOff $parameter 0`;
		$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$closestVtxNr+"]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		asPingPong tempLoc ($upperLower+"Lid1") 1 $side 7 1 0;

		//$upperLower (2)
		$pos=`xform -q -ws -t ($upperLower+"LidCurveClose"+$side+".cv[1]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		//snapToClosestVtx for better atttachemtEdge
		$parameter=`getAttr tempNearestPointOnCurve.parameter`;
		$closestVtxNr=`asRoundOff $parameter 0`;
		$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$closestVtxNr+"]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		asPingPong tempLoc ($upperLower+"Lid2") 1 $side 10 1 0;
		setAttr -type float3 ($upperLower+"Lid2"+$side+".s") 0.5 0.5 0.5;
		makeIdentity -a 1 -t 0 -r 0 -s 1 ($upperLower+"Lid2"+$side);
		asFaceAddIn {($upperLower+"Lid1Joint"+$side),("LidCorner1Joint"+$side)} ($upperLower+"Lid2Joint"+$side) 1;

		//$upperLower (3)
		$pos=`xform -q -ws -t ($upperLower+"LidCurveClose"+$side+".cv[3]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		//snapToClosestVtx for better atttachemtEdge
		$parameter=`getAttr tempNearestPointOnCurve.parameter`;
		$closestVtxNr=`asRoundOff $parameter 0`;
		$pos=`xform -q -ws -t ($upperLower+"LidCurve1"+$side+".cv["+$closestVtxNr+"]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		asPingPong tempLoc ($upperLower+"Lid3") 1 $side 10 1 0;
		setAttr -type float3 ($upperLower+"Lid3"+$side+".s") 0.5 0.5 0.5;
		makeIdentity -a 1 -t 0 -r 0 -s 1 ($upperLower+"Lid3"+$side);
		asFaceAddIn {($upperLower+"Lid1Joint"+$side),("LidCorner2Joint"+$side)} ($upperLower+"Lid3Joint"+$side) 1;
		connectAttr ("LidCorner2Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[4]");
		connectAttr ($upperLower+"Lid3Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[3]");
		connectAttr ($upperLower+"Lid1Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[2]");
		connectAttr ($upperLower+"Lid2Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[1]");
		connectAttr ("LidCorner1Joint"+$side+".t") ($upperLower+"LidCurve2"+$side+".cv[0]");

		//now after binding the curve, we can parent the joints
		if ($upperLower=="upper")
			parent ("LidCorner1JointOffset"+$side) ("LidCorner2JointOffset"+$side) LidJoints;
		parent ($upperLower+"Lid1JointOffset"+$side) ($upperLower+"Lid2JointOffset"+$side) ($upperLower+"Lid3JointOffset"+$side) LidJoints;


		// LidControlFollow
		createNode -n ($upperLower+"Lid1JointFollow"+$side) transform;
		$pos=`xform -q -ws -t ($upperLower+"Lid1Joint"+$side)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid1JointFollow"+$side);
		$tempString=`listRelatives -p ($upperLower+"Lid1Joint"+$side)`;
		parent ($upperLower+"Lid1JointFollow"+$side) $tempString[0];
		duplicate -n ($upperLower+"Lid1JointFollowBlended"+$side) ($upperLower+"Lid1JointFollow"+$side);
		createNode -n ($upperLower+"Lid1JointFollowLidRot"+$side) transform;
		parent ($upperLower+"Lid1JointFollowLidRot"+$side) $tempString[0];
		$pos=`xform -q -ws -t $eyeJoint`;
		$rot=`xform -q -ws -ro $eyeJoint`;
		asAlign ($upperLower+"Lid1JointFollowLidRot"+$side) $eyeJoint 1 1 0 1;
		duplicate -n ($upperLower+"Lid1JointFollowLidRotOffset"+$side) ($upperLower+"Lid1JointFollowLidRot"+$side);
		parent ($upperLower+"Lid1JointFollowLidRot"+$side) ($upperLower+"Lid1JointFollowLidRotOffset"+$side);
		parentConstraint -mo ($upperLower+"Lid1JointFollowLidRot"+$side) ($upperLower+"Lid1JointFollow"+$side);
		connectAttr ($eyeJoint+".rx") ($upperLower+"Lid1JointFollowLidRot"+$side+".rx");
		connectAttr ($eyeJoint+".ry") ($upperLower+"Lid1JointFollowLidRot"+$side+".ry");
		connectAttr ($eyeJoint+".rz") ($upperLower+"Lid1JointFollowLidRot"+$side+".rz");
		createNode -n ($upperLower+"LidFollowMultiply"+$side) multiplyDivide;
		connectAttr ($upperLower+"Lid1JointFollow"+$side+".t") ($upperLower+"LidFollowMultiply"+$side+".input1");
		connectAttr ("LidSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"LidFollowMultiply"+$side+".input2X");
		connectAttr ("LidSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"LidFollowMultiply"+$side+".input2Y");
		connectAttr ("LidSetup."+$upperLower+"LidFollow"+$side) ($upperLower+"LidFollowMultiply"+$side+".input2Z");
		connectAttr ($upperLower+"LidFollowMultiply"+$side+".output") ($upperLower+"Lid1JointFollowBlended"+$side+".t");
		asFaceAddIn {($upperLower+"Lid1JointFollowBlended"+$side)} ($upperLower+"Lid1Joint"+$side) 1;
		}
	}

//ctrlLid attributes
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	if (!`attributeExists blink ("ctrlEye"+$side)`)
		addAttr -ln "blink"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkCenter ("ctrlEye"+$side)`)
		addAttr -ln "blinkCenter" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLid ("ctrlEye"+$side)`)
		addAttr -ln "upperLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLid ("ctrlEye"+$side)`)
		addAttr -ln "lowerLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLidOut ("ctrlEye"+$side)`)
		addAttr -ln "upperLidOut" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidOut ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidOut" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkDriven ("ctrlEye"+$side)`)
		{
		addAttr -ln "eyeDriven" -k 1 -at double ("ctrlEye"+$side);
		setAttr -l 1 ("ctrlEye"+$side+".eyeDriven");
		}
	if (!`attributeExists upperLidFollow ("ctrlEye"+$side)`)
		addAttr -ln "upperLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidFollow ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkDriven ("ctrlEye"+$side)`)
		{
		addAttr -ln "blinkDriven" -k 1 -at double ("ctrlEye"+$side);
		setAttr -l 1 ("ctrlEye"+$side+".blinkDriven");
		}
	if (!`attributeExists upperLidOutAuto ("ctrlEye"+$side)`)
		addAttr -ln "upperLidOutAuto" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidOutAuto ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidOutAuto" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);

	if (`objExists LidSetup`)
		{
		asFaceBsSdk ("ctrlEye"+$side+".blink") 10 ("LidSetup.blink"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".blink") -10 ("LidSetup.blink"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".blinkCenter") 10 ("LidSetup.blinkCenter"+$side) 1;
		setAttr ("ctrlEye"+$side+".blinkCenter") 0.2;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") 10 ("LidSetup.upperLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") -10 ("LidSetup.upperLid"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") 10 ("LidSetup.lowerLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") -10 ("LidSetup.lowerLid"+$side) -1;
		setAttr ("LidSetup.upperLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidFollow") 10 ("LidSetup.upperLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".upperLidFollow") 10;
		setAttr ("LidSetup.lowerLidFollow"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidFollow") 10 ("LidSetup.lowerLidFollow"+$side) 1;
		setAttr ("ctrlEye"+$side+".lowerLidFollow") 3;

		setAttr ("LidSetup.upperLidOut"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidOut") 10 ("LidSetup.upperLidOut"+$side) 1;
		setAttr ("LidSetup.lowerLidOut"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidOut") 10 ("LidSetup.lowerLidOut"+$side) 1;
		setAttr ("LidSetup.upperLidOutAuto"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidOutAuto") 10 ("LidSetup.upperLidOutAuto"+$side) 1;
		setAttr ("LidSetup.lowerLidOutAuto"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidOutAuto") 10 ("LidSetup.lowerLidOutAuto"+$side) 1;
		}
/*
	connectAttr ("ctrlEye"+$side+".sx") ("LidSetup"+$side+".sz");
	connectAttr ("ctrlEye"+$side+".sy") ("LidSetup"+$side+".sy");
	connectAttr ("ctrlEye"+$side+".sz") ("LidSetup"+$side+".sx");
*/
	createNode -n ("EyeBallScaleMult"+$side) multiplyDivide;
	connectAttr ("ctrlEye"+$side+".s") ("EyeBallScaleMult"+$side+".input1");
//	connectAttr  ("EyeBallScaleMult"+$side+".output") ("Eye"+$side+".s");
	connectAttr  ("EyeBallScaleMult"+$side+".outputX") ("Eye"+$side+".sz");
	connectAttr  ("EyeBallScaleMult"+$side+".outputY") ("Eye"+$side+".sy");
	connectAttr  ("EyeBallScaleMult"+$side+".outputZ") ("Eye"+$side+".sx");
	}


//eyeLidVtxs set
//eval ("select "+`getAttr FaceFitEyeLidOuter.selection`);ConvertSelectionToVertices;
eval ("select "+`asGetFaceFitSelection FaceFitEyeLidOuterCurve`);
string $outerVtxs[]=`ls -sl -fl`;
//eval ("select "+`getAttr FaceFitEyeLidMain.selection`);ConvertSelectionToVertices;
eval ("select "+`asGetFaceFitSelection FaceFitEyeLidMainCurve`);
string $mainVtxs[]=`ls -sl -fl`;
//eval ("select "+`getAttr FaceFitEyeLidInner.selection`);ConvertSelectionToVertices;
eval ("select "+`asGetFaceFitSelection FaceFitEyeLidInnerCurve`);
string $innerVtxs[]=`ls -sl -fl`;
select $mainVtxs;
for ($i=0;$i<20;$i++)
	{
	GrowPolygonSelectionRegion;
	select -d $outerVtxs $innerVtxs;
	}
sets -n eyeLidVtxs;
sets -add FaceBuildingSets eyeLidVtxs;
string $eyeLidRegionVtxs[]=`asobjSetCast eyeLidVtxs {} EyeLidRegion`;

//Add joint as influences
string $addInfCmd="skinCluster -e ";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";}
		else {$upperLower="lower";}

		$numLid=`getAttr ($upperLower+"EyeLidMainCurve.spans")`+1;
		for ($i=0;$i<$numLid;$i++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			$addInfCmd+=" -ai "+$upperLower+"LidMain"+$i+$side;
			}
		}
	}
$addInfCmd+=" -lw false -wt 0 EyeLidSC" ;
eval ($addInfCmd);

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;

//Full weight for $mainVtxs & $innerVtxs
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		$numLid=`getAttr ($upperLower+"EyeLidMainCurve.spans")`+1;
		if ($upperLowerFactor==1) {$upperLower="upper";}
		else {$upperLower="lower";}

//		$tempString[0]=`getAttr ("FaceFitEyeLidMain."+$upperLower+"Selection")`;
		$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidMainCurve")`;
		string $mainVtxs[]=`stringToStringArray $tempString[0] " "`;
//		$tempString[0]=`getAttr ("FaceFitEyeLidInner."+$upperLower+"Selection")`;
		$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidInnerCurve")`;
		string $innerVtxs[]=`stringToStringArray $tempString[0] " "`;
		for ($i=0;$i<size($mainVtxs);$i++)
			{
			//MainVtxs
			$pos=`xform -q -ws -t $mainVtxs[$i]`;
			setAttr -type float3 closestSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
			skinPercent -tv ($upperLower+"LidMain"+$i+$side) 1 EyeLidSC ("EyeLidRegion.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
			//InnerVtxs
			if (!`objExists $innerVtxs[$i]`)
				continue;
			$pos=`xform -q -ws -t $innerVtxs[$i]`;
			setAttr -type float3 closestSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
			skinPercent -tv ($upperLower+"LidMain"+$i+$side) 1 EyeLidSC ("EyeLidRegion.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
			}
		}
	}
//Full weight for Inbetween $mainVtxs & $innerVtxs
//$tempString[0]=`getAttr FaceFitEyeLidMain.upperSelection`;
$tempString[0]=`asGetFaceFitSelection upperEyeLidMainCurve`;
string $upperMainVtxs[]=`stringToStringArray $tempString[0] " "`;
//$tempString[0]=`getAttr FaceFitEyeLidMain.lowerSelection`;
$tempString[0]=`asGetFaceFitSelection lowerEyeLidMainCurve`;
string $lowerMainVtxs[]=`stringToStringArray $tempString[0] " "`;
select $upperMainVtxs $lowerMainVtxs;
string $mainVtxs[]=`ls -sl -fl`;

//$tempString[0]=`getAttr FaceFitEyeLidInner.upperSelection`;
$tempString[0]=`asGetFaceFitSelection upperEyeLidInnerCurve`;
string $upperInnerVtxs[]=`stringToStringArray $tempString[0] " "`;
//$tempString[0]=`getAttr FaceFitEyeLidInner.lowerSelection`;
$tempString[0]=`asGetFaceFitSelection lowerEyeLidInnerCurve`;
string $lowerInnerVtxs[]=`stringToStringArray $tempString[0] " "`;
select $upperInnerVtxs $lowerInnerVtxs;
string $innerVtxs[]=`ls -sl -fl`;

//$tempString[0]=`getAttr FaceFitEyeLidOuter.upperSelection`;
$tempString[0]=`asGetFaceFitSelection upperEyeLidOuterCurve`;
string $upperOuterVtxs[]=`stringToStringArray $tempString[0] " "`;
//$tempString[0]=`getAttr FaceFitEyeLidOuter.lowerSelection`;
$tempString[0]=`asGetFaceFitSelection lowerEyeLidOuterCurve`;
string $lowerOuterVtxs[]=`stringToStringArray $tempString[0] " "`;
select $upperOuterVtxs $lowerOuterVtxs;
string $outerVtxs[]=`ls -sl -fl`;

select $upperMainVtxs[size($upperMainVtxs)/2];
ConvertSelectionToEdges;
ConvertSelectionToVertices;
select -d $upperMainVtxs;
string $twoWayVtx[]=`ls -sl -fl`;
int $twoWayVtxInside;
for ($a=0;$a<2;$a++)
	{
	select $twoWayVtx[$a];
	for ($y=0;$y<10;$y++)
		{
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $mainVtxs;
		$tempString=`ls -sl -fl`;
		for ($i=0;$i<size($tempString);$i++)
			if (`stringArrayCount $tempString[$i] $innerVtxs`)
				{
				$twoWayVtxInside=$a;
				break;
				}
		}
	}
select $twoWayVtx[$twoWayVtxInside];
int $numSelVtx,$prevNumSelVtx;
$prevNumSelVtx=1;
for ($i=0;$i<100;$i++)
	{
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $mainVtxs $innerVtxs;
	$numSelVtx=size(`ls -sl -fl`);
	if ($numSelVtx==$prevNumSelVtx)
		break;
	$prevNumSelVtx=$numSelVtx;
	}
$tempString=`ls -sl -fl`;
select `asobjSetCast "" $tempString EyeLidRegion`;
//changed Hammer for flood once, now chaning back..And back again.
asSmoothFlood faceHeadJoint "" 100;
//weightHammerVerts;
//Hardening these inside-eyeLid-weights.
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$transforms=`skinPercent -ignoreBelow 0.001 -q -t EyeLidSC $tempString[$i]`;
	$values=`skinPercent -ignoreBelow 0.001 -q -v EyeLidSC $tempString[$i]`;
	$maxValue=0;
	for ($z=0;$z<size($transforms);$z++)
		{
		if ($values[$z]>$maxValue)
			{
			$maxValue=$values[$z];
			$maxTransform=$transforms[$z];
			}
		}
	skinPercent -tv $maxTransform 1 EyeLidSC $tempString[$i];
	}

select $twoWayVtx[!$twoWayVtxInside];
$prevNumSelVtx=0;
int $numSelVtx,$prevNumSelVtx;
$prevNumSelVtx=1;
for ($i=0;$i<100;$i++)
	{
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $mainVtxs $outerVtxs;
	$numSelVtx=size(`ls -sl -fl`);
	if ($numSelVtx==$prevNumSelVtx)
		break;
	$prevNumSelVtx=$numSelVtx;
	}
$tempString=`ls -sl -fl`;
select `asobjSetCast "" $tempString EyeLidRegion`;
//latest findings is for hammer to work better on outside-eyeLid
weightHammerVerts;
/*
asSmoothFlood faceHeadJoint "" 100;

//Hardening these outside-eyeLid-weights. (harden to 2infl)
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$transforms=`skinPercent -ignoreBelow 0.001 -q -t EyeLidSC $tempString[$i]`;
	$values=`skinPercent -ignoreBelow 0.001 -q -v EyeLidSC $tempString[$i]`;
	$maxValue=0;
	for ($z=0;$z<size($transforms);$z++)
		{
		if ($values[$z]>$maxValue)
			{
			$maxValue=$values[$z];
			$maxTransform=$transforms[$z];
			}
		}
	$maxValue2=0;
	for ($z=0;$z<size($transforms);$z++)
		{
		if ($values[$z]>$maxValue2 && $transforms[$z]!=$maxTransform)
			{
			$maxValue2=$values[$z];
			$maxTransform2=$transforms[$z];
			}
		}
	skinPercent -tv $maxTransform 1 EyeLidSC $tempString[$i];
	skinPercent -tv $maxTransform2 $maxValue2 EyeLidSC $tempString[$i];
	}
*/
copySkinWeights -ss EyeLidSC -ds EyeLidSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//delete EyeLidSkinCage_R;
delete upperEyeLidMainCurve1_R upperEyeLidOuterCurve1_R lowerEyeLidMainCurve1_R lowerEyeLidOuterCurve1_R;
delete upperEyeLidMainCurve1_L upperEyeLidOuterCurve1_L lowerEyeLidMainCurve1_L lowerEyeLidOuterCurve1_L;
select $eyeLidRegionVtxs;

blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` EyeLidRegion 1 asFaceBS;
setAttr asFaceBS.EyeLidRegion 1;

progressBar -e -ep $gMainProgressBar;
select $eyeLidRegionVtxs;
}

global proc asSetupEyeRegion ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`;
string $tempString[];

select -cl;
joint -n EyeRegion_R;
select -cl;
joint -n EyeRegion_L;
parent EyeRegion_R EyeRegion_L FaceDeformationFollowHead;
setAttr EyeRegion_R.segmentScaleCompensate 0;
setAttr EyeRegion_L.segmentScaleCompensate 0;
/*
duplicate -n EyeRegion EyeLidRegion;
setAttr RegionDeformations.v 1;
setAttr EyeRegion.v 1;
sets -e -forceElement initialShadingGroup EyeRegion;
*/
string $side;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	
	$tempString=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r ($scale/30.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
	rename $tempString[0] ("FKEyeRegion"+$side);
	sets -add FaceControlSet ("FKEyeRegion"+$side);
	setAttr ("FKEyeRegion"+$side+"Shape.overrideEnabled") 1;
	setAttr ("FKEyeRegion"+$side+"Shape.overrideColor") 13;
	createNode -n ("FKOffsetEyeRegion"+$side) transform;
	parent ("FKOffsetEyeRegion"+$side) FaceMotionFollowHead;
	parent ("FKEyeRegion"+$side) ("FKOffsetEyeRegion"+$side);
	$posA=`xform -q -ws -t FitEyeBall`;
	xform -ws -t ($posA[0]*$b) $posA[1] $posA[2] ("FKOffsetEyeRegion"+$side);
	move -r ($posA[0]*$b*1.5) 0 0 ("FKEyeRegion"+$side+".cv[0:7]");
	parentConstraint ("FKEyeRegion"+$side) ("EyeRegion"+$side);
	scaleConstraint ("FKEyeRegion"+$side) ("EyeRegion"+$side);
	connectAttr ("EyeRegion"+$side+".t") ("Eye"+$side+".t");
	connectAttr ("EyeRegion"+$side+".s") ("EyeBallScaleMult"+$side+".input2");
	}
/*
string $insideVtxsOnEyeRegionMesh[];
select eyeLidVtxs;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	$insideVtxsOnEyeRegionMesh[$i]=`substitute $geometry $tempString[$i] EyeRegion`+" ";
*/
/*
select $headJoint EyeRegion_R EyeRegion_L EyeRegion;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] EyeRegionSC;
skinPercent -tv $headJoint 1 EyeRegionSC EyeRegion.vtx[0:99999];
select $insideVtxsOnEyeRegionMesh;
skinPercent -tv EyeRegion_R 1 EyeRegionSC `ls -sl`;
*/
skinCluster -e -wt 0 -ai EyeRegion_R -ai EyeRegion_L $skinCluster;
select eyeLidVtxs;
skinPercent -tv EyeRegion_R 1 $skinCluster `ls -sl`;

for ($i=0;$i<5;$i++)
	GrowPolygonSelectionRegion;
select -d eyeLidVtxs;
weightHammerVerts;
copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
/*
blendShape -e -tc 0 -t $geometry `getAttr -s regionsBS.w` EyeRegion 1 regionsBS;
setAttr regionsBS.EyeRegion 1;

setAttr EyeRegion.v 0;
*/
select -cl;
}

global proc asFaceMirroring ()
{
string $mirrorCtrls[]={"Lip6","cheek","upperLip3","lowerLip3","noseCorner","cheekRaiser"};
string $trs[]={"t","r","s"};
for ($i=0;$i<size($mirrorCtrls);$i++)
	for ($y=0;$y<size($trs);$y++)
		{
		createNode -n ("poseMirror"+$mirrorCtrls[$i]+$trs[$y]+"MultiplyDivide") multiplyDivide;
		connectAttr ($mirrorCtrls[$i]+"_R."+$trs[$y]) ("poseMirror"+$mirrorCtrls[$i]+$trs[$y]+"MultiplyDivide.input1");
		if ($trs[$y]=="t") setAttr -type float3 ("poseMirror"+$mirrorCtrls[$i]+$trs[$y]+"MultiplyDivide.input2") -1 1 1;
		if ($trs[$y]=="r") setAttr -type float3 ("poseMirror"+$mirrorCtrls[$i]+$trs[$y]+"MultiplyDivide.input2") 1 -1 -1;
		connectAttr ("poseMirror"+$mirrorCtrls[$i]+$trs[$y]+"MultiplyDivide.output") ($mirrorCtrls[$i]+"_L."+$trs[$y]);
		}
refresh;
}

global proc asSaveTarget (string $target, int $center)
{
//string $geometry=`textField -q -tx asFaceGeometryTextField`;

if ($center)
	{
	duplicate -n ($target+"_C") tempTarget;
//	parent ($target+"_C") faceTargets;
	setAttr ($target+"_C.v") 0;
	return;
	}

string $mirrorCtrls[]={"Lip6","cheek","upperLip3","lowerLip3","noseCorner","cheekRaiser"};
string $trs[]={"t","r","s"};
for ($i=0;$i<size($mirrorCtrls);$i++)
	for ($y=0;$y<size($trs);$y++)
		delete ("poseMirror"+$mirrorCtrls[$i]+$trs[$y]+"MultiplyDivide");

for ($i=0;$i<size($mirrorCtrls);$i++)
	{
	setAttr -type float3 ($mirrorCtrls[$i]+"_L.t") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_L.r") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_L.s") 1 1 1;
	}

duplicate -n ($target+"_R") tempTarget;
//parent ($target+"_R") faceTargets;
setAttr ($target+"_R.v") 0;

asFaceMirroring;

for ($i=0;$i<size($mirrorCtrls);$i++)
	{
	for ($y=0;$y<size($trs);$y++)
		delete ("poseMirror"+$mirrorCtrls[$i]+$trs[$y]+"MultiplyDivide");
	setAttr -type float3 ($mirrorCtrls[$i]+"_L.s") 1 1 1;
	}
for ($i=0;$i<size($mirrorCtrls);$i++)
	{
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.t") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.r") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.s") 1 1 1;
	}

duplicate -n ($target+"_L") tempTarget;
//parent ($target+"_L") faceTargets;
setAttr ($target+"_L.v") 0;

asFaceMirroring;
}

global proc asSetupSmile ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $pos[];
setAttr "ControlsSetup.visibility" 1;
select tempTarget $geometry;
$tempString=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}

int $upperEyeLidMainNumCVs=`getAttr upperEyeLidMainCurve.spans`+1;
int $upperLipMainNumCVs=`getAttr upperLipMainCurve.spans`+1;
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
createNode -n tempXform1 transform;
$pos=`xform -q -ws -t upperEyeLidMainCurve.cv[$upperEyeLidMainNumCVs]`;
xform -ws -t $pos[0] $pos[1] $pos[2] tempXform1;
createNode -n tempXform2 transform;
$pos=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
xform -ws -t $pos[0] $pos[1] $pos[2] tempXform2;

createNode -n SmileMuscle transform;
//delete `pointConstraint JawPivot EyeLidMain6 SmileMuscle`;
delete `pointConstraint JawPivot tempXform1 SmileMuscle`;
//pointConstraint LipOuter6 SmileMuscle Lip6_R;
pointConstraint tempXform2 SmileMuscle Lip6_R;
setAttr Lip6_R_pointConstraint1.SmileMuscleW1 0.33;
delete Lip6_R_pointConstraint1;
setAttr Lip6_R.rz -25;

setAttr cheek_R.ty (`getAttr Lip6_R.ty`/2.0);
setAttr cheek_R.tz (`getAttr Lip6_R.ty`/2.0);
setAttr cheekRaiser_R.ty (`getAttr Lip6_R.ty`/2.0);

asFaceMirroring;
delete SmileMuscle tempXform1 tempXform2;
select Lip6_R;
}

global proc asSetupFrown ()
{
float $scale=`asFaceGetScale`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;

asSaveTarget mouth_smile 1;
asSaveTarget mouth_smile 0;

float $smileLip6Pos[]=`getAttr Lip6_R.t`;
setAttr -type float3 Lip6_R.t 0 ($scale/-20.0) ($scale/-40.0) Lip6_R;
setAttr Lip6_R.rz 25;
select Lip6_R;
}

global proc asSetupCheekRaiser ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;

asSaveTarget mouth_frown 0;

float $smileLip6Pos[]=`getAttr Lip6_R.t`;
string $mirrorCtrls[]={"Lip6","cheek","upperLip3","lowerLip3","noseCorner","cheekRaiser"};
string $trs[]={"t","r","s"};
for ($i=0;$i<size($mirrorCtrls);$i++)
	{
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.t") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.r") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.s") 1 1 1;
	}

createNode -n tempXform1 transform;
createNode -n tempXform2 -p tempXform1 transform;
createNode -n tempXform3 -p tempXform2 transform;
asAlign tempXform1 Eye_R 1 1 0 0;
asAlign tempXform3 cheekRaiser_R 1 1 0 0;
setAttr tempXform2.rz -20;
float $pos[]=`xform -q -ws -t tempXform3`;
float $rot[]=`xform -q -ws -ro tempXform3`;
xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] cheekRaiser_R;
delete tempXform1;
select cheekRaiser_R;
}

/*
global proc asSetupCheekPuff ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`;

asSaveTarget cheek_raiser 0;

string $mirrorCtrls[]={"Lip6","cheek","upperLip3","lowerLip3","noseCorner","cheekRaiser"};
for ($i=0;$i<size($mirrorCtrls);$i++)
	{
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.t") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.r") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.s") 1 1 1;
	}
setAttr -type float3 cheek_R.t ($scale/-20.0) 0 ($scale/20.0);
}

global proc asSetupCheekSuck ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`;

asSaveTarget cheek_puff 0;

string $mirrorCtrls[]={"Lip6","cheek","upperLip3","lowerLip3","noseCorner","cheekRaiser"};
for ($i=0;$i<size($mirrorCtrls);$i++)
	{
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.t") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.r") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.s") 1 1 1;
	}
setAttr -type float3 cheek_R.t ($scale/20.0) 0 ($scale/-20.0);
}
*/
/*
global proc asSetupOoo ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`;
float $posA[],$posB[];

asSaveTarget cheek_suck;

string $mirrorCtrls[]={"Lip6","cheek","upperLip3","lowerLip3","noseCorner","cheekRaiser"};
for ($i=0;$i<size($mirrorCtrls);$i++)
	{
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.t") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.r") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.s") 1 1 1;
	}

setAttr FKLips_M.sx 0.33;
setAttr ctrlMouth_M.ty -1;
$posA=`xform -q -ws -t upperLipOuter0`;
$posB=`xform -q -ws -t LipOuter6`;
setAttr Lip6_R.tz (($posA[2]-$posB[2])/2.0);

}
*/
/*
global proc asSetupLipRollOut ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`;

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;
setAttr ctrlMouth_M.ty 0;
setAttr CurrentTarget.v 0;

//save OO
duplicate -n mouth_oo_C $geometry;
parent mouth_oo_C faceTargets;
setAttr mouth_oo_C.v 0;

delete asFaceBSTEMP SmileSoftModAHandle SmileSoftModBHandle;
setAttr FKLips_M.sx 1;
setAttr -type float3 Lip6_R.t 0 0 0;

setAttr upperLip0_M.rx -85;
setAttr upperLip0_M.sy 0.25;
setAttr upperLip0_M.ty ($scale/85.0);
setAttr upperLip0_M.tz ($scale/30.0);
setAttr lowerLip0_M.rx 85;
setAttr lowerLip0_M.sy 0.25;
setAttr lowerLip0_M.ty ($scale/-85.0);
setAttr lowerLip0_M.tz ($scale/30.0);
}

global proc asSetupLipRollIn ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $scale=`asFaceGetScale`;

//save lipRollOut
select $geometry CurrentTarget;
$tempString=`blendShape -frontOfChain`;
rename $tempString asFaceBSTEMP;
setAttr asFaceBSTEMP.w[0] 1;
select CurrentTarget;
DeleteHistory;
duplicate -n mouth_pucker_C CurrentTarget;
parent mouth_pucker_C faceTargets;

xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 upperLip0_M;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 lowerLip0_M;

setAttr upperLip0_M.rx 85;
setAttr upperLip0_M.sz 0.15;
setAttr upperLip0_M.ty ($scale/-100.0);
setAttr lowerLip0_M.rx -85;
setAttr lowerLip0_M.sz 0.15;
setAttr lowerLip0_M.ty ($scale/100.0);
}
*/

global proc asFaceCheekAndMouthShapes ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $posA[],$posB[],$posC[];
float $scale=`asFaceGetScale`;
string $tempString[];

asSaveTarget cheek_raiser 0;

//auto-gen cheek puff & suck
$posA=`xform -q -ws -t cheek`;
$posB=`xform -q -ws -t noseCorner`;
float $falloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
duplicate -n cheekTemplate tempTarget;
//parent cheekTemplate faceTargets;
setAttr cheekTemplate.v 0;
select -r cheekTemplate;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] tempSoftMod`;
string $softModHandle=`rename $tempString[1] tempSoftModHandle`;
setAttr  tempSoftMod.falloffRadius $falloffRadius;
setAttr tempSoftMod.falloffMode 0;
setAttr -type float3 tempSoftModHandleShape.origin $posA[0] $posA[1] $posA[2];
setAttr tempSoftMod.falloffCenter $posA[0] $posA[1] $posA[2];
xform -piv $posA[0] $posA[1] $posA[2] tempSoftModHandle;
//cheek_puff_R
xform -os -t ($scale/-40.0) 0 ($scale/20.0) tempSoftModHandle;
duplicate -n cheek_puff_R cheekTemplate;
//cheek_suck_R
xform -os -t ($scale/40.0) 0 ($scale/-20.0) tempSoftModHandle;
setAttr  tempSoftMod.falloffRadius ($falloffRadius/2.0);
duplicate -n cheek_suck_R cheekTemplate;
//cheek_suck_L
setAttr -type float3 tempSoftModHandleShape.origin ($posA[0]*-1) $posA[1] $posA[2];
setAttr tempSoftMod.falloffCenter ($posA[0]*-1) $posA[1] $posA[2];
setAttr tempSoftModHandle.tx (`getAttr tempSoftModHandle.tx`*-1);
duplicate -n cheek_suck_L cheekTemplate;
//cheek_puff_L
xform -os -t ($scale/40.0) 0 ($scale/20.0) tempSoftModHandle;
setAttr  tempSoftMod.falloffRadius $falloffRadius;
duplicate -n cheek_puff_L cheekTemplate;
delete cheekTemplate;

//auto-gen mouth_narrow
$posA=`xform -q -ws -t upperLip0_M`;
$posB=`xform -q -ws -t lowerLip0_M`;
$posC=`xform -q -ws -t Lip6_R`;
xform -ws -t (($posA[0]+$posB[0]+$posC[0])/3.0) (($posA[1]+$posB[1]+$posC[1])/3.0) (($posA[2]+$posB[2]+$posC[2])/3.0) Lip6_R;
asSaveTarget mouth_narrow 1;
asSaveTarget mouth_narrow 0;

//auto-gen mouth_wide
$posA=`xform -q -ws -t upperLip0_M`;
$posB=`xform -q -ws -t lowerLip0_M`;
$posC=`xform -q -ws -t Lip6_R`;
xform -ws -t ($posC[0]+$posC[0]) ($posC[1]) ($posC[2]-($posA[2]-$posC[2])) -ro 0 -30 0 Lip6_R;
rotate -r -os 0 -30 0 ;
setAttr cheek_R.tx ($scale/-25.0);
//asSaveTarget mouth_wide 1;
asSaveTarget mouth_wide 0;

//auto-gen nose_wrinkler_R, nose_dilator_R, nose_compressor_R
xform -os -t 0 ($scale/20.0) 0 -ro 0 0 0 -s 1 1 1 noseCorner_R;
asSaveTarget nose_wrinkler 0;
xform -os -t ($scale/-60.0) 0 0 -ro 0 0 0 -s 1 1 1 noseCorner_R;
asSaveTarget nose_dilator 0;
xform -os -t ($scale/60.0) 0 0 -ro 0 0 0 -s 1 1 1 noseCorner_R;
asSaveTarget nose_compressor 0;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 noseCorner_R;

string $mirrorCtrls[]={"Lip6","cheek","upperLip3","lowerLip3","noseCorner","cheekRaiser"};
string $trs[]={"t","r","s"};
for ($i=0;$i<size($mirrorCtrls);$i++)
	{
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.t") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.r") 0 0 0;
	setAttr -type float3 ($mirrorCtrls[$i]+"_R.s") 1 1 1;
	refresh;
	for ($y=0;$y<size($trs);$y++)
		delete ("poseMirror"+$mirrorCtrls[$i]+$trs[$y]+"MultiplyDivide");
	}
}

global proc asFaceFinish ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
if (`objExists foreHeadMesh`)
	delete foreHeadMesh;
//If "keepTweakedBlendShapes", then both keepTweakedBlendShapes & faceTargets must `stay`, to get the inMesh updaet working.
if (`objExists faceTargets` && !`objExists keepTweakedBlendShapes`)
 delete faceTargets;
if (`objExists tempLocFlip`)
	delete tempLocFlip;

setAttr -l 1 ClusterSetup.v 0;
setAttr -l 1 LipSetup.v 0;

//Also update buildPose
select `sets -q FaceControlSet`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -k -shortNames $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controlSetMembers[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
setAttr -type "string" faceBuildPose.udAttr $setAttrCmd;

//Wrapdeformer might have turned off these:
setAttr ($geometry+".castsShadows") 1;
setAttr ($geometry+".receiveShadows") 1;
setAttr ($geometry+".motionBlur") 1;
setAttr ($geometry+".primaryVisibility") 1;
setAttr ($geometry+".smoothShading") 1;
setAttr ($geometry+".visibleInReflections") 1;
setAttr ($geometry+".visibleInRefractions") 1;
setAttr ($geometry+".doubleSided") 1;


//update AllSet
select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
select -d allBeforeFaceBuild;
sets -add FaceAllSet `ls -sl`;

sets -rm FaceBuildingSets allBeforeFaceBuild;
delete `sets -q FaceBuildingSets`;

setAttr -l 1 FaceDeformationSystem.v 0;

cycleCheck -e on;

evalDeferred ("sets -clear allBeforeFaceBuild;delete allBeforeFaceBuild;");

select -cl;
print ("// Advanced Face created\n");
}

global proc asFaceReSelect (string $section, string $part)
{
string $faceFitNode="FaceFit"+$section+$part;
if (`objExists $faceFitNode`)
	if (`attributeExists selection $faceFitNode`)
		eval ("select "+`getAttr ($faceFitNode+".selection")`);
print ("// ReSelecting: "+$section+" : "+$part+"\n");
}

global proc asAdvancedEyeBrowPartA ()
{
global string $gMainProgressBar;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower,$lidJoint,$eyeJoint,$vtx;
string $tempString[],$tempString2[],$tempString3[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;

setAttr ctrlEye_L.tx 0;setAttr ctrlEye_L.ty 0;
setAttr ctrlEye_R.tx 0;setAttr ctrlEye_R.ty 0;
setAttr ctrlEye_L.blink 0;setAttr ctrlEye_R.blink 0;

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;
setAttr EyeLidRegion.v 0;

int $eyeBrowOuterNumCVs=`getAttr EyeBrowOuterCurve.spans`+1;
int $upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`+1;
int $upperEyeLidMainNumCVs=`getAttr upperEyeLidMainCurve.spans`+1;

//create curves around forhead region
/*
$curveCmd="curve -d 3 ";
for ($i=0;$i<7;$i++)
	{
	$pos=`xform -q -ws -t ("EyeBrowOuter"+$i)`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] foreHeadBorderCurve1;
*/
duplicate -n foreHeadBorderCurve1 EyeBrowOuterCurve;
$tempString=`listRelatives -s foreHeadBorderCurve1`;
rename $tempString[0] foreHeadBorderCurveShape1;
parent -w foreHeadBorderCurve1;
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t EyeBrowOuterCurve.cv[$eyeBrowOuterNumCVs]`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;
//delete `pointConstraint EyeBrowOuter6 EyeLidOuter6 tempGeoSnapLoc`;
$posA=$pos;
$posB=`xform -q -ws -t upperEyeLidOuterCurve.cv[$upperEyeLidOuterNumCVs]`;
xform -ws -t (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$pos=`xform -q -ws -t upperEyeLidOuterCurve.cv[$upperEyeLidOuterNumCVs]`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t upperEyeLidMainCurve.cv[$upperEyeLidMainNumCVs]`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] foreHeadBorderCurve2;

duplicate -n foreHeadBorderCurve3 upperEyeLidMainCurve;
parent -w foreHeadBorderCurve3;
$tempString=`listRelatives -s foreHeadBorderCurve3`;
rename $tempString[0] "foreHeadBorderCurveShape3";
reverseCurve -ch 0 -rpo 1 "foreHeadBorderCurve3";

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t upperEyeLidMainCurve.cv[0]`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t upperEyeLidOuterCurve.cv[0]`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $pos[1] $pos[2] tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
for($i=0;$i<20;$i++) setAttr tempGeoSnapLoc.tx 0;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] foreHeadBorderCurve4;

select -r foreHeadBorderCurve1 foreHeadBorderCurve2 foreHeadBorderCurve3 foreHeadBorderCurve4 ;
}

global proc asAdvancedEyeBrowPartB ()
{
global string $gMainProgressBar;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower,$lidJoint,$eyeJoint,$vtx;
string $tempString[],$tempString2[],$tempString3[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;

string $deleteObjs[]={"foreheadGeo","foreHeadVtxs","foreHeadBorderVtxs"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

createNode -n NClothObjects transform;

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;

//select vtx`s from forehead region curves
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempPointOnCurveInfo.position tempLoc.t;

asCreateSamplerMesh $geometry;
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr -f tempLoc.worldPosition closestSampler.inPosition;

select -cl;
string $borderVtxs[];
progressBar -e -st ("Setup EyeBrow") -bp -ii 0 -min 0 -max (98*2*4) $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	setAttr tempLocFlip.sx $b;
	for ($a=1;$a<5;$a++)
		{
		connectAttr -f ("foreHeadBorderCurveShape"+$a+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		for ($i=0;$i<99;$i++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			setAttr tempPointOnCurveInfo.parameter ($i*0.01);
//			refresh;
			$vtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
			if (!`stringArrayCount $vtx $borderVtxs`)
				{
				$borderVtxs[size($borderVtxs)]=$vtx;
				select -add $vtx;
				}
			}
		}
	}
//ensure complete loop
select $borderVtxs;
asEnsureSelectionCompleteLoop;
$borderVtxs=`ls -sl -fl`;
sets -n foreHeadBorderVtxs;
sets -add FaceBuildingSets foreHeadBorderVtxs;

//Find centerForHead vtx to grow from
$posA=`xform -q -ws -t foreHeadBorderCurve1.cv[0]`;
$posB=`xform -q -ws -t foreHeadBorderCurve4.cv[2]`;
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) tempGeoSnapLoc;
setAttr -l 1 tempGeoSnapLoc.tx;delete `geometryConstraint $geometry tempGeoSnapLoc`;
setAttr -l 0 tempGeoSnapLoc.tx;setAttr tempGeoSnapLoc.tx 0;
connectAttr -f tempGeoSnapLoc.worldPosition closestSampler.inPosition;
string $foreheadStartVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete tempGeoSnapLoc tempPointOnCurveInfo samplerMesh closestSampler;

//grow until forehead region, to create separate forhead object;
select $foreheadStartVtx;
for ($i=0;$i<30;$i++)
{
ConvertSelectionToEdges;
ConvertSelectionToVertices;
select -d `sets -q foreHeadBorderVtxs`;
}
select -add $borderVtxs;
sets -n foreHeadVtxs;
sets -add FaceBuildingSets foreHeadVtxs;
select -d $borderVtxs;
ConvertSelectionToFaces;
string $forheadFaces[]=`ls -sl`;

duplicate -n foreheadGeo $geometry;
asLockAttr foreheadGeo 0 0 0 0;
$tempString=`listRelatives -p foreheadGeo`;
parent foreheadGeo NClothObjects;
$tempString=`listRelatives -s foreheadGeo`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
select foreheadGeo.f[0:99999];
for ($i=0;$i<size($forheadFaces);$i++)
	select -d (`substitute $geometry $forheadFaces[$i] foreheadGeo`);
delete;

if (`objExists foreheadGeo`)
	setAttr foreheadGeo.v 1;
select -r foreHeadBorderCurve1 foreHeadBorderCurve2 foreHeadBorderCurve3 foreHeadBorderCurve4 ;

if (`objExists "Group"`) setAttr "Group.v" 1;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
progressBar -e -ep $gMainProgressBar;
}

global proc asAdvancedEyeBrowPartC ()
{
global string $gMainProgressBar;
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower,$lidJoint,$eyeJoint,$vtx;
string $tempString[],$tempString2[],$tempString3[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $borderVtxs[]=`sets -q foreHeadBorderVtxs`;

for ($a=1;$a<5;$a++)
	delete ("foreHeadBorderCurve"+$a);

//ncloth
select foreheadGeo;
$tempString=`createNCloth 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] foreheadNCloth;
setAttr foreheadNCloth.ignoreSolverGravity 1;
setAttr foreheadNCloth.damp 10;
setAttr foreheadNCloth.stretchResistance 0;
setAttr foreheadNClothShape.selfCollide 0;
setAttr foreheadNCloth.selfCollisionFlag 4;
setAttr foreheadNCloth.stretchResistance 5;
setAttr foreheadNCloth.compressionResistance 3;
setAttr foreheadNCloth.bendResistance 3;

select -r foreheadGeo.vtx[0:99999];
refresh;
//someTimes polySelectConstraint -pp 3 fails, ensuring -t seem to fix
polySelectConstraint -t 1 -pp 3;
$tempString=`createNConstraint transform 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] tempNClothConstraint1;

int $eyeBrowOuterNumCVs=`getAttr EyeBrowOuterCurve.spans`+1;
int $eyeBrowMainNumCVs=`getAttr EyeBrowMainCurve.spans`+1;
int $upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`+1;
int $upperEyeLidMainNumCVs=`getAttr upperEyeLidMainCurve.spans`+1;

$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t EyeBrowOuterCurve.cv[$eyeBrowOuterNumCVs]`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];

$posA=`xform -q -ws -t EyeBrowOuterCurve.cv[$eyeBrowOuterNumCVs]`;
$posB=`xform -q -ws -t EyeBrowMainCurve.cv[$eyeBrowMainNumCVs]`;
//spaceLocator -n tempGeoSnapLoc;
//delete `pointConstraint EyeBrowOuter6 EyeBrowMain6 tempGeoSnapLoc`;
//xform -ws -t (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) tempGeoSnapLoc;
//$pos=`xform -q -ws -t tempGeoSnapLoc`;
$curveCmd+=" -p "+(($posA[0]+$posB[0])/2.0)+" "+(($posA[1]+$posB[1])/2.0)+" "+(($posA[2]+$posB[2])/2.0);
//delete tempGeoSnapLoc;

for($i=$eyeBrowMainNumCVs-1;$i>-1;$i--)
	{
	$pos=`xform -q -ws -t EyeBrowMainCurve.cv[$i]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
/*
$pos=`xform -q -ws -t EyeBrowMain6`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain5`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain4`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain3`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain2`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain1`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowMain0`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
*/
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $pos[1] $pos[2] tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
for($i=0;$i<20;$i++) setAttr tempGeoSnapLoc.tx 0;
$pos=`xform -q -ws -t tempGeoSnapLoc`;$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2];
delete tempGeoSnapLoc;
$pos=`xform -q -ws -t EyeBrowMainCurve.cv[0]`;$curveCmd+=" -p "+($pos[0]*-1)+" "+$pos[1]+" "+$pos[2];

$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] EyeBrowMainCurve2;

//rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.0001 EyeBrowMainCurve2;

duplicate -n EyeBrowMainCurveWrapped EyeBrowMainCurve;
parent -w EyeBrowMainCurveWrapped;
select -r EyeBrowMainCurveWrapped;
select -add EyeBrowMainAnimateFitCurve;
$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "1", "0" }`;
//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}


int $index=2;
for($i=$eyeBrowMainNumCVs-1;$i>-1;$i--)
	{
	createNode -n ("tempPointOnCurveInfo"+$i) pointOnCurveInfo;
	connectAttr -f EyeBrowMainCurveWrappedShape.worldSpace[0] ("tempPointOnCurveInfo"+$i+".inputCurve");
	setAttr ("tempPointOnCurveInfo"+$i+".parameter") $i;
	connectAttr ("tempPointOnCurveInfo"+$i+".result.position") EyeBrowMainCurve2.cv[$index];
	$index++;
	}

/*
connectAttr EyeBrowMainCurve.controlPoints[0] EyeBrowMainCurve2.cv[8];
connectAttr EyeBrowMainCurve.controlPoints[1] EyeBrowMainCurve2.cv[7];
connectAttr EyeBrowMainCurve.controlPoints[2] EyeBrowMainCurve2.cv[6];
connectAttr EyeBrowMainCurve.controlPoints[3] EyeBrowMainCurve2.cv[5];
connectAttr EyeBrowMainCurve.controlPoints[4] EyeBrowMainCurve2.cv[4];
connectAttr EyeBrowMainCurve.controlPoints[5] EyeBrowMainCurve2.cv[3];
connectAttr EyeBrowMainCurve.controlPoints[6] EyeBrowMainCurve2.cv[2];
*/
circle -n EyeBrowCircle -c 0 0 0 -nr 1 0 0 -sw 360 -r ($scale/100.0) -d 3 -ut 0 -tol 0.00393701 -s 8 -ch 1;
extrude -n EyeBrowExtrude -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 1 EyeBrowCircle EyeBrowMainCurve2;
//nurbsToPoly -n EyeBrowMainPoly -mnd 1  -ch 1 -f 2 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 2 -un 20 -vt 2 -vn 256 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 EyeBrowExtrude;
nurbsToPoly -n EyeBrowMainPoly -mnd 1  -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 EyeBrowExtrude;

//$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r ($scale/200.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
//rename $tempString[0] EyeBrowProfileMain;
//extrude -n EyeBrowCylinderMain -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 1 EyeBrowProfileMain EyeBrowMainCurve;

nurbsToPoly -n eyeBrowPoly -mnd 1  -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 8 -vt 1 -vn 8 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 EyeBrowCylinderMain;
select -r foreheadGeo EyeBrowMainPoly;
$tempString=`createNConstraint pointToPoint 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] tempNClothRigid1;
$tempString2=`listRelatives -p $tempString[1]`;
rename $tempString2[0] tempNClothConstraint2;

setAttr tempNClothConstraintShape2.constraintMethod 2;
setAttr tempNClothConstraintShape2.connectionMethod 1;
float $posA[]=`xform -q -ws -t EyeBrowCylinderMain.cv[3][3]`;
float $posB[]=`xform -q -ws -t EyeBrowCylinderMain.cv[7][3]`;
float $browWidth=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`*1.5;
setAttr tempNClothConstraintShape2.maxDistance ($browWidth/2.0);
duplicate -n foreheadGeoSlideOn foreheadGeo;
setAttr foreheadGeoSlideOn.v 0;
select -r foreheadGeo.vtx[0:99999] ;
select -add foreheadGeoSlideOn;
$tempString=`createNConstraint slideOnSurface 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] tempNRigid;
$tempString2=`listRelatives -p $tempString[1]`;
rename $tempString2[0] tempdynamicConstraint;
setAttr tempdynamicConstraintShape.collideWidthScale 0;

//Find nearby vtx and remove these from the slideConstraint, to have smoother the main eyeBrow part
select -r foreheadGeo;
string $nearBrowVtxs[];
for ($i=0;$i<56;$i++)
	{
	$pos=`xform -q -ws -t eyeBrowPoly.vtx[$i]`;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 $browWidth -dp $pos[0] $pos[1] $pos[2];
	select -add $nearBrowVtxs;
	$nearBrowVtxs=`ls -sl`;
	}
polySelectConstraint -m 0;
select $nearBrowVtxs;
select -add tempdynamicConstraint;
dynamicConstraintMembership "remove";

string $parentObjs[]={"EyeBrowProfileMain","EyeBrowMainCurveWrapped","nucleus1","foreheadNCloth","tempNClothConstraint1","EyeBrowMainCurve2","EyeBrowCircle","EyeBrowExtrude",
		"EyeBrowMainPoly","eyeBrowPoly","tempNClothRigid1","tempNClothConstraint2","tempNRigid","tempdynamicConstraint"};
for ($i=0;$i<size($parentObjs);$i++)
	if (`objExists $parentObjs[$i]`)
		parent $parentObjs[$i] NClothObjects;

if (`objExists tempNearestPointOnCurve`)
	delete tempNearestPointOnCurve;
currentTime -1;
select -cl;
}

global proc asNClothSim ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;

string $faceTargets[]={"brow_raiser_R","brow_lowerer_R","brow_innerRaiser_R","brow_innerLowerer_R","brow_squeeze_R","brow_outerRaiser_R"};
if (`objExists foreheadGeo`)
	asFaceSkinSim $faceTargets foreheadGeo;//nCloth sim
if (`objExists "Group"`) setAttr "Group.v" 1;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;
if (`objExists foreheadGeo`)
	{
	select foreheadGeo;
	DeleteHistory;
//	delete foreheadGeoSlideOn tempdynamicConstraint foreheadGeo;
	}
//delete tempNClothConstraint2 tempNClothRigid1 eyeBrowPoly EyeBrowMainPoly EyeBrowExtrude EyeBrowCircle EyeBrowMainCurve2;
delete NClothObjects;
}

global proc asDetectLip ()
{
string $tempString[];

//$FaceFitLipOuterVtxs
duplicate -n tempUpperLipOuterCurve upperLipOuterCurve;setAttr tempUpperLipOuterCurve.sx -1;
duplicate -n tempLowerLipOuterCurve lowerLipOuterCurve;setAttr tempLowerLipOuterCurve.sx -1;
eval ("select "+`asGetFaceFitSelection FaceFitLipOuterCurve`);
string $FaceFitLipOuterVtxs[]=`ls -sl -fl`;
delete tempUpperLipOuterCurve tempLowerLipOuterCurve;

//$FaceFitLipInnerVtxs
duplicate -n tempUpperLipInnerCurve upperLipInnerCurve;setAttr tempUpperLipInnerCurve.sx -1;
duplicate -n tempLowerLipInnerCurve lowerLipInnerCurve;setAttr tempLowerLipInnerCurve.sx -1;
eval ("select "+`asGetFaceFitSelection FaceFitLipInnerCurve`);
string $FaceFitLipInnerVtxs[]=`ls -sl -fl`;
delete tempUpperLipInnerCurve tempLowerLipInnerCurve;

//$FaceFitLipMainVtxs
duplicate -n tempUpperLipMainCurve upperLipMainCurve;setAttr tempUpperLipMainCurve.sx -1;
duplicate -n tempLowerLipMainCurve lowerLipMainCurve;setAttr tempLowerLipMainCurve.sx -1;
eval ("select "+`asGetFaceFitSelection FaceFitLipMainCurve`);
string $FaceFitLipMainVtxs[]=`ls -sl -fl`;
delete tempUpperLipMainCurve tempLowerLipMainCurve;

createNode -n lipArea objectSet;
sets -add FaceBuildingSets lipArea;

select $FaceFitLipMainVtxs;
for ($i=0;$i<10;$i++)
	{
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $FaceFitLipOuterVtxs $FaceFitLipInnerVtxs;
	}
select -add $FaceFitLipOuterVtxs $FaceFitLipInnerVtxs;
sets -add lipArea `ls -sl`;
}

global proc asAdvancedJaw ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
float $scale=`asFaceGetScale`;
float $pos[],$pos2[],$posA[],$posB[];
string $tempString[];

//Existing Jaw ?
if (`objExists Jaw_M`)
	error "Jaw_M already exists, can not build new Jaw, remove old jaw first";

createNode -n JawSetup -p FaceMotionSystem transform;
createNode -n JawSetupFollowHead -p JawSetup transform;
parentConstraint $headJoint JawSetupFollowHead;
scaleConstraint $headJoint JawSetupFollowHead;

createNode -n JawUpVectorOffset -p JawSetup transform;
parentConstraint $headJoint JawUpVectorOffset;
createNode -n JawUpVector transform;
parent JawUpVector JawUpVectorOffset;
setAttr -type float3 JawUpVector.t 0 0 0;

//create joints
select -cl;
joint -n Jaw_M;
parent Jaw_M faceHeadJoint;
joint -n Chin_M;
select -cl;
joint -n TeethUpper_M;
parent TeethUpper_M FaceDeformationFollowHead;
select -cl;
joint -n TeethLower_M;
parent TeethLower_M FaceDeformationFollowHead;


$curve=`curve -d 1 -p -3 0 0 -p -1 0 -1 -p 0 0 -3 -p 1 0 -1 -p 3 0 0 -p 1 0 1 -p 0 0 3 -p -1 0 1 -p -3 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8`;
rename $curve FKJaw_M;
move -r 0 0 5.3 FKJaw_M.cv[2];
move -r 0 0 1.5 FKJaw_M.cv[1] FKJaw_M.cv[3];
rotate -r -p 0 0 0 -os 90 0 0 FKJaw_M.cv[0:8];
sets -add FaceControlSet FKJaw_M;
setAttr FKJaw_MShape.overrideEnabled 1;
setAttr FKJaw_MShape.overrideColor 17;
setAttr -type float3 FKJaw_M.s ($scale/18.0) ($scale/18.0) ($scale/36.0);
makeIdentity -a 1 -t 0 -r 0 -s 1 FKJaw_M;
createNode -n FKOffsetJaw_M transform;
createNode -n FKSDK1Jaw_M -p FKOffsetJaw_M transform;
parent FKOffsetJaw_M JawSetupFollowHead;
parent FKJaw_M FKSDK1Jaw_M;
//asAlign FKOffsetJaw_M Jaw_M 1 1 0 0;
$pos=`xform -q -ws -t JawPivot`;
xform -ws -t 0 $pos[1] $pos[2] FKOffsetJaw_M;
//parentConstraint FKJaw_M Jaw_M;
//scaleConstraint FKJaw_M Jaw_M;
createNode -n LocalOffsetJaw_M -p JawSetup transform;
createNode -n LocalSDKJaw_M -p LocalOffsetJaw_M transform;
createNode -n LocalJaw_M -p LocalSDKJaw_M transform;
asAlign LocalOffsetJaw_M FKJaw_M 1 1 0 1;
string $trs[]={"t","r","s"};
for ($i=0;$i<size($trs);$i++)
	{
	connectAttr ("FKSDK1Jaw_M."+$trs[$i]) ("LocalSDKJaw_M."+$trs[$i]);
	connectAttr ("FKJaw_M."+$trs[$i]) ("LocalJaw_M."+$trs[$i]);
	}
parentConstraint LocalJaw_M Jaw_M;
scaleConstraint LocalJaw_M Jaw_M;
//connectAttr FKJaw_M.t Jaw_M.t;
//connectAttr FKJaw_M.r Jaw_M.r;
//connectAttr FKJaw_M.s Jaw_M.s;
$pos=`xform -q -ws -t Jaw`;
xform -ws -t 0 $pos[1] $pos[2] Chin_M;
$pos=`getAttr Chin_M.t`;
move -r 0 $pos[1] $pos[2] FKJaw_M.cv[0:8];

createNode -n upperTeethOrientOffset_M transform;
parent upperTeethOrientOffset_M JawSetupFollowHead;
setAttr -type float3 upperTeethOrientOffset_M.t 0 0 0;
//float $ctrlScale[]=`getAttr ctrlBoxFKTeethUpper_M.s`;
//setAttr -type float3 upperTeethOrientOffset_M.s ($ctrlScale[0]*1) ($ctrlScale[0]*1) ($ctrlScale[0]*1);
duplicate -n lowerTeethOrientOffset_M upperTeethOrientOffset_M;
parent lowerTeethOrientOffset_M FKJaw_M;

string $upperLower,$upperLowerTeeth,$teethUpperLowerM;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerTeeth=$upperTeeth;$teethUpperLowerM="TeethUpper_M";}
	else {$upperLower="lower";$upperLowerTeeth=$lowerTeeth;$teethUpperLowerM="TeethLower_M";}

	if ($upperLowerTeeth!="")
		{
		eval ("select "+$upperLowerTeeth);
		$tempString=`ls -sl -o`;
		if (size($tempString)>1)
			select $tempString[0];
		float $bb[]=`xform -q -ws -bb`;

		createNode -n ($upperLower+"TeethOffset_M") -p ($upperLower+"TeethOrientOffset_M") transform;
		xform -ws -t (($bb[0]+$bb[3])/2.0) (($bb[1]+$bb[4])/2.0) (($bb[2]+$bb[5])/2.0) ($upperLower+"TeethOrientOffset_M");

		$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 0.5 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
		rename $tempString[0] ("FK"+$teethUpperLowerM);
		parent -r ("FK"+$teethUpperLowerM) ($upperLower+"TeethOffset_M");
		scale ($bb[3]-$bb[0]) 1 ($bb[5]-$bb[2]) ("FK"+$teethUpperLowerM+".cv[0:7]");
		sets -add FaceControlSet ("FK"+$teethUpperLowerM);
		setAttr ("FK"+$teethUpperLowerM+"Shape.overrideEnabled") 1;
		setAttr ("FK"+$teethUpperLowerM+"Shape.overrideColor") 17;

		parentConstraint ("FK"+$teethUpperLowerM) $teethUpperLowerM;
		scaleConstraint ("FK"+$teethUpperLowerM) $teethUpperLowerM;
		}
	}

setAttr Jaw_M.segmentScaleCompensate 0;
setAttr TeethUpper_M.segmentScaleCompensate 0;
setAttr TeethLower_M.segmentScaleCompensate 0;

asSkinTeeth;

//Skin jaw-curves
select $headJoint Jaw_M JawCurve;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawCurveSC;
select $headJoint Jaw_M JawCurveMid;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawCurveMidSC;

//Create the JawOpenRegion mesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
if (`objExists tempTargetFullMesh`)
	duplicate -n JawOpenRegion tempTargetFullMesh;
else
	duplicate -n JawOpenRegion tempTarget;
setAttr RegionDeformations.v 1;
setAttr JawOpenRegion.v 1;
setAttr EyeLidRegion.v 0;
parent JawOpenRegion RegionDeformations;
sets -e -forceElement initialShadingGroup JawOpenRegion;

if (`objExists tempTargetFullMesh`)
	duplicate -n JawOpenStickyLipRegion tempTargetFullMesh;
else
	duplicate -n JawOpenStickyLipRegion tempTarget;
parent JawOpenStickyLipRegion RegionDeformations;
sets -e -forceElement initialShadingGroup JawOpenStickyLipRegion;

select JawOpenRegion faceHeadJoint Jaw_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawOpenRegionSC;
skinPercent -tv faceHeadJoint 1 JawOpenRegionSC JawOpenRegion.vtx[0:99999];

select JawOpenStickyLipRegion faceHeadJoint Jaw_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawOpenStickyLipRegionSC;
skinPercent -tv faceHeadJoint 1 JawOpenStickyLipRegionSC JawOpenStickyLipRegion.vtx[0:99999];

//if teeth part of Main mesh, temporarily weight teeth to jaw
if (`gmatch $lowerTeeth "*[.]*"`)
	{
	eval ("select "+$lowerTeeth);
	$tempString=`ls -sl`;
	skinPercent -tv Jaw_M 1 JawOpenRegionSC `asobjSetCast "" $tempString JawOpenRegion`;
	}
}

global proc asWeightStickyLips ()
{
//asWeightLips JawOpenStickyLipRegion;
asFaceUpdateJawWeightsFromCurves JawOpenStickyLipRegion;
}

global proc asWeightLips (string $geo)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];

if (`objExists JawOpenRegionDeleteComponent`)
	setAttr JawOpenRegionDeleteComponent.nodeState 1;
float $currentTime=`currentTime -q`;
currentTime 0;

duplicate -n lipWeighter $geometry;
$tempString=`listRelatives -s lipWeighter`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
sets -rm lipArea lipWeighter.vtx[0:99999];
sets -add mouthOpenSoftModSet lipWeighter;
setAttr mouthOpenSoftModHandle.ty 0;
if (!`objExists lipAreaJawOpenRegion`)
	{
	createNode -n lipAreaJawOpenRegion objectSet;
	sets -add FaceBuildingSets lipAreaJawOpenRegion;
	}
select lipArea;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	string $vtxOnLipWeighter=`substitute $geometry $tempString[$i] lipWeighter`;
	$posA=`xform -q -ws -t $vtxOnLipWeighter`;
	setAttr mouthOpenSoftModHandle.ty 1;
	$posB=`xform -q -ws -t $vtxOnLipWeighter`;
	setAttr mouthOpenSoftModHandle.ty 0;
	float $weight=$posB[1]-$posA[1];
	$tempString[0]=`substitute $geometry $tempString[$i] $geo`;
	sets -add lipAreaJawOpenRegion $tempString[0];
	skinPercent -tv Jaw_M $weight ($geo+"SC") $tempString[0];
	}
delete lipWeighter;

if (`objExists JawOpenRegionDeleteComponent`)
	setAttr JawOpenRegionDeleteComponent.nodeState 0;
currentTime $currentTime;

setAttr ControlsSetup.v 0;
select -cl;
setKeyframe -v 0 -t 0 ctrlMouth_M.ty;
setKeyframe -v -1 -t 30 ctrlMouth_M.ty;
playbackOptions -min 0 -max 30 -ast 0 -aet 30;
}

global proc asFaceUpdateJawWeightsFromCurves (string $geo)
{
global string $gMainPane;
global string $gMainProgressBar;
progressBar -e -st ("asFaceUpdateJawWeightsFromCurves") -bp -ii 0 -min 0 -max 1 $gMainProgressBar;
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
//string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $posA[],$posB[];
string $tempString[];
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $vtxsFromLipToNose=3;
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;

if (`objExists JawOpenRegionDeleteComponent`)
	setAttr JawOpenRegionDeleteComponent.nodeState 1;
float $currentTime=`currentTime -q`;
currentTime 0;

if (`objExists jawArea`) delete jawArea;

asSelectCurveVtx JawCurve;
$tempString=`ls -sl -fl`;select -cl;
for ($i=0;$i<size($tempString);$i++) select -add `substitute $geometry $tempString[$i] $geo`;
string $jawCurveVtxs[]=`ls -sl -fl`;
asSelectCurveVtx JawCurveMid;
$tempString=`ls -sl -fl`;select -cl;
for ($i=0;$i<size($tempString);$i++) select -add `substitute $geometry $tempString[$i] $geo`;
string $jawCurveMidVtxs[]=`ls -sl -fl`;

skinPercent -tv Jaw_M 1 ($geo+"SC") $jawCurveVtxs;
skinPercent -tv Jaw_M 0.5 ($geo+"SC") $jawCurveMidVtxs;

//taper off skinWeights towards the jawPivot, based on distance
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t Jaw`;
float $maxDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
for ($i=0;$i<size($jawCurveVtxs);$i++)
	{
	$posB=`xform -q -ws -t $jawCurveVtxs[$i]`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<($maxDist/2.0))
		skinPercent -tv Jaw_M (($dist/$maxDist)*2) ($geo+"SC") $jawCurveVtxs[$i];
	}

//taper off skinWeights towards the jawPivot, based on distance (50vtx)
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
float $maxDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
for ($i=0;$i<size($jawCurveMidVtxs);$i++)
	{
	$posB=`xform -q -ws -t $jawCurveMidVtxs[$i]`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<($maxDist/2.0))
		skinPercent -tv Jaw_M ($dist/$maxDist) ($geo+"SC") $jawCurveMidVtxs[$i];
	}

//Select vtxs with curve boundaries, first from BB polySeConstr for speed
duplicate -n JawCurveTopSampler JawCurveTop;
duplicate -n JawCurveBottomSampler JawCurveBottom;
select JawCurveTopSampler.cv[0:6] JawCurveBottomSampler.cv[0:5];
move -x 0;
//Jaw can be lower than throat on some characters
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t Throat`;
if ($posA[1]<$posB[1])
	xform -ws -t 0 $posA[1] $posA[2] JawCurveBottomSampler.cv[5]; 
spaceLocator -n samplerLocator;
spaceLocator -n samplerLocatorTop;
spaceLocator -n samplerLocatorBottom;
parent samplerLocatorTop samplerLocatorBottom samplerLocator;
select JawCurveTopSampler samplerLocatorTop;geometryConstraint -weight 1;
select samplerLocator samplerLocatorTop;pointConstraint;
select JawCurveBottomSampler samplerLocatorBottom;geometryConstraint -weight 1;
select samplerLocator samplerLocatorBottom;pointConstraint;

float $bbCurveTop[]=`xform -q -ws -bb JawCurveTopSampler`;
float $bbCurveBottom[]=`xform -q -ws -bb JawCurveBottomSampler`;
select $geo;
polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveBottom[1] $bbCurveTop[4] -da 0 1 0 -dp 0 0 0;
string $ySel[]=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 100 -da 0 0 1 -dp 0 0 ($bbCurveBottom[2]-100);
string $zSelInv[]=`ls -sl`;
polySelectConstraint -m 0;
select $ySel;
select -d $zSelInv;
InvertSelection;
string $outsideOuterBoundsVtxs[]=`ls -sl`;

float $bbCurveTop[]=`xform -q -ws -bb JawCurveTopSampler`;
float $bbCurveBottom[]=`xform -q -ws -bb JawCurveBottomSampler`;
select $geo;
polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveBottom[1] $bbCurveTop[1] -da 0 1 0 -dp 0 0 0;
string $ySel[]=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 100 -da 0 0 1 -dp 0 0 ($bbCurveBottom[5]-100);
string $zSelInv[]=`ls -sl`;
polySelectConstraint -m 0;
select $ySel;
select -d $zSelInv;
string $insideInnerBoundsVtxs[]=`ls -sl`;

float $bbCurveTop[]=`xform -q -ws -bb JawCurveTopSampler`;
float $bbCurveBottom[]=`xform -q -ws -bb JawCurveBottomSampler`;
select $geo;
polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveTop[4] $bbCurveTop[1] -da 0 1 0 -dp 0 0 0;
string $yOnBoundSel[]=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbCurveBottom[5]-$bbCurveBottom[2])/2.0) -da 0 0 1 -dp 0 0 (($bbCurveBottom[5]+$bbCurveBottom[2])/2.0);
string $zOnBoundSelInv[]=`ls -sl`;
polySelectConstraint -m 0;
select $yOnBoundSel $zOnBoundSelInv;
select -d $outsideOuterBoundsVtxs;
string $onBoundsVtxs[]=`ls -sl -fl`;

select -cl;
for ($i=0;$i<size($onBoundsVtxs);$i++)
	{
	$pos=`xform -q -ws -t $onBoundsVtxs[$i]`;
//	if ($pos[0]>0)
//		continue;
	xform -ws -t $pos[0] $pos[1] $pos[2] samplerLocator;
	refresh;
//	if (`getAttr samplerLocatorTop.ty`>0 && `getAttr samplerLocatorBottom.tz`<0)
	if (`getAttr samplerLocatorTop.ty`>0)
		select -add $onBoundsVtxs[$i];
	}


select -add $insideInnerBoundsVtxs;
select -d lipAreaJawOpenRegion;
sets -n jawArea;
sets -add FaceBuildingSets jawArea;
select -d $jawCurveVtxs $jawCurveMidVtxs;
weightHammerVerts;
copySkinWeights -ss ($geo+"SC") -ds ($geo+"SC") -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//select JawOpenRegion JawOpenRegionNonSmoo;
//copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

select jawArea;
asSmoothFlood faceHeadJoint Jaw_M 100;
select $geo JawCurve;CopySkinWeights;
select $geo JawCurveMid;CopySkinWeights;

//fix the weighting just above upperLip
select lipAreaJawOpenRegion;
string $completedVtxs[]=`ls -sl -fl`;
//eval ("select "+`getAttr FaceFitLipOuter.upperSelection`);
eval ("select "+`asGetFaceFitSelection upperLipOuterCurve`);
$tempString=`ls -sl -fl`;
float $bb[]=`xform -q -bb`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	select -add `substitute $geometry $tempString[$i] $geo`;
string $lipOutherVtxs[]=`ls -sl -fl`;
for ($i=0;$i<size($lipOutherVtxs);$i++)
	{
	$posA=`xform -q -ws -t $lipOutherVtxs[$i]`;
//	if ($posA[0]>0)
//		continue;
	select $lipOutherVtxs[$i];
	float $prevWeights[];
	float $onLipWeights[]=`skinPercent -ignoreBelow 0.001 -q -v ($geo+"SC")`;
	select $lipOutherVtxs[$i];
	for ($y=0;$y<$vtxsFromLipToNose;$y++)
		{
		asWsPickWalk 0 1 0;
		refresh;
		$tempString=`ls -sl -fl`;
		if (`sets -im lipAreaJawOpenRegion $tempString[0]`)
			continue;
		float $newWeight=$onLipWeights[1]-(($onLipWeights[1]/$vtxsFromLipToNose)*$y);
		skinPercent -tv Jaw_M $newWeight ($geo+"SC");
		}
	}

copySkinWeights -ss ($geo+"SC") -ds ($geo+"SC") -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
select jawArea;
asSmoothFlood faceHeadJoint Jaw_M 5;
copySkinWeights -ss ($geo+"SC") -ds ($geo+"SC") -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

if (`objExists JawOpenRegionDeleteComponent`)
	setAttr JawOpenRegionDeleteComponent.nodeState 0;
currentTime $currentTime;

delete samplerLocator JawCurveTopSampler JawCurveBottomSampler;
progressBar -e -ep $gMainProgressBar;
select $sel;
}

global proc asWsPickWalk (int $x, int $y, int $z)
{
string $sel[]=`ls -sl`;
float $posA[]=`xform -q -ws -t`;
ConvertSelectionToEdges;
ConvertSelectionToVertices;
string $expandSel[]=`ls -sl -fl`;
float $dist,$maxWeight;
//float $minDist=9999;
for ($i=0;$i<size($expandSel);$i++)
	{
	if ($expandSel[$i]==$sel[0])
		continue;
	float $posB[]=`xform -q -ws -t $expandSel[$i]`;
	if ($x==1 && $posB[0]<$posA[0]) continue;
	if ($y==1 && $posB[1]<$posA[1]) continue;
	if ($z==1 && $posB[2]<$posA[2]) continue;
	if ($x==-1 && $posB[0]>$posA[0]) continue;
	if ($y==-1 && $posB[1]>$posA[1]) continue;
	if ($z==-1 && $posB[2]>$posA[2]) continue;

	$xDist=abs($posB[0]-$posA[0]);
	$yDist=abs($posB[1]-$posA[1]);
	$zDist=abs($posB[2]-$posA[2]);
	$xyzDist=$xDist+$yDist+$zDist;
	if (abs($x)) $weight=$xDist/$xyzDist;
	if (abs($y)) $weight=$yDist/$xyzDist;
	if (abs($z)) $weight=$zDist/$xyzDist;

	if ($weight>$maxWeight)
		{
		$maxWeight=$weight;
		select $expandSel[$i];
		}
	}
string $tempString[]=`ls -sl -fl`;
if (size($tempString)>1)
	select $tempString[0];
}

global proc asSetupStickyLips ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
//string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;

parent FaceFitJawCurves FaceFitSkeleton;

if (`objExists JawOpenRegionDeleteComponent`) delete JawOpenRegionDeleteComponent;
setAttr JawOpenRegion.v 0;

//remove temp weighted teeth to jaw (if teeth part of Main mesh)
if (`gmatch $lowerTeeth "*[.]*"`)
	{
	eval ("select "+$lowerTeeth);
	$tempString=`ls -sl`;
	skinPercent -tv faceHeadJoint 1 JawOpenRegionSC `asobjSetCast "" $tempString JawOpenRegion`;
	}

setAttr JawOpenStickyLipRegion.v 1;
setAttr mouthOpenSoftMod.falloffCurve[0].falloffCurve_FloatValue 0.5;
setAttr mouthOpenSoftMod.falloffCurve[1].falloffCurve_FloatValue 0.5;
asWeightLips JawOpenStickyLipRegion;
asFaceUpdateJawWeightsFromCurves JawOpenStickyLipRegion;

setAttr JawOpenStickyLipRegion.v 0;

string $tempString[]=`listConnections -s 1 -d 0 -type animCurve ctrlMouth_M`;
if ($tempString[0]!="")
	delete $tempString[0];
setAttr ctrlMouth_M.tx 0;
setAttr ctrlMouth_M.ty 0;

setAttr JawOpenRegion.v 0;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;
delete LipDeformations mouthOpenSoftModHandle;

blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` JawOpenRegion 1 asFaceBS;
blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` JawOpenStickyLipRegion 1 asFaceBS;
addAttr -k 1 -ln stickyLips -at double -min 0 -max 10 -dv 0 ctrlMouth_M;

createNode -n stickyLipsUnitConversion unitConversion;
setAttr stickyLipsUnitConversion.conversionFactor 0.1;
connectAttr ctrlMouth_M.stickyLips stickyLipsUnitConversion.input;

createNode -n stickyLipsReverse reverse;
connectAttr stickyLipsUnitConversion.output stickyLipsReverse.inputX;
connectAttr stickyLipsReverse.outputX asFaceBS.JawOpenRegion;

connectAttr stickyLipsUnitConversion.output asFaceBS.JawOpenStickyLipRegion;

setAttr ctrlMouth_M.ty -1;
refresh;
setAttr ctrlMouth_M.stickyLips 10;
select ctrlMouth_M;
}

global proc asSetupZipperLips ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $pos[],$posA[],$posB[];
float $dist,$value;
int $upperLipMainNumCVs=`getAttr upperLipMainCurve.spans`+1;
createNode -n ZipperLipSetup -p FaceMotionSystem transform;
setAttr -l 1 ZipperLipSetup.v 0;

//Cleanup stickyLips first
setAttr ctrlMouth_M.tx 0;
setAttr ctrlMouth_M.ty 0;
setAttr ctrlMouth_M.stickyLips 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	if (`objExists tempTargetFullMesh`)
		duplicate -n ("zipperLips"+$side+"Region") tempTargetFullMesh;
	else
		duplicate -n ("zipperLips"+$side+"Region") tempTarget;
	parent ("zipperLips"+$side+"Region") RegionDeformations;
	sets -e -forceElement initialShadingGroup ("zipperLips"+$side+"Region");

	$pos=`xform -q -ws -t upperLipMainCurve.cv[$upperLipMainNumCVs]`;
	if ($side=="_L") $pos[0]=$pos[0]*-1;
	select -r ("zipperLips"+$side+"Region");
	$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
	rename $tempString[0] ("ZipperSoftMod"+$side);
	rename $tempString[1] ("ZipperSoftModHandle"+$side);
	parent ("ZipperSoftModHandle"+$side) ZipperLipSetup;
	setAttr ("ZipperSoftMod"+$side+".falloffRadius") 999;
	setAttr ("ZipperSoftMod"+$side+".falloffMode") 0;
	setAttr -type float3 ("ZipperSoftModHandle"+$side+"Shape.origin") ($pos[0]) $pos[1] $pos[2];
	setAttr ("ZipperSoftMod"+$side+".falloffCenter") ($pos[0]) $pos[1] $pos[2];
	xform -piv $pos[0] $pos[1] $pos[2] ("ZipperSoftModHandle"+$side);
	setAttr ("ZipperSoftMod"+$side+".falloffCurve[0].falloffCurve_Position") 0.95;
	parentConstraint -mo Jaw_M ("ZipperSoftModHandle"+$side);
	}

connectAttr -f ZipperSoftMod_R.falloffCurve ZipperSoftMod_L.falloffCurve;
setAttr ctrlMouth_M.ty -1;

int $tempInts[]=`polyEvaluate -v zipperLips_RRegion`;
int $numVtx=$tempInts[0];

//First find $maxDist
float $maxDist=0;
for ($i=0;$i<$numVtx;$i++)
	{
	setAttr "ctrlMouth_M.stickyLips" 0;
	$posA=`xform -q -ws -t ($geometry+".vtx["+$i+"]")`;
	setAttr "ctrlMouth_M.stickyLips" 10;
	$posB=`xform -q -ws -t ($geometry+".vtx["+$i+"]")`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist>$maxDist)
	    $maxDist=$dist;
	}
//Then set weight to $dist/$maxDist
for ($i=0;$i<$numVtx;$i++)
	{
	setAttr "ctrlMouth_M.stickyLips" 0;
	$posA=`xform -q -ws -t ($geometry+".vtx["+$i+"]")`;
	setAttr "ctrlMouth_M.stickyLips" 10;
	$posB=`xform -q -ws -t ($geometry+".vtx["+$i+"]")`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	$value=($dist/$maxDist)/2.0;
	if ($posA[1]<$posB[1]) $value=$value*-1;
	percent -v $value ZipperSoftMod_R ("zipperLips_RRegion.vtx["+$i+"]");
	percent -v $value ZipperSoftMod_L ("zipperLips_LRegion.vtx["+$i+"]");
	}
setAttr "ctrlMouth_M.stickyLips" 0;

$posA=`xform -q -ws -t upperLipMainCurve.cv[$upperLipMainNumCVs]`;
$posB={($posA[0]*-1),$posA[1],$posA[2]};
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
setAttr ZipperSoftMod_R.falloffCurve[0].falloffCurve_Position ($dist/2.0);

blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` zipperLips_RRegion 1 asFaceBS;
blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` zipperLips_LRegion 1 asFaceBS;
setAttr asFaceBS.zipperLips_RRegion 1;
setAttr asFaceBS.zipperLips_LRegion 1;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	addAttr -k 1 -ln ("zipLips"+$side) -at double -min 0 -max 10 -dv 0 ctrlMouth_M;

	createNode -n ("zipLips"+$side+"UnitConversion") unitConversion;
	setAttr ("zipLips"+$side+"UnitConversion.conversionFactor") ($dist/10.0);
	connectAttr ("ctrlMouth_M.zipLips"+$side) ("zipLips"+$side+"UnitConversion.input");

	connectAttr ("zipLips"+$side+"UnitConversion.output") ("ZipperSoftMod"+$side+".falloffRadius");
	}

parent -w ZipperSoftModHandle_R;
setAttr ctrlMouth_M.zipLips_L 5;
setAttr ctrlMouth_M.zipLips_R 5;
select ctrlMouth_M;
}

global proc asSetupChin ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
//string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $scale=`asFaceGetScale`;
float $posA[],$posB[];
string $tempString[];
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $vtxsFromLipToNose=3;
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;

//Finish zipperLips first
parent ZipperSoftModHandle_R ZipperLipSetup;
setAttr ctrlMouth_M.ty 0;
setAttr ctrlMouth_M.stickyLips 0;
setAttr ctrlMouth_M.zipLips_R 0;
setAttr ctrlMouth_M.zipLips_L 0;

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
string $JawRegionMeshes[]={"JawOpenRegion","JawOpenStickyLipRegion"};
for ($a=0;$a<size($JawRegionMeshes);$a++)
	{
	setAttr ($JawRegionMeshes[$a]+".v") 1;

	$posA=`xform -q -ws -t Chin_M`;
//	$posB=`xform -q -ws -t LipOuter6`;
	$posB=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
	setAttr faceHeadJoint.lockInfluenceWeights 1;

	skinCluster -e -wt 0 -ai Chin_M ($JawRegionMeshes[$a]+"SC");
	select lipArea;
	$tempString=`ls -sl -fl`;
	select -cl;
	for ($i=0;$i<size($tempString);$i++)
		select -add `substitute $geometry $tempString[$i] $JawRegionMeshes[$a]`;
	string $lipArea[]=`ls -sl -fl`;

	select $JawRegionMeshes[$a];
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 ($posB[0]*-1) -dp $posA[0] $posA[1] $posA[2];
	polySelectConstraint -m 0;
	select -d $lipArea;
//	$posA=`xform -q -ws -t lowerLipOuter0`;
	$posA=`xform -q -ws -t lowerLipOuterCurve.cv[0]`;
	$tempString=`ls -sl -fl`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$posB=`xform -q -ws -t $tempString[$i]`;
		if ($posB[1]>$posA[1])
			select -d $tempString[$i];
		}

	skinPercent -tv Chin_M 0.66 ($JawRegionMeshes[$a]+"SC") `ls -sl`;
	for ($i=0;$i<7;$i++)
		GrowPolygonSelectionRegion;

	select -d $lipArea;
	$posA=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
	$tempString=`ls -sl -fl`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$posB=`xform -q -ws -t $tempString[$i]`;
		if ($posB[1]>$posA[1])
			select -d $tempString[$i];
		}

	asSmoothFlood Jaw_M Chin_M 25;
	setAttr ($JawRegionMeshes[$a]+".v") 0;
	}

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 1;

$tempString=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r ($scale/40.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FKChin_M;
sets -add FaceControlSet FKChin_M;
setAttr FKChin_MShape.overrideEnabled 1;
setAttr FKChin_MShape.overrideColor 13;
createNode -n FKOffsetChin_M transform;
parent FKChin_M FKOffsetChin_M;
parent FKOffsetChin_M FKJaw_M;
$posA=`xform -q -ws -t Jaw`;
xform -ws -t $posA[0] $posA[1] $posA[2] FKOffsetChin_M;
move -r 0 ($scale/-20.0) 0 FKChin_M.cv[0:7];	
//parentConstraint FKChin_M Chin_M;
//scaleConstraint FKChin_M Chin_M;
createNode -n LocalOffsetChin_M -p LocalJaw_M transform;
createNode -n LocalChin_M -p LocalOffsetChin_M transform;
asAlign LocalOffsetChin_M FKChin_M 1 1 0 1;
string $trs[]={"t","r","s"};
for ($i=0;$i<size($trs);$i++)
	connectAttr ("FKChin_M."+$trs[$i]) ("LocalChin_M."+$trs[$i]);
parentConstraint LocalChin_M Chin_M;
scaleConstraint LocalChin_M Chin_M;

//Lips control
$tempString=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r ($scale/40.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FKLips_M;
scale -r -p 0 0 0 1.5 0.3 1.5 FKLips_M.cv[0:7];
sets -add FaceControlSet FKLips_M;
setAttr FKLips_MShape.overrideEnabled 1;
setAttr FKLips_MShape.overrideColor 13;
createNode -n FKOffsetLips_M transform;
parent FKLips_M FKOffsetLips_M;
parent FKOffsetLips_M FaceMotionFollowHead;

select lipArea;
float $bb[]=`xform -q -bb`;
xform -ws -t (($bb[0]+$bb[3])/2.0) (($bb[1]+$bb[4])/2.0) (($bb[2]+$bb[5])/2.0) FKOffsetLips_M;
$posA=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
$posB=`xform -q -ws -t NoseUnder`;
$posB={0.0,(($posA[1]+$posB[1])/2.0),(($posA[2]+$posB[2])/2.0)};
$posA=`xform -q -ws -t FKOffsetLips_M`;
move -r 0 ($posB[1]-$posA[1]) ($posB[2]-$posA[2]) FKLips_M.cv[0:7];
move -r 0 0 ($scale/100.0) FKLips_M.cv[0:7];

select -cl;
joint -n Lips_M;
parent Lips_M faceHeadJoint;
asAlign Lips_M FKLips_M 1 0 0 0;

createNode -n LipsAddOffset plusMinusAverage;
setAttr LipsAddOffset.input3D[0].input3Dx `getAttr Lips_M.tx`;
setAttr LipsAddOffset.input3D[0].input3Dy `getAttr Lips_M.ty`;
setAttr LipsAddOffset.input3D[0].input3Dz `getAttr Lips_M.tz`;
connectAttr FKLips_M.t LipsAddOffset.input3D[1];
connectAttr -f LipsAddOffset.output3D Lips_M.t;
connectAttr FKLips_M.r Lips_M.r;
connectAttr FKLips_M.s Lips_M.s;

if (`objExists tempTargetFullMesh`)
	duplicate -n LipsRegion tempTargetFullMesh;
else
	duplicate -n LipsRegion tempTarget;
setAttr LipsRegion.v 1;
parent LipsRegion RegionDeformations;
sets -e -forceElement initialShadingGroup LipsRegion;
select Lips_M faceHeadJoint LipsRegion;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] LipsSC;
skinPercent -tv faceHeadJoint 1 LipsSC LipsRegion.vtx[0:99999];

string $lipAreaInLipsMesh[]=`asobjSetCast lipArea {} LipsRegion`;
select $lipAreaInLipsMesh;
skinPercent -tv Lips_M 1 LipsSC `ls -sl`;

eval ("select "+`asGetFaceFitSelection FaceFitLipOuterCurve`);
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	select -add `substitute $geometry $tempString[$i] LipsRegion`;
for ($i=0;$i<$vtxsFromLipToNose+2;$i++)
	GrowPolygonSelectionRegion;
select -d $lipAreaInLipsMesh;
weightHammerVerts;
asSmoothFlood faceHeadJoint Lips_M 50;
copySkinWeights -ss LipsSC -ds LipsSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` LipsRegion 1 asFaceBS;
setAttr asFaceBS.LipsRegion 1;
setAttr LipsRegion.v 0;
select -cl;
}

global proc asAdvancedCheekPartA ()
{
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower;
string $tempString[],$tempString2[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;

if (`objExists mouthGeo`)
	delete mouthGeo;

select jawArea;
ConvertSelectionToFaces;
if ($upperTeeth!="") eval ("select -d "+$upperTeeth);
if ($lowerTeeth!="") eval ("select -d "+$lowerTeeth);
string $mouthAreFaces[]=`ls -sl`;
duplicate -n mouthGeo $geometry;
asLockAttr mouthGeo 0 0 0 0;
setAttr mouthGeo.v 1;
$tempString=`ls -l mouthGeo`;
if (`gmatch $tempString[0] "*?|*"`)
	parent -w mouthGeo;
$tempString=`listRelatives -s mouthGeo`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
$tempString=`listRelatives -s mouthGeo`;
if ($tempString[0]!="mouthGeoShape")
	rename $tempString[0] "mouthGeoShape";
sets -remove grownUpLipVtxs mouthGeoShape.vtx[0:99999];
sets -remove grownUpLipVtxsInverse mouthGeoShape.vtx[0:99999];
select mouthGeo.f[0:99999];
for ($i=0;$i<size($mouthAreFaces);$i++)
	select -d (`substitute $geometry $mouthAreFaces[$i] mouthGeo`);
delete;

if (`objExists "Group"`) setAttr "Group.v" 0;
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
select -r mouthGeo ;
}

global proc asAdvancedCheekPartB ()
{
float $scale=`asFaceGetScale`;
float $pos[],$posA[],$posB[];
string $upperLower;
string $tempString[],$tempString2[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;

createNode -n lipGeometry transform;
setAttr lipGeometry.v 0;
int $loop1VtxNrs[]={0,3,7,11,17,37,40,46,128,131,134,140,160,163,168};
int $loop2VtxNrs[]={12,13,16,18,39,41,45,47,133,135,139,141,162,164,169};
int $loop3VtxNrs[]={14,15,20,21,43,44,49,50,137,138,143,144,166,167,171};
int $loop4VtxNrs[]={8,9,10,19,36,38,42,48,130,132,136,142,161,165,170};
int $loop5VtxNrs[]={25,26,28,29,54,55,61,62,148,149,155,156,175,176,181};
int $loop6VtxNrs[]={22,23,24,27,52,53,59,60,146,147,153,154,173,174,180};
int $loop7VtxNrs[]={31,32,34,35,57,58,64,65,151,152,158,159,178,179,183};
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	if ($side=="_L") continue;
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		if ($side=="_R")
			{
			nurbsToPoly -n ($upperLower+"LipCylinderPoly_R") -mnd 1 -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 16 -vt 1 -vn 16 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($upperLower+"LipCylinder");
			parent ($upperLower+"LipCylinderPoly"+$side) lipGeometry;
			}
		else
			{
			duplicate -n ($upperLower+"LipCylinderPoly_L") ($upperLower+"LipCylinderPoly_R");
			setAttr ($upperLower+"LipCylinderPoly_L.sx") -1;
			connectAttr ($upperLower+"LipCylinderPoly_R.outMesh") ($upperLower+"LipCylinderPoly_L.inMesh");
			}
		
		duplicate -n ($upperLower+"LipCylinderPolyBS"+$side) ($upperLower+"LipCylinderPoly"+$side);
		select ($upperLower+"LipCylinderPoly"+$side) ($upperLower+"LipCylinderPolyBS"+$side);
		blendShape -n ($upperLower+"LipBS"+$side) -frontOfChain -w 0 1;
//		blendShape -e  -t ($upperLower+"LipCylinderPolyBS"+$side) 1 ($upperLower+"LipCylinderPoly"+$side) 1 ($upperLower+"LipCylinderPolyBS"+$side);

		if ($side=="_L")
			for ($i=0;$i<240;$i++)
				setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$i+"]") 0;

		for ($i=0;$i<size($loop1VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop1VtxNrs[$i]+"]") 0.5;
		for ($i=0;$i<size($loop2VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop2VtxNrs[$i]+"]") 0.51;
		for ($i=0;$i<size($loop3VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop3VtxNrs[$i]+"]") 0.65;
		for ($i=0;$i<size($loop4VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop4VtxNrs[$i]+"]") 0.8;
		for ($i=0;$i<size($loop5VtxNrs);$i++)
			setAttr -size 1 ($upperLower+"LipBS"+$side+".inputTarget[0].inputTargetGroup[0].targetWeights["+$loop5VtxNrs[$i]+"]") 0.9;
		}
	}

select mouthGeo;
$tempString=`createNCloth 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] mouthNCloth;
setAttr mouthNCloth.ignoreSolverGravity 1;
setAttr mouthNCloth.damp 10;
setAttr mouthNCloth.stretchResistance 0;
setAttr mouthNCloth.selfCollide 0;
setAttr mouthNCloth.selfCollisionFlag 4;
setAttr mouthNCloth.stretchResistance 5;
setAttr mouthNCloth.compressionResistance 3;
setAttr mouthNCloth.bendResistance 3;
setAttr mouthNCloth.selfCollide 0;

select -r mouthGeo.vtx[0:99999];

refresh;
//someTimes polySelectConstraint -pp 3 fails, ensuring -t seem to fix
polySelectConstraint -t 1 -pp 3;
$borderVtxs=`ls -sl`;
$tempString=`createNConstraint transform 0`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] tempNClothConstraint1;

//find $grownUpLipVtxsOnMouthGeo & $grownUpLipVtxsInverseOnMouthGeo
string $grownUpLipVtxsOnMouthGeo[];
asCreateSamplerMesh mouthGeo;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f samplerMesh.outMesh closestSampler.inMesh;
select `sets -q grownUpLipVtxs`;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$grownUpLipVtxsOnMouthGeo[$i]="mouthGeo.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	}
delete samplerMesh closestSampler;
select $grownUpLipVtxsOnMouthGeo;
InvertSelection;
string $grownUpLipVtxsInverseOnMouthGeo[]=`ls -sl`;

//constraint to lipGeo
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	if ($side=="_L") continue;
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";
	
		select -r mouthGeo ($upperLower+"LipCylinderPolyBS"+$side);
		$tempString=`createNConstraint pointToPoint 0`;
		$tempString2=`listRelatives -p $tempString[0]`;
		rename $tempString2[0] ($upperLower+"LipNClothRigid"+$side);
		$tempString2=`listRelatives -p $tempString[1]`;
		rename $tempString2[0] ($upperLower+"LipNClothConstraint"+$side);
	
		select ($upperLower+"LipNClothConstraint"+$side);
		select -add $borderVtxs;
		if ($upperLower=="upper")	select -add $grownUpLipVtxsInverseOnMouthGeo;
		if ($upperLower=="lower")	select -add $grownUpLipVtxsOnMouthGeo;
		dynamicConstraintMembership "remove";
		
		setAttr ($upperLower+"LipNClothConstraint"+$side+".constraintMethod") 2;
		setAttr ($upperLower+"LipNClothConstraint"+$side+".connectionMethod") 1;
		setAttr ($upperLower+"LipNClothConstraint"+$side+".maxDistance") ($scale*0.01);//using 1% of facescale as skinOffset
		}
	}

//constraint to JawCylinderMainPoly
asFaceClothConstraint JawCylinderMain ($scale*0.01);

//constraint to Nose
asFaceClothConstraint NoseCylinder ($scale*0.01);

//constraint to noseCorner
asFaceClothConstraint noseCornerSphere ($scale*0.01);

//constraint to lowerEyeLidCylinderPolyOuter_R
asFaceClothConstraint lowerEyeLidCylinderOuter ($scale*0.01);

//Cheek Puff & Suck forceFields
select -r mouthGeo;
$tempString=`createNConstraint force 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] CheekPuffDynamicConstraint;
select -r mouthGeo;
$tempString=`createNConstraint force 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] CheekSuckDynamicConstraint;
setAttr -type float3 CheekPuffDynamicConstraint.s ($scale*0.1) ($scale*0.1) ($scale*0.1);//using 10% of facescale as skinOffset
setAttr -type float3 CheekSuckDynamicConstraint.s ($scale*0.1) ($scale*0.1) ($scale*0.1);//using 10% of facescale as skinOffset
setAttr CheekPuffDynamicConstraintShape.force ($scale/1.5);
setAttr CheekSuckDynamicConstraintShape.force ($scale/1.5);

$pos=`xform -q -ws -t cheek`;
xform -ws -t ($pos[0]+($scale*0.02)) $pos[1] ($pos[2]-($scale*0.02)) CheekPuffDynamicConstraint;
xform -ws -t ($pos[0]-($scale*0.02)) $pos[1] ($pos[2]+($scale*0.02)) CheekSuckDynamicConstraint;
setKeyframe -v 0 -t 100 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 1 -t 101 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 1 -t 105 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 0 -t 106 CheekPuffDynamicConstraintShape.ena;
setKeyframe -v 0 -t 110 CheekSuckDynamicConstraintShape.ena;
setKeyframe -v 1 -t 111 CheekSuckDynamicConstraintShape.ena;
setKeyframe -v 1 -t 115 CheekSuckDynamicConstraintShape.ena;
setKeyframe -v 0 -t 116 CheekSuckDynamicConstraintShape.ena;

//Find LipVtxs
asWrapLipCylinders $scale;
string $lipArea[]=`ls -sl`;
delete tempWrap;
if (size($lipArea)==0)
	{
	//Trying again with scaled up objects, because wrap deformer does not work on small objects
	print ("// LipArea not detected, trying upscale x10 to get wrap-attachment\n");
	scale -r -p 0 0 0 10 10 10 mouthGeo.vtx[0:99999];
	setAttr -type float3 lipGeometry.s 10 10 10;
	asWrapLipCylinders ($scale*10);
	$lipArea=`ls -sl`;
	delete tempWrap;
	scale -r -p 0 0 0 0.1 0.1 0.1 mouthGeo.vtx[0:99999];
	setAttr -type float3 lipGeometry.s 1 1 1;
	if (size($lipArea)==0)
		error "Unable to determine the lipArea";
	}
createNode -n lipArea objectSet;
	if (`objExists "Sets"`)
		sets -add "Sets" lipArea;
sets -add lipArea $lipArea;
select $lipArea;
}

global proc asCurveOffsetMesh (string $curve, string $geometry ,float $offset)
{
$form=`getAttr ($curve+".form")`;
$spans=`getAttr ($curve+".spans")`;
$degrees=`getAttr ($curve+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 20 -d 3 -tol 0.01 $curve;
spaceLocator -n constraintLoc;
spaceLocator -n constraintLoc2;
parent constraintLoc2 constraintLoc;
setAttr constraintLoc2.tx $offset;
select $geometry constraintLoc;
geometryConstraint -weight 1;
select $geometry constraintLoc;
normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
for ($i=0;$i<23;$i++)
    {
    $posA=`xform -q -ws -t ($curve+".cv["+$i+"]")`;
    xform -ws -t $posA[0] $posA[1] $posA[2] constraintLoc;
    $posB=`xform -q -ws -t constraintLoc2`;
    xform -ws -t $posB[0] $posB[1] $posB[2] ($curve+".cv["+$i+"]");
    }
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 3 -tol 0.01 $curve;
delete constraintLoc;
}

global proc asWrapLipCylinders (float $scale)
{
asSetFixedWrapOptions;
select -r mouthGeo upperLipCylinderPoly_R;CreateWrap;
//select -r mouthGeo upperLipCylinderPoly_L;AddWrapInfluence;
select -r mouthGeo lowerLipCylinderPoly_R;AddWrapInfluence;
//select -r mouthGeo lowerLipCylinderPoly_L;AddWrapInfluence;
$tempString=`listConnections mouthGeo.inMesh`;
rename $tempString[0] tempWrap;
setAttr tempWrap.autoWeightThreshold 0;
setAttr tempWrap.weightThreshold 0;
setAttr tempWrap.exclusiveBind 0;
setAttr tempWrap.maxDistance ($scale*0.01);
setAttr upperLipCylinderPoly_R.tz (100*$scale);//setAttr upperLipCylinderPoly_L.tz (100*$scale);
setAttr lowerLipCylinderPoly_R.tz (100*$scale);//setAttr lowerLipCylinderPoly_L.tz (100*$scale);
int $tempInts[]=`polyEvaluate -v mouthGeo`;
int $numVtx=$tempInts[0];
select -cl;
for ($i=0;$i<$numVtx;$i++)
	{
	$pos=`xform -q -ws -t ("mouthGeo.vtx["+$i+"]")`;
	if ($pos[2]>(50*$scale))
		select -add  ("mouthGeo.vtx["+$i+"]");
	}
setAttr upperLipCylinderPoly_R.tz 0;//setAttr upperLipCylinderPoly_L.tz 0;
setAttr lowerLipCylinderPoly_R.tz 0;//setAttr lowerLipCylinderPoly_L.tz 0;
}

global proc asAdvancedLip ()
{
//create `fake FitLocators`, place inbetween Main, Inner & Outer
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	createNode -n ($upperLower+"Lip0") -p ClusterSetup transform;
	delete `pointConstraint ($upperLower+"LipMain0") ($upperLower+"LipOuter0") ($upperLower+"LipInner0") ($upperLower+"Lip0")`;
	createNode -n ($upperLower+"Lip3") -p ClusterSetup transform;
	delete `pointConstraint ($upperLower+"LipMain3") ($upperLower+"LipOuter3") ($upperLower+"LipInner3") ($upperLower+"Lip3")`;
	}
createNode -n Lip6 -p ClusterSetup transform;
delete `pointConstraint LipMain6 LipOuter6 LipInner6 Lip6`;

//Lip PingPongs
float $posA[]=`xform -q -ws -t Lip6`;
float $posB[]=`xform -q -ws -t upperLip0`;
float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
if (!`attributeExists falloffRadius Lip6`) addAttr -k 1 -min 0 -dv ($dist*1.2) -ln "falloffRadius" -at double Lip6;
if (!`attributeExists falloffMode Lip6`) addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 Lip6;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	softCluster Lip6 Lip6 $b $side;
	sets -e -forceElement asFaceGreenSG ("Lip6"+$side);
	$posA=`xform -q -ws -t Lip6`;
	$posB=`xform -q -ws -t LipOuter6`;
	xform -ws -r -t ((($posB[0]-$posA[0])*2)*$b) (($posB[1]-$posA[1])*2) (($posB[2]-$posA[2])*2) ("Lip6"+$side+".cv[0:6][0:7]");
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	$posA=`xform -q -ws -t ($upperLower+"Lip0")`;
	$posB=`xform -q -ws -t Lip6`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if (!`attributeExists falloffRadius ($upperLower+"Lip0")`) addAttr -k 1 -min 0 -dv ($dist*1.2) -ln "falloffRadius" -at double ($upperLower+"Lip0");
	if (!`attributeExists falloffMode ($upperLower+"Lip0")`) addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 ($upperLower+"Lip0");
	softCluster ($upperLower+"Lip0") ($upperLower+"Lip0") 1 "_M";
	sets -e -forceElement asFaceGreenSG ($upperLower+"Lip0_M");
	$posA=`xform -q -ws -t ($upperLower+"Lip0_M")`;
	$posB=`xform -q -ws -t ($upperLower+"LipOuter0")`;
	xform -ws -r -t (($posB[0]-$posA[0])*2) (($posB[1]-$posA[1])*2) (($posB[2]-$posA[2])*2) ($upperLower+"Lip0_M.cv[0:6][0:7]");

	$posA=`xform -q -ws -t ($upperLower+"Lip3")`;
	$posB=`xform -q -ws -t Lip6`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if (!`attributeExists falloffRadius ($upperLower+"Lip3")`) addAttr -k 1 -min 0 -dv ($dist*1.2) -ln "falloffRadius" -at double ($upperLower+"Lip3");
	if (!`attributeExists falloffMode ($upperLower+"Lip3")`) addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 ($upperLower+"Lip3");
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		softCluster ($upperLower+"Lip3") ($upperLower+"Lip3") $b $side;
		sets -e -forceElement asFaceBrownSG ($upperLower+"Lip3"+$side);
		$posA=`xform -q -ws -t ($upperLower+"Lip3"+$side)`;
		$posB=`xform -q -ws -t ($upperLower+"LipOuter3")`;
		scale -r -p $posA[0] $posA[1] $posA[2] 0.5 0.5 0.5 ($upperLower+"Lip3"+$side+".cv[0:6][0:7]");
		xform -ws -r -t (($posB[0]-($posA[0]*$b))*2) (($posB[1]-$posA[1])*2) (($posB[2]-$posA[2])*2) ($upperLower+"Lip3"+$side+".cv[0:6][0:7]");
		}
	}
select -cl;
}

global proc asAdvancedTongue ()
{
global string $gSelect;
setToolTo $gSelect;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
if ($tongue=="")
	return;
float $pos[];
float $scale=`asFaceGetScale`/3.0;
string $tongueSkinCluster="";
string $tempString[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//Display only tongue geo
if (!`gmatch $tongue "*[.]*"`)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
		if (!`getAttr -l ($allFaceGeo[$i]+".v")`)
			setAttr ($allFaceGeo[$i]+".v") 0;
		}
	setAttr ($tongue+".v") 1;
	}

for ($i=0;$i<5;$i++)
	{
	select -cl;
	joint -n ("Tongue"+$i+"_M");
	$pos=`xform -q -ws -t ("TongueCurve.cv["+$i+"]")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i+"_M");
	if ($i>0)
		delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 ("Tongue"+$i+"_M") ("Tongue"+($i-1)+"_M")`;
	if ($i==0)
		parent Tongue0_M FaceDeformationFollowHead;
	else
		parent ("Tongue"+$i+"_M") ("Tongue"+($i-1)+"_M");
	}
for ($i=0;$i<5;$i++)
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("Tongue"+$i+"_M");
setAttr -type float3 Tongue4_M.jo 0 0 0;
setAttr Tongue0_M.overrideEnabled 0;
setAttr Tongue0_M.segmentScaleCompensate 0;
/*
if (`objExists FKJaw_M`)
	{
	parentConstraint -mo FKJaw_M Tongue0_M;
	scaleConstraint FKJaw_M Tongue0_M;
	}
*/
//Polycube skin method
polyCube -n tempWeightCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 4 -ax 0 1 0 -cuv 4 -ch 1;
xform -s $scale $scale $scale tempWeightCube;
float $bb[]=`xform -q -ws -bb $tongue`;

select -r tempWeightCube.vtx[10:13] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[0]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[8:9] tempWeightCube.vtx[14:15] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[1]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[6:7] tempWeightCube.vtx[16:17] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[2]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[4:5] tempWeightCube.vtx[18:19] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[3]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[0:3] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[4]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

duplicate -n tempWeightCube2 tempWeightCube;
select -r tempWeightCube2 Tongue3_M Tongue2_M Tongue1_M Tongue0_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] tongueBoxSC;
//	skinCluster -n tongueBoxSC -dr 4 -lw false -wt 1 -mi 1;
select -r tempWeightCube2.vtx[10:13] ;
skinPercent -tv Tongue0_M 1 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[8:9] tempWeightCube2.vtx[14:15] ;
skinPercent -tv Tongue0_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv Tongue1_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[6:7] tempWeightCube2.vtx[16:17] ;
skinPercent -tv Tongue1_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv Tongue2_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[4:5] tempWeightCube2.vtx[18:19] ;
skinPercent -tv Tongue2_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv Tongue3_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[0:3] ;
skinPercent -tv Tongue3_M 1 tongueBoxSC `ls -sl`;

string $historyNodes[];
tokenize $tongue $tempString;
if(size($tempString))
	$historyNodes=`listHistory $tempString[0]`;
else
	$historyNodes=`listHistory $tongue`;
for ($i=0;$i<size($historyNodes);$i++)
	if (`objectType $historyNodes[$i]`=="skinCluster")
		if (!`gmatch $historyNodes[$i] "prefix_*"` && $historyNodes[$i]!="squashIKSC")
			{
			$tongueSkinCluster=$historyNodes[$i];
			break;
			}
if ($tongueSkinCluster=="")
	{
	select -r $tongue Tongue3_M Tongue2_M Tongue1_M Tongue0_M;
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	rename $tempString[0] tongueSC;
//		skinCluster -n tongueSC -dr 4 -lw false -wt 1 -mi 1;
	$tongueSkinCluster="tongueSC";
	}
else
	skinCluster -e -wt 0 -ai Tongue3_M -ai Tongue2_M -ai Tongue1_M -ai Tongue0_M $tongueSkinCluster;

/*
//move prefix_ inf joints, since in a rebuild case, weights gets copied to these joints instead of new ones
$tempString=`listConnections -type joint -s 1 -d 0 $tongueSkinCluster`;
skinCluster -e -moveJointsMode 1 $tongueSkinCluster;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "prefix_*"`)
		if(`objExists $tempString[$i]`)
			move -r 0 0 -10 $tempString[$i];
skinCluster -e -moveJointsMode 0 $tongueSkinCluster;
*/

eval ("select tempWeightCube2 "+$tongue);
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
skinCluster -e -removeUnusedInfluence 1 $tongueSkinCluster;
delete tempWeightCube tempWeightCube2;

for ($i=0;$i<4;$i++)
	{
	$tempString=`circle -c 0 0 0 -nr 1 0 0 -sw 360 -r 0.5 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
	rename $tempString[0] ("FKTongue"+$i+"_M");
	scale -r -p 0 0 0 0 ($bb[4]-$bb[1]) ($bb[3]-$bb[0]) ("FKTongue"+$i+"_M.cv[0:7]");
	sets -add FaceControlSet ("FKTongue"+$i+"_M");
	setAttr ("FKTongue"+$i+"_MShape.overrideEnabled") 1;
	setAttr ("FKTongue"+$i+"_MShape.overrideColor") 17;
	createNode -n ("FKOffsetTongue"+$i+"_M") transform;
	parent ("FKTongue"+$i+"_M") ("FKOffsetTongue"+$i+"_M");
	if ($i==0)
		parent ("FKOffsetTongue"+$i+"_M") FKJaw_M;
	else
		parent ("FKOffsetTongue"+$i+"_M") ("FKTongue"+($i-1)+"_M");
	asAlign ("FKOffsetTongue"+$i+"_M") ("Tongue"+$i+"_M") 1 1 0 0;
	parentConstraint ("FKTongue"+$i+"_M") ("Tongue"+$i+"_M");
	scaleConstraint ("FKTongue"+$i+"_M") ("Tongue"+$i+"_M");
	}
//asConnectTongueControl;
select -cl;
}

global proc asFaceSkinSim (string $faceTargets[], string $wrapDriver)
{
global string $gMainProgressBar;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $upperTeethVtxs[]=`sets -q upperTeethSet`;
string $lowerTeethVtxs[]=`sets -q lowerTeethSet`;
string $polyAverages[];

//Load custom cloth preset here. e.g:
//select tempNClothShape;
//AttributeEditor;
//applyPresetToNode "|tempNCloth|tempNClothShape" "" "" "C:/Program Files/Autodesk/Maya2015/presets/attrPresets/nCloth/putty.mel" 1;
//setAttr "tempNClothShape.ignoreSolverGravity" 1;

select -r tempTarget;
select -add $wrapDriver;
$tempString=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
rename $tempString[0] tempWrap;
setAttr tempWrap.autoWeightThreshold 0;
setAttr tempWrap.maxDistance 0.001;
setAttr tempWrap.exclusiveBind 1;
if (`objExists lipArea`)
	sets -remove lipArea mouthGeoBase.vtx[0:99999];

//remove teeth from wrapSet
$tempString=`listConnections tempWrap.message`;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!="FaceAllSet")
		rename $tempString[$i] tempWrapSet;
sets -remove tempWrapSet $upperTeethVtxs $lowerTeethVtxs;

//tempTargetLeft
createNode -n flipGroup transform;
duplicate -n tempTargetLeft tempTarget;
parent tempTargetLeft flipGroup;
setAttr flipGroup.sx -1;
select -r tempTargetLeft;
select -add tempTarget;
$tempString=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
rename $tempString[0] tempWrap2;
setAttr tempWrap2.exclusiveBind 1;

select tempTarget;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 999 -dp 999 0 0 -da 1 0 0;
InvertSelection;
int $rightVtxNrs[]=`asFaceSelVtxIntArray`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 0.001 -dp 0 0 0 -da 1 0 0;
int $centerVtxNrs[]=`asFaceSelVtxIntArray`;
polySelectConstraint -m 0;

int $time=-5;
progressBar -e -st ("Setup EyeBrow") -bp -ii 0 -min 0 -max 24 $gMainProgressBar;
for ($i=0;$i<size($faceTargets);$i++)
	{
	if ($faceTargets[$i]=="mouth_wide_C")
		{
		select lipArea;
		for ($y=0;$y<2;$y++)
			{
			$tempString=`polyAverageVertex -i 10 -ch 1`;
			$polyAverages[$y]=$tempString[0];
			}
		}

//	currentTime 0;
	currentTime $time;
	for ($y=0;$y<10;$y++)
		{
		$time++;
		currentTime $time;
		progressBar -e -s 1 $gMainProgressBar;
		}
	for ($y=0;$y<5;$y++)
		{
		currentTime ($time-1);	
		currentTime $time;	
		}
	duplicate -n $faceTargets[$i] tempTarget;

//	if (!`gmatch $faceTargets[$i] "*_R"`)
//		continue;

	//mirror target
	string $leftTarget=`substitute "_R" $faceTargets[$i] "_L"`;
	if (!`gmatch $faceTargets[$i] "*_R"`) $leftTarget+="_L";
	duplicate -n $leftTarget tempTargetLeft;
	parent $leftTarget faceTargets;
	xform -ws -t 0 0 0 -ro 0 0 0 -s 1 1 1 $leftTarget;

	if ($faceTargets[$i]=="mouth_wide_C") delete $polyAverages;

	if (!`gmatch $faceTargets[$i] "*_R"`)
		{
		select -r $leftTarget $faceTargets[$i];
		blendShape -n tempBS -w 0 1;

		for ($y=0;$y<size($rightVtxNrs);$y++)
			setAttr ("tempBS.inputTarget[0].inputTargetGroup[0].targetWeights["+$rightVtxNrs[$y]+"]") 0;
		for ($y=0;$y<size($centerVtxNrs);$y++)
			setAttr ("tempBS.inputTarget[0].inputTargetGroup[0].targetWeights["+$centerVtxNrs[$y]+"]") 0.5;
		select $faceTargets[$i];
		DeleteHistory;
		delete $leftTarget;
		}
}
delete flipGroup;
currentTime 0;
progressBar -e -ep $gMainProgressBar;
}

global proc asFaceClothConstraint (string $nurbs, float $maxDistance)
{
nurbsToPoly -n ($nurbs+"Poly") -mnd 1 -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 32 -vt 1 -vn 16 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 $nurbs;
setAttr ($nurbs+"Poly.v") 0;
select -r mouthGeo ($nurbs+"Poly");
$tempString=`createNConstraint pointToPoint 0`;
$tempString2=`listRelatives -p $tempString[0]`;
rename $tempString2[0] ($nurbs+"NClothRigid");
$tempString2=`listRelatives -p $tempString[1]`;
rename $tempString2[0] ($nurbs+"NClothConstraint");
setAttr ($nurbs+"NClothConstraint.constraintMethod") 2;
setAttr ($nurbs+"NClothConstraint.connectionMethod") 1;
setAttr ($nurbs+"NClothConstraint.maxDistance") $maxDistance;//using 1% of facescale as skinOffset
}

global proc asFaceCreateTestDuplicate ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
if ($geometry=="")
	error "No \"Face\" Geometry choosen yet";
if (!`objExists $geometry`)
	error ("Face Geometry:\""+$geometry+"\" not found");
createNode -n FaceSymmetryTestGroup transform;
duplicate -n FaceSymmetryTest $geometry;
parent FaceSymmetryTest FaceSymmetryTestGroup;
asLockAttr FaceSymmetryTestGroup 1 1 0 1;
setAttr -k 0 -l 1 FaceSymmetryTestGroup.sy;
setAttr -k 0 -l 1 FaceSymmetryTestGroup.sz;
setAttr FaceSymmetryTestGroup.sx -1;
select FaceSymmetryTestGroup;
connectControl asFaceDuplicateSlider FaceSymmetryTestGroup.sx;
}

global proc asFaceWrapDeformToFace ()
{
float $pos[];
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $shape;
string $tempString[];
//remove possible defomers first
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	if (size($tempString)<2)
		continue;
	$tempString=`listRelatives -ni -s $sel[$i]`;
	delete `listRelatives -s -ni $sel[$i]`;
	$tempString=`listRelatives -s $sel[$i]`;
	$shape=$tempString[0];
	setAttr ($shape+".intermediateObject") 0;
	$tempString=`listConnections -p 1 ($shape+".worldMesh[0]")`;
	if (size($tempString))
		disconnectAttr ($shape+".worldMesh[0]") $tempString[0];
	print ("// Deleting history for \""+$sel[$i]+"\", to avoid double deformations;\n");
	}
for ($i=0;$i<size($sel);$i++)
	{
	select -r $sel[$i];
	select -add $geometry;
	$tempString=`doWrapArgList "6" { "1","0","1", "2", "0", "1", "1", "0" }`;
	rename $tempString[0] eyeBrowWrap;
	}
print ("// WrapDeformer created\n");
}

global proc asFaceWireDeformToFace ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster,$side;
string $tempString[];

if (!`objExists EyeBrowWire`)
	{
	currentTime 0;
	duplicate -n EyeBrowWireCurve_R EyeBrowMainCurve;
	createNode -n EyeBrowWire -p FaceDeformationSystem transform;
	parent EyeBrowWireCurve_R EyeBrowWire;
	duplicate -n EyeBrowWireCurve_L EyeBrowWireCurve_R;
	setAttr EyeBrowWireCurve_L.sx -1;
	makeIdentity -a 1 -t 0 -r 0 -s 1 EyeBrowWireCurve_L;

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		select -r ("EyeBrowWireCurve"+$side) $geometry;
		$tempString=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
		rename $tempString[0] ("EyeBrowCurveWrap"+$side);
		if (`objExists asFaceBS`)
			connectAttr -f asFaceBS.outputGeometry[0] ("EyeBrowCurveWrap"+$side+".driverPoints[0]");
		rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.000393701 ("EyeBrowWireCurve"+$side);
		}
	}

for ($i=0;$i<size($sel);$i++)
	{
	$side="_R";
	float $bb[]=`xform -q -ws -bb $sel[$i]`;
	if ((($bb[0]+$bb[3])/2.0)>0)
		$side="_L";

	$tempString=`wire -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ("EyeBrowWireCurve"+$side) $sel[$i]`;
	$tempString[0]=`rename $tempString[0] ("EyeBrowWire"+$side)`;
	string $wireDeformer=$tempString[0];

	$skinCluster="";
	string $historyNodes[]=`listHistory -pdo 1 -il 2 $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$skinCluster=$historyNodes[$y];
			}

	if (`objExists $skinCluster`)
		{
		reorderDeformers $skinCluster $wireDeformer $sel[$i];
		//copySkinWeights from face (to get EyeBrow joint weights)
		skinCluster -e -ai ("browInnerJoint"+$side) -ai ("browHalfJoint"+$side) -ai ("browOuterJoint"+$side) -lw false -wt 0 $skinCluster;
		select $geometry $sel[$i];
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		}
	}
print "// Wire deformer added.\n";
select $sel;
}

global proc asFaceSkinEyeLashes ()
{
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "Nothing selected";
//string $geometry=`textField -q -tx asFaceGeometryTextField`;
//string $geometryFaces=`asGetGeometryFaces`;
int $numLid,$haveSkinCluster;
string $skinCluster;
string $tempString[],$historyNodes[];

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		for ($y=1;$y<99;$y++)
			{
			if (`objExists ($upperLower+"LidMain"+$y+$side)`)
				$numLid=$y;
			else
				break;
			}

		polyPlane -n ($upperLower+"EyeLidCage"+$side) -w 1 -h 1 -sx ($numLid-1) -sy 1 -ax 0 1 0 -cuv 2 -ch 1;
		for ($y=1;$y<$numLid+1;$y++)
			{
			$pos=`xform -q -ws -t ($upperLower+"LidMain"+$y+$side)`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			$pos=`xform -q -ws -t FitEyeBall`;
			scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 4 4 4 ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			}
		select ($upperLower+"EyeLidCage"+$side);
		for ($y=1;$y<$numLid+1;$y++)
			select -add ($upperLower+"LidMain"+$y+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"EyeLidCageSC"+$side);
		select EyeLidRegion ($upperLower+"EyeLidCage"+$side);
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		
		for ($y=1;$y<$numLid+1;$y++)
			{
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			artAttrSkinWeightCopy;
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			artAttrSkinWeightPaste;
			}
		}
	}

select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
for ($i=0;$i<size($sel);$i++)
	{
	$historyNodes=`listHistory $sel[$i]`;
	$haveSkinCluster=0;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	select $sel[$i];
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";

			for ($y=1;$y<99;$y++)
				{
				if (`objExists ($upperLower+"LidMain"+$y+$side)`)
					$numLid=$y;
				else
					break;
				}

			if ($haveSkinCluster)
				for ($y=1;$y<$numLid+1;$y++)
					catchQuiet (`skinCluster -e -ai ($upperLower+"LidMain"+$y+$side) -lw false -wt 0 $skinCluster`);
			if (!$haveSkinCluster)
				{
				for ($y=1;$y<$numLid+1;$y++)
					select -add ($upperLower+"LidMain"+$y+$side);
				}
			}
		}
	if (!$haveSkinCluster)
		{
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=`rename $tempString[0] ($sel[$i]+"EyeLashSC")`;
		}

	select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
	select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
delete upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;

//cluster
for ($i=0;$i<size($sel);$i++)
	{
	if (`objExists ($sel[$i]+"Cluster")`)
		delete ($sel[$i]+"Cluster");
	select $sel[$i];
  $tempString=`newCluster " -envelope 1"`;
  rename $tempString[0] ($sel[$i]+"Cluster");
  rename $tempString[1] ($sel[$i]+"ClusterHandle");
  setAttr ($sel[$i]+"Cluster.relative") 0;
	float $bb[]=`xform -q -ws -bb $sel[$i]`;
	if ($bb[0]<0 && $bb[3]<0)
		parent ($sel[$i]+"ClusterHandle") EyeRegion_R;
	else if ($bb[0]>0 && $bb[3]>0)
		parent ($sel[$i]+"ClusterHandle") EyeRegion_L;
	else
		error ("Unable to determine if \""+$sel[$i]+"\" belongs to Right or Left Eye");
	}

select $sel;
}

global proc asFaceDeleteFromCheckBox (string $region)
{
string $dialog=`confirmDialog -t "Confirm"
	-m ("Delete "+$region)
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	{
	checkBox -e -v 1 ("asFaceFit"+$region);
	return;
	}
if (`objExists ("FaceFit"+$region)`)
	delete ("FaceFit"+$region);
checkBox -e -ed 0 ("asFaceFit"+$region);
}

global proc asEnsureSelectionCompleteLoop ()
{
string $borderVtxs[]=`ls -sl -fl`;
int $neighboursInLoop,$neighboursInLoop2,$expandsBeforeHit,$closestNr;
for ($i=0;$i<size($borderVtxs);$i++)
	{
	select $borderVtxs[$i];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $borderVtxs[$i];
	$tempString=`ls -sl -fl`;
	$neighboursInLoop=0;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $tempString[$y] $borderVtxs`)
			$neighboursInLoop++;

	if ($neighboursInLoop<2)
		{
		//edgeloop not complete, must add vtx`s.
		for ($y=0;$y<size($tempString);$y++)
			{
			if (`stringArrayCount $tempString[$y] $borderVtxs`)
				continue;
			select $tempString[$y];
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d $tempString[$y] $borderVtxs[$i];
			$tempString2=`ls -sl -fl`;
			int $foundSolution=0;
			for ($z=0;$z<size($tempString2);$z++)
				if (`stringArrayCount $tempString2[$z] $borderVtxs`)
					if (!`stringArrayCount $tempString[$y] $borderVtxs`)
						{
						$borderVtxs[size($borderVtxs)]=$tempString[$y];
						$foundSolution=1;
						}
			if (!$foundSolution)
				for ($z=0;$z<size($tempString2);$z++)
					{
					if ($foundSolution)continue;
					select $tempString2[$z];
 					ConvertSelectionToEdges;
					ConvertSelectionToVertices;
					select -d $tempString2[$z];
					$tempString3=`ls -sl -fl`;
					for ($q=0;$q<size($tempString3);$q++)
  					if (`stringArrayCount $tempString3[$q] $borderVtxs`)
  						{
							if (`stringArrayCount $tempString3[$q] $tempString`)
							    continue;
							if (!`stringArrayCount $tempString2[$z] $borderVtxs`)
								$borderVtxs[size($borderVtxs)]=$tempString2[$z];
							if (!`stringArrayCount $tempString[$y] $borderVtxs`)
								$borderVtxs[size($borderVtxs)]=$tempString[$y];
              $foundSolution=1;                             
							}
					}
			}
		}
	}
select $borderVtxs;
}
global proc asSmoothFlood (string $infA, string $infB, int $numSmoo)
{
global string $gSelect;
string $selO[]=`ls -sl -o`;

string $tempString[]=`listHistory $selO[0]`;
string $skinCluster;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="skinCluster")
		$skinCluster=$tempString[$y];

//string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $infJoints[]=`listConnections ($skinCluster+".matrix")`;

if ($infB!="")
	for ($i=0;$i<size($infJoints);$i++)
		{
		setAttr ($infJoints[$i]+".lockInfluenceWeights") 1;
		if ($infJoints[$i]==$infA || $infJoints[$i]==$infB)
			setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
		}

ArtPaintSkinWeightsTool; 
artAttrSkinPaintCtx -e -sao smooth -influence $infA artAttrSkinContext;
artSkinInflListChanging $infA 1;
artSkinInflListChanged artAttrSkinPaintCtx;
for ($i=0;$i<$numSmoo;$i++)
	artFloodSurfaces;

for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
setToolTo $gSelect;
}

global proc asSkinTeeth ()
{
global string $gMainProgressBar;
global string $gSelect;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $upperTeethJoint="TeethUpper_M";
string $lowerTeethJoint="TeethLower_M";
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $tempString[];

//make sure teeth geo is in vtxs
if ($upperTeeth!="") 
	{
	eval ("select "+$upperTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$upperTeeth=`stringArrayToString $tempString " "`;
	}
if ($lowerTeeth!="") 
	{
	eval ("select "+$lowerTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$lowerTeeth=`stringArrayToString $tempString " "`;
	}

//teeth
string $upperLower,$teeth,$teethJoint,$teethObject;
string $teethObjects[];
string $teethSC=$skinCluster;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$teeth=$upperTeeth;$teethJoint=$upperTeethJoint;}
	else {$upperLower="lower";$teeth=$lowerTeeth;$teethJoint=$lowerTeethJoint;}
		
	if ($teeth=="")
		continue;

  eval ("select "+$teeth);
  $teethObjects=`ls -sl -o`;

	for ($i=0;$i<size($teethObjects);$i++)
		{
		$teethObject=$teethObjects[$i];
		int $haveSkinCluster=0;
	
		string $historyNodes[]=`listHistory -pdo 1 -il 2 $teethObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$teethSC=$historyNodes[$y];
				}
		if (!$haveSkinCluster)
			{
			select $teethJoint;
			select -add $teethObjects[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString[0] ($upperLower+"TeethSC");
			}
		else
			{
			$tempString=`listConnections ($teethSC+".matrix")`;
			if (!`stringArrayCount $teethJoint $tempString`)
				skinCluster -e -ai $teethJoint -lw false -wt 0 $teethSC;
			eval ("select "+$teeth);
			skinPercent -tv $teethJoint 1 $teethSC `ls -sl`;
			}
		}
	}
//Temp skin tongue as well, for easier jaw-weighting
if ($tongue!="")
	{
	eval ("select "+$tongue);
	$tempString=`ls -sl -o`;
	string $tongueObject=$tempString[0];
	int $haveSkinCluster=0;
	string $historyNodes[]=`listHistory -pdo 1 -il 2 $tongueObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$skinCluster=$historyNodes[$y];
				}
	if (!$haveSkinCluster)
		{
		select $lowerTeethJoint;
		select -add $tongueObject;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] TongueSC;
		}
	else
		{
		$tempString=`listConnections ($skinCluster+".matrix")`;
		if (!`stringArrayCount $lowerTeethJoint $tempString`)
			skinCluster -e -ai $lowerTeethJoint -lw false -wt 0 $skinCluster;
		eval ("select "+$tongue);
		skinPercent -tv $lowerTeethJoint 1 $skinCluster `ls -sl`;
		}
	}

setToolTo $gSelect;
}

global proc asSkinJawPartB ()
{
global string $gMainProgressBar;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $upperTeethJoint="TeethUpper_M";
string $lowerTeethJoint="TeethLower_M";
string $vtx;
string $tempString[],$borderVtxs[];
float $pos[],$posA[],$posB[],$posC[];

string $deleteObjs[]={"jawArea","grownUpLipVtxs","grownUpLipVtxsInverse"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];


//select vtx`s from Jaw region curves
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempPointOnCurveInfo.position tempLoc.t;

asCreateSamplerMesh $geometry;
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr -f tempLoc.worldPosition closestSampler.inPosition;

select -cl;
progressBar -e -st ("Setup JawArea") -bp -ii 0 -min 0 -max (98*2*4) $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	setAttr tempLocFlip.sx $b;
	for ($a=1;$a<5;$a++)
		{
		connectAttr -f ("JawBorderCurveShape"+$a+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
		for ($i=0;$i<99;$i++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			setAttr tempPointOnCurveInfo.parameter ($i*0.01);
//			refresh;
			$vtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
			if (!`stringArrayCount $vtx $borderVtxs`)
				$borderVtxs[size($borderVtxs)]=$vtx;
			}
		}
	}
select $borderVtxs;
GrowPolygonSelectionRegion;//Thicken the `Border` for the `Jaw-shell`.
$borderVtxs=`ls -sl -fl`;

//Find center vtx to grow from
$posA=`xform -q -ws -t lowerLipCylinder.cv[0][3]`;
spaceLocator -n tempGeoSnapLoc;xform -ws -t 0 $posA[1] $posA[2] tempGeoSnapLoc;
setAttr -l 1 tempGeoSnapLoc.tx;delete `geometryConstraint $geometry tempGeoSnapLoc`;
setAttr -l 0 tempGeoSnapLoc.tx;setAttr tempGeoSnapLoc.tx 0;
connectAttr -f tempGeoSnapLoc.worldPosition closestSampler.inPosition;
string $JawStartVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete samplerMesh closestSampler;
//delete tempGeoSnapLoc JawBorderCurve1 JawBorderCurve2 JawBorderCurve3 JawBorderCurve4;
delete tempGeoSnapLoc;


//grow until Jaw region, to create separate forhead object;
select $JawStartVtx;
for ($i=0;$i<50;$i++)
	{
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $borderVtxs; 
	refresh;
	}
select -d `sets -q foreHeadVtxs`;
GrowPolygonSelectionRegion;
select -d `sets -q eyeLidVtxs`;
string $jawArea[]=`ls -sl`;
if (size($jawArea)==0)
	error "Unable to determine the jawArea";
//Remove eyeLidVtxs+grownOnce, to avoid bleeding eyeLidWeights
select eyeLidVtxs;GrowPolygonSelectionRegion;
string $expandedEyeLidVtxs[]=`ls -sl`;
select $jawArea;
select -d $expandedEyeLidVtxs;
$jawArea=`ls -sl`;
createNode -n jawArea objectSet;
sets -add FaceBuildingSets jawArea;
sets -add jawArea $jawArea;

//define 50% vtxs & 0% vtxs (as a line from mouthCnr (noseCnr) to JawStart
duplicate -n JawMainCurve50 JawMainCurve;
$pos=`xform -q -ws -t upperLipCylinder.cv[6][3]`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve50.cv[0:1];
$pos=`xform -q -ws -t JawMain6`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve50.cv[5:6];
$posA=`xform -q -ws -t upperLipCylinder.cv[6][3]`;
$posB=`xform -q -ws -t JawMain6`;
$posC=`xform -q -ws -t JawMain3`;
$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
xform -ws -t ($posC[0]-$mag*0.1) (($posA[1]+$posB[1])/2.0) ($posC[2]+$mag*0.1) JawMainCurve50.cv[2:4];
duplicate -n JawMainCurve0 JawMainCurve;
$pos=`xform -q -ws -t Nose6`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve0.cv[0:1];
$pos=`xform -q -ws -t JawMain6`;
xform -ws -t $pos[0] $pos[1] $pos[2] JawMainCurve0.cv[5:6];
$posA=`xform -q -ws -t Nose6`;
$posB=`xform -q -ws -t JawMain6`;
$posC=`xform -q -ws -t JawMain3`;
xform -ws -t ($posC[0]-$mag*0.1) (($posA[1]+$posB[1])/2.0) ($posC[2]+$mag*0.1) JawMainCurve0.cv[2:4];

//All head first
select jawArea;
skinPercent -tv $headJoint 1 $skinCluster `ls -sl`;



//jaw line
asSelectCurveVtx JawMainCurve;
string $jawCurveVtxs[]=`ls -sl`;
skinPercent -tv Jaw_M 1 $skinCluster `ls -sl`;
asSelectCurveVtx JawMainCurve50;
string $jawCurve50Vtxs[]=`ls -sl`;
skinPercent -tv Jaw_M 0.5 $skinCluster `ls -sl`;
asSelectCurveVtx JawMainCurve0;
string $jawCurve0Vtxs[]=`ls -sl`;

//find $LipVtxs
$posA=`xform -q -ws -t upperLipCylinder.cv[0][3]`;
$posB=`xform -q -ws -t upperLipCylinder.cv[0][7]`;
float $lipRadius=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`/1.5;
select $geometry;
$pos=`xform -q -ws -t upperLipCylinder.cv[0][3]`;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $lipRadius -dp $pos[0] $pos[1] $pos[2];
if ($upperTeeth!="") eval ("select -d "+$upperTeeth);
if ($lowerTeeth!="") eval ("select -d "+$lowerTeeth);
string $upperLipVtxs[]=`ls -sl`;
if (!size($upperLipVtxs))
	error ("Failed to find $upperLipVtxs, within radius of \""+$lipRadius+"\" of upperLipCylinder.cv[0][3]");

$posA=`xform -q -ws -t lowerLipCylinder.cv[0][3]`;
$posB=`xform -q -ws -t lowerLipCylinder.cv[0][7]`;
$lipRadius=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`/1.5;
$pos=`xform -q -ws -t lowerLipCylinder.cv[0][3]`;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $lipRadius -dp $pos[0] $pos[1] $pos[2];
if ($upperTeeth!="") eval ("select -d "+$upperTeeth);
if ($lowerTeeth!="") eval ("select -d "+$lowerTeeth);
string $lowerLipVtxs[]=`ls -sl`;
polySelectConstraint -m 0;
if (!size($lowerLipVtxs))
	error ("Failed to find $lowerLipVtxs, within radius of \""+$lipRadius+"\" of lowerLipCylinder.cv[0][3]");


//find "$grownUpLipVtxs"
asCreateSamplerMesh $geometry;
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
$pos=`xform -q -ws -t Lip6`;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
string $sideLipVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
$pos=`xform -q -ws -t upperLip0`;
string $nearestInYVtx;
float $nearestInYDist=999;
for ($i=0;$i<size($upperLipVtxs);$i++)
	{
	$vtx=$upperLipVtxs[$i];
	float $pos2[]=`xform -q -ws -t $vtx`;
	float $dist=abs($pos[1]-$pos2[1]);
	if ($dist<$nearestInYDist)//closest in TY)
		{
		$nearestInYDist=$dist;
		$nearestInYVtx=$vtx;
		}
	}
select $nearestInYVtx;
string $grownUpLipVtxs[],$grownUpLipVtxsInverse[];
for ($i=0;$i<99;$i++)
	{
	GrowPolygonSelectionRegion;
	$tempString=`ls -sl -fl`;
	if (`stringArrayCount $sideLipVtx $tempString`)
		{
		$grownUpLipVtxs=`ls -sl`;
		sets -n grownUpLipVtxs;
		if (`objExists "Sets"`)
			sets -add "Sets" grownUpLipVtxs;
		InvertSelection;
		$grownUpLipVtxsInverse=`ls -sl`;
		sets -n grownUpLipVtxsInverse;
		if (`objExists "Sets"`)
			sets -add "Sets" grownUpLipVtxsInverse;
		break;
		}
	}

//update $upperLipVtxs[] & $lowerLipVtxs[], for up/lo lip separation
select $upperLipVtxs;
select -d $grownUpLipVtxsInverse;
$upperLipVtxs=`ls -sl`;
select $lowerLipVtxs;
select -d $grownUpLipVtxs;
$lowerLipVtxs=`ls -sl`;

//$noseEndVtx
$pos=`xform -q -ws -t Nose6`;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
string $noseEndVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete samplerMesh closestSampler;

skinPercent -tv Jaw_M 0.1 $skinCluster $upperLipVtxs;
skinPercent -tv Jaw_M 0.5 $skinCluster $sideLipVtx;
skinPercent -tv Jaw_M 0.9 $skinCluster $lowerLipVtxs;
skinPercent -tv Jaw_M 0.5 $skinCluster $jawCurve50Vtxs;

select jawArea;
select -d $jawCurveVtxs $upperLipVtxs $sideLipVtx $lowerLipVtxs $noseEndVtx;
select -d $jawCurve50Vtxs $jawCurve0Vtxs `sets -q eyeLidVtxs`;
weightHammerVerts;
select $jawCurveVtxs $upperLipVtxs $sideLipVtx $lowerLipVtxs $noseEndVtx $jawCurve50Vtxs $jawCurve0Vtxs;
weightHammerVerts;
select $jawCurve0Vtxs;GrowPolygonSelectionRegion;GrowPolygonSelectionRegion;
weightHammerVerts;

copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
select jawArea;
progressBar -e -ep $gMainProgressBar;
}

global proc asSelectCurveVtx (string $curve)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $tempString[]=`listRelatives -s $curve`;
string $curveShape=$tempString[0];

string $tmpObjs[]={"tempLocator","tempPointOnCurveInfo","samplerMesh","closestSampler"};
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
spaceLocator -n tempLocator;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
connectAttr -f ($curveShape+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
setAttr tempPointOnCurveInfo.parameter 0.5;
connectAttr tempPointOnCurveInfo.position tempLocator.t;
setAttr tempLocator.v 0;

asCreateSamplerMesh $geometry; 
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr tempLocator.worldPosition closestSampler.inPosition;
setAttr "tempPointOnCurveInfo.parameter" 1;
select -cl;
int $previousVtx;
for ($i=0;$i<99;$i++)
	{
	setAttr tempPointOnCurveInfo.parameter (0.01*$i);
	int $vtx=`getAttr closestSampler.result.closestVertexIndex`;
	if($vtx!=$previousVtx)
		{
		select -add ($geometry+".vtx["+$vtx+"]");
		string $currentSel[]=`ls -sl`;
//		refresh;
		select $currentSel;
		}
	$previousVtx=$vtx;
	}
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
}

global proc asFacePaintControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";

showRegion Clusters;
select $sel;

$tempString=`listConnections ($sel[0]+".s")`;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	asFacePaintClusterWeights;
	print "// Detected this controller to control a \"Cluster\", starting Cluster Painting Tool";
	}
else
	{
	tokenize $sel[0] "_" $tempString;
	if (!($tempString[1]=="R" || $tempString[1]=="L" || $tempString[1]=="M"))
		$error=1;
	string $joint=$tempString[0]+"Joint_"+$tempString[1];
	if (!`objExists $joint`)
		$error=1;
	if (!$error)
		{
		select $geometry;
		ArtPaintSkinWeightsTool;
		string $currentCtx = `currentCtx`;
		artSkinSelectInfluence artAttrSkinPaintCtx $joint;
		print "// Detected this controller to control a \"Joint\", starting Skin Weight Tool";
		}
	}
if ($error)
		error "Unable to detect which joint or cluster this is controlling";
}

global proc asFacePaintClusterWeights ()
{
global string $artSelectObject;
string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrun" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;
	
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $sel[]=`ls -sl`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
$fitJoint=$tempString[0];
$side="_"+$tempString[1];

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
setAttr ClustersRegion.v 1;

if ($dialog=="UnPrun")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ($geometry+".vtx[0:999999]");
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

artAttrToolScript 4 "cluster";
$artSelectObject="";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
select ClustersRegion;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
}

global proc showRegion (string $region)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $normal=0;
if ($region=="Normal") $normal=1;
setAttr ($geometry+".v") $normal;
string $regions[]=`listRelatives -c RegionDeformations`;
for ($i=0;$i<size($regions);$i++)
	setAttr ($regions[$i]+".v") 0;
if (!$normal) setAttr ($region+"Region.v") (!$normal);
setAttr -l 0 FaceDeformationSystem.v;
setAttr FaceDeformationSystem.v (!$normal);
setAttr -l 1 FaceDeformationSystem.v;
if ($normal) select -cl;
if (!$normal) select ($region+"Region");
}

global proc asCreateRegion ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $regionName;
string $tempString[];

for ($i=1;$i<99;$i++)
	{
	$regionName="Untitled"+$i;
	if (!`objExists ($regionName+"Region")`)
		break;
	}

duplicate -n ($regionName+"Region") $geometry;
$tempString=`listRelatives -s ($regionName+"Region")`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];

parent ($regionName+"Region") RegionDeformations;
sets -e -forceElement initialShadingGroup ($regionName+"Region");
blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` ($regionName+"Region") 1 asFaceBS;
setAttr ("asFaceBS."+$regionName+"Region") 1;
showRegion $regionName;

print ("// New Region \""+$regionName+"\" created, You can add your own custom deformations here\n");
}

global proc asBSWizardStop ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
text -e -l "..." asBSWizardObjAttrText;
text -e -l "..." asBSWizardValueText;
button -e -en 0 asBSWizardHelpButton;
button -e -en 0 asBSWizardNextButton;
if (`objExists deleteThis`)
	delete deleteThis;
if (`objExists tempAnimCurve`)
	delete tempAnimCurve;
asGoToBuildPose faceSetup;
}

global proc asBSWizard ()
{
button -e -en 1 asBSWizardNextButton;
button -e -en 1 asBSWizardHelpButton;
asGoToBuildPose faceSetup;
playbackOptions -min 1 -max 10 -ast 1 -aet 10;
asBSWizardNext;
}

global proc asBSWizardNext ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
int $step=$previousStep+1;

if (`objExists deleteThis`)
	delete deleteThis;
if (`objExists tempAnimCurve`)
	delete tempAnimCurve;
asGoToBuildPose faceSetup;

string $objAttr;
float $value;
if ($step==1)
	{$objAttr="ctrlBrow_R.translateY";$value=-1;}
if ($step==2)
	{$objAttr="ctrlBrow_R.translateY";$value=1;}
if ($step==3)
	{$objAttr="ctrlBrow_R.translateX";$value=1;}
if ($step==4)
	{$objAttr="ctrlBrow_R.translateX";$value=-1;}
if ($step==5)
	{$objAttr="ctrlBrow_R.squeeze";$value=10;}
if ($step==6)
	{$objAttr="ctrlBrow_R.outerUpDown";$value=10;}
if ($step==7)
	$step=8;
//	{$objAttr="ctrlBrow_R.outerUpDown";$value=-10;}
if ($step==8)
	{$objAttr="ctrlEye_R.squint";$value=10;}
if ($step==9)
	{$objAttr="ctrlCheek_R.translateY";$value=1;}
if ($step==10)
	{$objAttr="ctrlCheek_R.translateX";$value=1;}
if ($step==11)
	{$objAttr="ctrlCheek_R.translateX";$value=-1;}
if ($step==12)
	{$objAttr="ctrlNose_R.translateY";$value=1;}
if ($step==13)
	{$objAttr="ctrlNose_R.translateX";$value=1;}
if ($step==14)
	{$objAttr="ctrlNose_R.translateX";$value=-1;}
if ($step==15)
	$step=16;
//	{$objAttr="ctrlNose_R.furrowDeepener";$value=10;}
if ($step==16)
	$step=17;
//	{$objAttr="ctrlMouth_M.translateY";$value=-1;}
if ($step==17)
	{$objAttr="ctrlMouth_M.translateX";$value=1;}
if ($step==18)
	{$objAttr="ctrlMouth_M.translateX";$value=-1;}
if ($step==19)
	$step=22;
if ($step==22)
	$step=23;
//	{$objAttr="ctrlMouth_M.jawShut";$value=10;}
if ($step==23)
	$step=24;
//	{$objAttr="ctrlMouth_M.chinRaiser";$value=10;}
if ($step==24)
	$step=25;
//	{$objAttr="ctrlMouth_M.oh";$value=10;}
if ($step==25)
	$step=26;
//	{$objAttr="ctrlMouth_M.pucker";$value=10;}
if ($step==26)
	$step=32;
//	{$objAttr="ctrlMouth_M.funnel";$value=10;}
/*
if ($step==27)
	{$objAttr="ctrlMouth_M.lipPress_R";$value=10;}
if ($step==28)
	{$objAttr="ctrlMouth_M.lipUpperRoll_R";$value=10;}
if ($step==29)
	{$objAttr="ctrlMouth_M.lipUpperRoll_R";$value=-10;}
if ($step==30)
	{$objAttr="ctrlMouth_M.lipLowerRoll_R";$value=10;}
if ($step==31)
	{$objAttr="ctrlMouth_M.lipLowerRoll_R";$value=-10;}
*/
if ($step==32)
	{$objAttr="ctrlMouthCorner_R.translateY";$value=-1;}
if ($step==33)
	{$objAttr="ctrlMouthCorner_R.translateY";$value=1;}
if ($step==34)
	{$objAttr="ctrlMouthCorner_R.translateX";$value=1;}
if ($step==35)
	{$objAttr="ctrlMouthCorner_R.translateX";$value=-1;}
if ($step==36)
	$step=37;
//	{$objAttr="ctrlMouthCorner_R.dimpler";$value=10;}
if ($step==37)
	$step=38;
//	{$objAttr="ctrlMouthCorner_R.stretcher";$value=10;}
if ($step==38)
	{
	print ("// All Shapes Complete.\n");
	asBSWizardStop;
	if (`window -q -ex faceHelpImage`)
		deleteUI faceHelpImage;
	return;
	}

text -e -l ($step+"/"+$lastStep) asBSWizardStepText;
button -e -c ("asHelpImage asBSWizardStep"+$step) asBSWizardHelpButton;
if (`window -q -ex faceHelpImage`)
	asHelpImage ("asBSWizardStep"+$step);

text -e -l $objAttr asBSWizardObjAttrText;
text -e -l $value asBSWizardValueText;

print ("// "+$step+"/"+$lastStep+"\n");
evalEcho ("setAttr "+$objAttr+" "+$value);
asBSAdjustTarget;
}

global proc asBSResetTarget ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $tempString[],$resetTargets[];
if (!`objExists deleteThis`)
	error "Click create blendshape target first";
$tempString=`listRelatives deleteThis`;
$resetTargets[0]=$tempString[0];

setAttr asFaceBS.envelope 0;
duplicate -n asBSResetTarget $geometry;
setAttr asFaceBS.envelope 1;
parent asBSResetTarget deleteThis;
$tempString=`listRelatives -s asBSResetTarget`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
for ($i=0;$i<size($resetTargets);$i++)
	{
	select -r asBSResetTarget $resetTargets[$i];
	blendShape -n deleteThisResetBS -frontOfChain;
	setAttr deleteThisResetBS.asBSResetTarget 1;
	select $resetTargets[$i];
	DeleteHistory;
	}
delete asBSResetTarget;
select $sel;
}

global proc asBSExtractAll ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[],$tempString[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
//for ($i=0;$i<$lastStep;$i++)
createNode -n asBlendShapes transform;
for ($i=0;$i<$lastStep;$i++)
	{
	asBSWizardNext;
	if (`objExists asFaceMirroWrap`)
		{
		select `listConnections asFaceMirroWrap.outputGeometry`;
		DeleteHistory;
//		delete asFaceMirroWrap;
		}
	if (`text -q -l asBSWizardStepText`=="0/37")
		break;
	$tempString=`listRelatives -c deleteThis`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString[$y] "*_L"`)
			setAttr ($tempString[$y]+".v") 1;
		if (`getAttr ($tempString[$y]+".v")`)
			parent $tempString[$y] asBlendShapes;
		if (`gmatch $tempString[$y] "*_C"`)
			setAttr ($tempString[$y]+".tx") 0;
		setAttr ($tempString[$y]+".ty") (($i+1)*`asFaceGetScale`);
		}
	}
}

global proc asBSDeltaMushAll ()
{

string $geometry=`textField -q -tx asFaceGeometryTextField`;
select $geometry;
if (`checkBox -q -ex wbDeltaMush`)
	checkBox -e -v 0 wbDeltaMush;
asApplyDeltaMush;

if (`undoInfo -q -state`)
	{
	evalDeferred ("undoInfo -state 1;");
	undoInfo -state 0;
	}

string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
createNode -n runningDeltaMushAllTargets transform;
for ($i=0;$i<$lastStep;$i++)
	{
	asBSWizardNext;
	if (`text -q -l asBSWizardStepText`=="0/37")
		break;
	}

string $tempString[]=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="wbDeltaMush" || `objectType $tempString[$y]`=="deltaMush")
		evalDeferred ("delete "+$tempString[$y]);
if (`objExists runningDeltaMushAllTargets`)
	delete runningDeltaMushAllTargets;
}

global proc asBSAdjustTarget ()
{
select asFaceBS;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $targets[]=`listAttr -m asFaceBS.weight`;
string $targetLeft;
float $multiply=`floatFieldGrp -q -v1 asCreateTargetShapeMultiplier`;
if (`objExists runningDeltaMushAllTargets`)
	$multiply=`floatFieldGrp -q -v1 asDeltaMushShapeMultiplier`;
int $targetNum;
float $targetWeights[];
float $targetWeightsSum=0;
for ($i=0;$i<size($targets);$i++)
    {
		if (`gmatch $targets[$i] "*Region"`)
			continue;
    $targetWeights[$i]=`getAttr ("asFaceBS."+$targets[$i])`;
    $targetWeightsSum+=$targetWeights[$i];
    if ($targetWeights[$i]>0.99 && $targetWeights[$i]<1.01)
        $targetNum=$i;
    }
if ($targetWeightsSum>1.01 || $targetWeightsSum<0.99)
	{
	for ($i=0;$i<size($targets);$i++)
		if (!`gmatch $targets[$i] "*Region"`)
			if ($targetWeights[$i]>0.001 || $targetWeights[$i]<-0.001)
				print ("// asFaceBS."+$targets[$i]+" = "+$targetWeights[$i]+"\n");
	AttributeEditor;
  error "Must have one target set to \"1\", and the rest set to \"0\"\n";
  }
if (`objExists deleteThis`)
	delete deleteThis;
createNode -n deleteThis transform;
float $cheekPos[]=`xform -q -ws -t JawPivot`;
string $targetName=$targets[$targetNum];
if (`objExists $targetName`)
	error ("Object "+$targetName+" exists");
if (!`attributeExists ($targetName+"_tweaked") FaceFitSkeleton`)
	addAttr -k 1 -dv 1 -ln ($targetName+"_tweaked") -at bool FaceFitSkeleton;
setAttr ("FaceFitSkeleton."+$targetName+"_tweaked") 1;
if (`gmatch $targetName "*_R"`)
	{
	$targetLeft=`substitute "_R" $targetName "_L"`;
		if (!`attributeExists ($targetLeft+"_tweaked") FaceFitSkeleton`)
			addAttr -k 1 -dv 1 -ln ($targetLeft+"_tweaked") -at bool FaceFitSkeleton;
	setAttr ("FaceFitSkeleton."+$targetLeft+"_tweaked") 1;
	}
if ($multiply!=1)
	setAttr ("asFaceBS.w["+$targetNum+"]") $multiply;

setAttr ($skinCluster+".envelope") 0;
duplicate -n $targetName $geometry;
asLockAttr $targetName 0 0 0 0;
setAttr ($skinCluster+".envelope") 1;
parent $targetName deleteThis;
select $targetName;
string $tempString[]=`listRelatives -f -s $targetName`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
connectAttr -f ($targetName+".worldMesh[0]") ("asFaceBS.inputTarget[0].inputTargetGroup["+$targetNum+"].inputTargetItem[6000].inputGeomTarget");
refresh;//Maya2016 bug workaround
move -r ($cheekPos[0]*2.5) 0 0 $targetName;

if (`gmatch $targetName "*_R"`)
    {
    refresh;
    $targetLeft=`substitute "_R" $targetName "_L"`;
    setAttr asFaceBS.envelope 0;
    duplicate -n $targetLeft $geometry;
    asLockAttr $targetLeft 0 0 0 0;
    parent $targetLeft deleteThis;
    setAttr asFaceBS.envelope 1;
//    move -r ($cheekPos[0]*-2.5) 0 0 $targetLeft;
    move -r (`getAttr ctrlBox.tx`*2) 0 0 $targetLeft;
    $tempString=`listRelatives -f -s $targetLeft`;
    for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
    duplicate -n ($targetLeft+"MirrorDriver") $targetLeft;
    setAttr ($targetLeft+"MirrorDriver.sx") -1;
    setAttr ($targetLeft+"MirrorDriver.v") 0;

    select -r $targetLeft ($targetLeft+"MirrorDriver");
		CreateWrap;
    $tempString=`listConnections ($targetLeft+"MirrorDriver.inflType")`;
		rename $tempString[0] asFaceMirroWrap;
		setAttr asFaceMirroWrap.exclusiveBind 1;
    connectAttr -f ($targetName+".outMesh") ($targetLeft+"MirrorDriver.inMesh");
    
    for ($i=0;$i<size($targets);$i++)
        if ($targets[$i]==$targetLeft)
            connectAttr -f ($targetLeft+".worldMesh[0]") ("asFaceBS.inputTarget[0].inputTargetGroup["+$i+"].inputTargetItem[6000].inputGeomTarget");

//		setAttr ($targetLeft+".v") 0;
    }

floatSlider -e -en 1 asFaceBSFloatSlider;
connectControl asFaceBSFloatSlider ("asFaceBS."+$targetName);
select $targetName;
}

global proc asBSNewTarget ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSMirror;
$asDSMessage="Create New BlendShape";
$asDSAttrName="";
$asDSObjName="";
string $side;
string $tempString[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $cheekPos[]=`xform -q -ws -t JawPivot`;

if (!`asConfirmIfNotInBuildPose`)
	return;

string $dialogResult=`layoutDialog -t "Confirm" -ui asCreateDrivingSystemLayout`;
if ($dialogResult!="OK")
	return;
if ($asDSAttrName=="") $asDSAttrName="Untitled";
if ($asDSObjName=="") $asDSObjName="ctrlUntitled";
if (`objExists $asDSObjName`)
	{
	if (`gmatch $asDSObjName "*_R"`) $side="_R";
	else $side="_M";
	}
else
	{
	if ($asDSMirror) $side="_R";
	else $side="_M";
	}
if (`objExists $asDSAttrName`)
	error ("Object \""+$asDSAttrName+"\" Already Exists");

if (`objExists deleteThis`)
	delete deleteThis;

$targetName=$asDSAttrName;
$driverName=$asDSObjName;
duplicate -n ($targetName+$side) $geometry;
asLockAttr ($targetName+$side) 0 0 0 0;
createNode -n deleteThis transform;
parent ($targetName+$side) deleteThis;
$tempString=`listRelatives -s ($targetName+$side)`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
move -r ($cheekPos[0]*2.5) 0 0 ($targetName+$side);

//Mirrored target
if ($side=="_R")
  {
  refresh;
  duplicate -n ($targetName+"_L") ($targetName+$side);
  move -r ($cheekPos[0]*-5) 0 0 ($targetName+"_L");

  duplicate -n ($targetName+"_LMirrorDriver") ($targetName+"_L");
  setAttr ($targetName+"_LMirrorDriver.sx") -1;
  setAttr ($targetName+"_LMirrorDriver.v") 0;

  select -r ($targetName+"_L") ($targetName+"_LMirrorDriver");
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
	//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
  connectAttr -f ($targetName+$side+".outMesh") ($targetName+"_LMirrorDriver.inMesh");
  }

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1 && $side=="_M") break;
	if ($b==-1 && $side=="_R")
		{
		$side="_L";
		$driverName=`substitute "_R" $driverName "_L"`;
		}

	if (!`objExists $driverName`)
		{
		$driverName=$asDSObjName+$side;
		$tempString=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
		rename $tempString[0] $driverName;
		parent $driverName ctrlBox;
		$tempString=`listRelatives -s $driverName`;
		setAttr ($tempString[0]+".overrideEnabled") 1;
		setAttr ($tempString[0]+".overrideColor") 13;
		xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $driverName;
		if ($side!="_M") setAttr ($driverName+".tx") ($cheekPos[0]*0.2*$b);
		}
	if (!`attributeExists $targetName $driverName`)
		addAttr -k 1 -ln $targetName -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 $driverName;
	
	blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` ($targetName+$side) 1 asFaceBS;
	setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($driverName+"."+$targetName) ("asFaceBS."+$targetName+$side);
	setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv 10 -cd ($driverName+"."+$targetName) ("asFaceBS."+$targetName+$side);
	selectKey -add -k -f 0 -f 10 ("asFaceBS_"+$targetName+$side);
	setInfinity -pri cycleRelative -poi cycleRelative;

	string $setAttrCmdExtra="setAttr "+$driverName+"."+$targetName+" 0;";
	setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);
	}

select $driverName;
}

global proc asFaceCreatePlacementLocator (int $mirror, string $controlName)
{
string $side="_R";
if ($mirror)
	$side="_L";
else
	{
	if (`promptDialog -t "New Control" -m "Enter Name:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
		return;
	$controlName=`promptDialog -query -text`;
	}
if (`objExists ($controlName+$side)`)
	error ("Controller \""+$controlName+$side+"\" Already exists");

int $form,$spans,$degrees,$numCv;
$form=`getAttr upperEyeLidOuterCurve.form`;
$spans=`getAttr upperEyeLidOuterCurve.spans`;
$degrees=`getAttr upperEyeLidOuterCurve.degree`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;

spaceLocator -n ($controlName+"_placement");
float $posA[]=`xform -q -ws -t ("upperEyeLidOuterCurve.cv["+($numCv-1)+"]")`;
float $posB[]=`xform -q -ws -t ("upperEyeLidOuterCurve.cv[0]")`;
float $posC[];
$posC[0]=($posA[0]+$posB[0])/2.0;
$posC[1]=($posA[1]+$posB[1])/2.0;
$posC[2]=($posA[2]+$posB[2])/2.0 + ($posB[0]-$posA[0]);
xform -ws -t $posC[0] $posC[1] $posC[2] ($controlName+"_placement");
float $scale=($posB[0]-$posA[0])/2.0;
xform -os -r -s $scale $scale $scale ($controlName+"_placement");
addAttr -k 1 -ln placementLocator -at bool -dv true ($controlName+"_placement");
if ($mirror)
	{
	$posC=`xform -q -ws -t ($controlName+"_R")`;
	xform -ws -t ($posC[0]*-1) $posC[1] $posC[2] ($controlName+"_placement");
	$scale=`getAttr ($controlName+"_R.falloffRadius")`*2;
	xform -os -r -s $scale $scale $scale ($controlName+"_placement");
	}
select ($controlName+"_placement");
}

global proc asFaceCreateRubberControl ()
{
string $tempString[];
string $sel[]=`ls -sl`;
if (!`attributeExists placementLocator $sel[0]`)
	error "A placement locator must be selected";
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $controlName=`substitute "_placement"  $sel[0] ""`;
string $side="_R";
float $pos[]=`xform -q -ws -t $sel[0]`;
	if ($pos[0]>0)
		$side="_L";
if ($pos[0]>-0.001 && $pos[0]<0.001)
	$side="_M";
float $falloffRadius=`getAttr ($sel[0]+".sx")`;
delete $sel[0];

int $form,$spans,$degrees,$numCv;
$form=`getAttr upperEyeLidOuterCurve.form`;
$spans=`getAttr upperEyeLidOuterCurve.spans`;
$degrees=`getAttr upperEyeLidOuterCurve.degree`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;

if (!`objExists RubberSetup`)
	{
	string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
	string $allFaceGeo[],$tempString[];
	tokenize $allFaceGeoString $tempString;
	for ($i=0;$i<size($tempString);$i++)
		$allFaceGeo[$i]=$tempString[$i];
	select $allFaceGeo;

	$tempString=`lattice  -divisions 21 21 21 -objectCentered true  -ldv 2 2 2`;
	rename $tempString[0] rubberFfd;
	rename $tempString[1] rubberFfdLattice;
	rename $tempString[2] rubberFfdBase;
	$tempString=`listConnections rubberFfd.message`;
	rename $tempString[0] rubberFfdSet;
	setAttr rubberFfd.outsideLattice 1;

	float $rubberTopPos[3]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
	float $rubberBasePos[3]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
	float $rubberHeight=$rubberTopPos[1]-$rubberBasePos[1];
	float $rubberFrwPos[3]=`xform -q -ws -t ("upperEyeLidOuterCurve.cv["+(($numCv-1)/2)+"]") `;
	float $rubberWidthPos[3]=`xform -q -ws -t JawPivot`;
	float $rubberWidth=$rubberWidthPos[0]*2;
	float $scaleFactor=$rubberHeight;
	if ($rubberWidth>$rubberHeight)
		$scaleFactor=$rubberWidth;

	xform -ws -t 0 (($rubberTopPos[1]+$rubberBasePos[1])/2) $rubberFrwPos[2] rubberFfdLattice;
	xform -ws -t 0 (($rubberTopPos[1]+$rubberBasePos[1])/2) $rubberFrwPos[2] rubberFfdBase;
	xform -s $scaleFactor $scaleFactor $scaleFactor rubberFfdLattice;
	xform -s $scaleFactor $scaleFactor $scaleFactor rubberFfdBase;

	createNode -n RubberSetup -p FaceMotionSystem transform;
	createNode -n rubberLattice -p RubberSetup transform;
	parentConstraint $headJoint rubberLattice;
	scaleConstraint $headJoint rubberLattice;
	parent rubberFfdLattice rubberFfdBase rubberLattice; 
	
	setAttr -l 1 RubberSetup.v 0;
	if (`objExists squashFfd`)
		{
		//rubberFfd && squashFfd will not work well together, so instead have squashFfd only deform rubberFfd
		sets -rm squashFfdSet `sets -q squashFfdSet`;
		sets -add squashFfdSet rubberFfdLattice;
		}
	if (!`attributeExists RubberCtrlVis ctrlBox`)
		addAttr -k 1 -ln "RubberCtrlVis" -at bool -dv true ctrlBox;
	if (!`attributeExists RubberCtrlEnable ctrlBox`)
		addAttr -k 1 -ln "RubberCtrlEnable" -at bool -dv true ctrlBox;
	if (!`objExists RubberControls`)
		{
		createNode -n RubberControls -p ControlsSetup transform;
		connectAttr ctrlBox.RubberCtrlVis RubberControls.v;
		parentConstraint $headJoint RubberControls;
		scaleConstraint $headJoint RubberControls;
		createNode -n rubberOrigin transform;
		parent rubberOrigin RubberControls;
		}
	createNode -n RubberCtrlEnableReverse reverse;
	setAttr -type float3 RubberCtrlEnableReverse.input 1 1 1;
	connectAttr -f ctrlBox.RubberCtrlEnable RubberCtrlEnableReverse.inputX;
	connectAttr -f RubberCtrlEnableReverse.outputX rubberFfd.nodeState;
	}

asCreateFaceController $controlName $side 12;
rename ($controlName+"Subtract"+$side) ($controlName+"Origin"+$side);
asLockAttr ($controlName+"Origin"+$side) 0 1 1 1;
sets -add FaceControlSet ($controlName+"Origin"+$side);
xform -ws -t $pos[0] $pos[1] $pos[2] ($controlName+"Offset"+$side);
addAttr -k 1 -min 0 -dv $falloffRadius -ln falloffRadius -at double ($controlName+$side);
parent ($controlName+"Offset"+$side) RubberControls;
delete ($controlName+"Attach"+$side);
createNode -n ($controlName+"OriginReader"+$side) -p rubberOrigin transform;
pointConstraint ($controlName+"Origin"+$side) ($controlName+"OriginReader"+$side);
asFaceEnsureShaders;
sets -e -forceElement asFaceRedSG ($controlName+$side);
string $setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$controlName+$side+";";
$setAttrCmdExtra+="xform -a -os -t 0 0 0 "+$controlName+"Origin"+$side+";";
setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);

select -r rubberFfdLattice;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ($controlName+"latticeSoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($controlName+"latticeSoftModHandle"+$side)`;
$tempString=`listConnections ($softMod+".message")`;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") 0;
if (`objExists squashFfd`)
	catch (`reorderDeformers squashFfd ($controlName+"latticeSoftMod"+$side) rubberFfdLattice`);
if (`objExists squashFfdSet`)
	sets -add squashFfdSet ($controlName+$side);
parent $softModHandle RubberSetup;

setAttr -type float3 ($softModHandle+"Shape.origin") $pos[0] $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") $pos[0] $pos[1] $pos[2];
xform -piv $pos[0] $pos[1] $pos[2] $softModHandle;

connectAttr ($controlName+$side+".t") ($softModHandle+".t");
connectAttr ($controlName+$side+".r") ($softModHandle+".r");
connectAttr ($controlName+$side+".s") ($softModHandle+".s");
connectAttr ($controlName+$side+".falloffRadius") ($softMod+".falloffRadius");
connectAttr ($controlName+"OriginReader"+$side+".t") ($softMod+".falloffCenter");
select ($controlName+$side);
}

global proc asFaceSaveRubberFalloff ()
{
string $sel[]=`ls -sl`;
if ($sel[0]=="")
	error "Rubber Control must be selected";
if (!`sets -im FaceControlSet $sel[0]` || !`attributeExists falloffRadius $sel[0]`)
	error "Rubber Control must be selected";

string $existingCmd=`getAttr faceBuildPose.udAttr`;
string $tempString[];
tokenize $existingCmd ";" $tempString;
string $newCmd;
float $falloffRadius=`getAttr ($sel[0]+".falloffRadius")`;
$falloffRadius=`asRoundOff $falloffRadius 3`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`gmatch $tempString[$i] ("setAttr "+$sel[0]+"[.]falloffRadius *")`)
		$newCmd+=$tempString[$i]+";";
	}
$newCmd+="setAttr "+$sel[0]+".falloffRadius "+$falloffRadius+";";
setAttr -type "string" faceBuildPose.udAttr $newCmd;
print ("// Falloff radius stored to face buildPose\n");
}

global proc asFaceMirrorRubberControl ()
{
string $sel[]=`ls -sl`;
if ($sel[0]=="")
	error "Rubber Control to mirror, must be selected";
if (!`sets -im FaceControlSet $sel[0]` || !`attributeExists falloffRadius $sel[0]`)
	error "Rubber Control to mirror, must be selected";
if (!`gmatch $sel[0] "*_R"`)
	error "Rubber Control on Right side must be selected";
int $numChar=size($sel[0]);
string $controlName=`substring $sel[0] 1 ($numChar-2)`;

string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose faceSetup;
asFaceCreatePlacementLocator 1 $controlName;
asFaceCreateRubberControl;
eval($restorePoseCmd);
}

global proc asFaceMirrorRubberControl ()
{
string $sel[]=`ls -sl`;
if ($sel[0]=="")
	error "Rubber Control to mirror, must be selected";
if (!`sets -im FaceControlSet $sel[0]` || !`attributeExists falloffRadius $sel[0]`)
	error "Rubber Control to mirror, must be selected";
if (!`gmatch $sel[0] "*_R"`)
	error "Rubber Control on Right side must be selected";
int $numChar=size($sel[0]);
string $controlName=`substring $sel[0] 1 ($numChar-2)`;

string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose faceSetup;
asFaceCreatePlacementLocator 1 $controlName;
asFaceCreateRubberControl;
eval($restorePoseCmd);
}

global proc asFaceConvertSoftModToControl (int $convertingBack)
{
global string $gSelect;
string $sel[]=`ls -sl`;
asFaceEnsureAdvancedBase;
float $pos[3],$posSoftMod[3],$posControl[3],$currentT[3],$currentR[3],$currentS[3];
string $tempString[],$historyList[];
string $side;
int $multiply;
int $autoKeyState=`autoKeyframe -q -state`;
string $fitJoint,$restoreCmd,$setAttrCmdExtra,$softModSet;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*Handle*"`)
		$sel[0]=$sel[$i];

if ($convertingBack==1)
	{
	if (!`gmatch $sel[0] "convertedSoftModHandle_*"`)
		error "convertedSoftModHandle not selected";
	tokenize $sel[0] "_" $tempString;
	$fitJoint=$tempString[1];
	$side="_"+$tempString[2];
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+$side+".message")`;
	$softModSet=$tempString[0];
	}
else
	{
	string $allBefore[]=`ls`;
	if (!`gmatch $sel[0] "softMod*"`)
		error "Selection is not a new SoftMod, name does not match \"softMod*\"";
	if ($convertingBack==0)
		{
		if (`promptDialog -t "New Control" -m "Enter Name:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
			return;
		$fitJoint=`promptDialog -query -text`;
		}
	if (`objExists $fitJoint` || $fitJoint=="")
		error "not a unique name";
	setToolTo $gSelect;

	//find $side, when tx=0
	float $locPos[3]=`getAttr ($sel[0]+".t")`;
	setAttr -type float3 ($sel[0]+".t") 0 0 0;
	float $pos[3]=`xform -q -ws -piv $sel[0]`;
	setAttr -type float3 ($sel[0]+".t") $locPos[0] $locPos[1] $locPos[2];
	$side="_M";
	if (!`checkBox -q -v asFaceIsMiddleControlCheckBox`)
		$side="_R";
	if ($pos[0]>0.001)
		error "SoftMod must be on Right side, or middle, currenly on Left side";

	$sel[0]=`rename $sel[0] ("convertedSoftModHandle_"+$fitJoint+$side)`;
	$tempString=`listConnections ("convertedSoftModHandle_"+$fitJoint+$side+".worldMatrix[0]")`;
	rename $tempString[0] ("convertedSoftMod_"+$fitJoint+$side);
	$tempString=`listConnections ("convertedSoftMod_"+$fitJoint+$side+".message")`;
	$softModSet=$tempString[0];
	string $deformObjs[]=`sets -q -no $softModSet`;
	$deformObjs=`stringArrayRemoveDuplicates $deformObjs`;

	$currentT=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t")`;
	$currentR=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r")`;
	$currentS=`getAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s")`;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".t") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".r") 0 0 0;
	setAttr -type float3 ("convertedSoftModHandle_"+$fitJoint+$side+".s") 1 1 1;
	$posSoftMod=`xform -q -ws -piv ("convertedSoftModHandle_"+$fitJoint+$side)`;
	curve -n tempCurve -d 1 -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -p $posSoftMod[0] $posSoftMod[1] $posSoftMod[2] -k 0 -k 1;
	deformer -type wrap tempCurve;
	select -r tempCurve;
	select -add ClustersRegion;
	AddWrapInfluence;

	$posControl=`xform -q -ws -t tempCurve.cv[0]`;
	createNode -n tempTransform transform;
	xform -ws -t $posControl[0] $posControl[1] $posControl[2] tempTransform;
	select tempTransform;
	int $color=6;
	if (size($deformObjs)>1)
		$color=9;
	asCreateFaceFitJoint $fitJoint `getAttr ("convertedSoftMod_"+$fitJoint+$side+".falloffRadius")` $color;
	setAttr ($fitJoint+".falloffMode") `getAttr ("convertedSoftMod_"+$fitJoint+$side+".falloffMode")`;
	softCluster $fitJoint $fitJoint 1 $side;
	
	if ($side=="_R")
		{
		//Mirror pose before doing left to ensure identical attachment
		string $restoreCmd=`asFaceMirror`;
		softCluster $fitJoint $fitJoint -1 "_L";
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_R;xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_L;";
	
		eval ($restoreCmd);
		if ($autoKeyState)
			autoKeyframe -state 1;
		}
	else
		$setAttrCmdExtra="xform -a -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$fitJoint+"_M;";


	delete tempCurve tempTransform;
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".t") $currentT[0] $currentT[1] $currentT[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".r") $currentR[0] $currentR[1] $currentR[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	setAttr ("convertedSoftModHandle_"+$fitJoint+$side+".s") $currentS[0] $currentS[1] $currentS[2] ("convertedSoftModHandle_"+$fitJoint+$side);
	//add to faceBuildPose
	setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);

	//FaceAllset
	string $allAfter[]=`ls`;
	string $allNew[];
	for ($i=0;$i<size($allAfter);$i++)
		if (!`stringArrayCount $allAfter[$i] $allBefore`)
			if (`objectType $allAfter[$i]`!="objectSet")
				$allNew[size($allNew)]=$allAfter[$i];
	sets -add FaceAllSet $allNew;
	sets -remove FaceAllSet `listRelatives -ad FaceFitSkeleton`;
	}

float $t[3]=`xform -q -ws -piv $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;

$pos=`xform -q -ws -t $fitJoint`;
string $softMod=`substitute "convertedSoftModHandle" $sel[0] "convertedSoftMod"`;
string $cluster=$fitJoint+"Cluster"+$side;
float $falloffRadius=`getAttr ($softMod+".falloffRadius")`;

float $falloffMode=`getAttr ($softMod+".falloffMode")`;
setAttr ($fitJoint+".falloffRadius") $falloffRadius;
setAttr ($fitJoint+".falloffMode") $falloffMode;

select $softModSet;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$vtxs=`ls -sl -fl`;
polySelectConstraint -m 0;

if ($convertingBack)
	{
	percent -v 0 $cluster ClustersRegion;
	asFaceSoftModToCluster $softMod $cluster $vtxs;
	}
delete $softMod;
if ($convertingBack)
	{
	select ($fitJoint+$side);
	asFaceMirrorClusterWeight;
	}
xform -ws -t $t[0] $t[1] $t[2] -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] ($fitJoint+$side);
select ($fitJoint+$side);
}

global proc asFaceConvertControlToSoftMod ()
{
string $sel[]=`ls -sl`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a face control";
$tempString=`listConnections ($sel[0]+".s")`;
if (!`gmatch $tempString[0] "*Cluster*"`)
	error "Selected object is not a \"cluster\" control";
tokenize $sel[0] "_" $tempString;
string $fitJoint=$tempString[0];
string $side="_"+$tempString[1];
if ($side=="_L")
	error "must be Right side";

string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrun" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;

float $falloffRadius=`getAttr ($fitJoint+".falloffRadius")`;
float $falloffMode=`getAttr ($fitJoint+".falloffMode")`;

if ($dialog=="UnPrun")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ClustersRegion.vtx[0:999999];
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

float $t[3]=`xform -q -ws -t $sel[0]`;
float $r[3]=`xform -q -ws -ro $sel[0]`;
float $s[3]=`xform -q -r -s $sel[0]`;
setAttr -type float3 ($sel[0]+".t") 0 0 0;
setAttr -type float3 ($sel[0]+".r") 0 0 0;
setAttr -type float3 ($sel[0]+".s") 1 1 1;
float $pos[3]=`xform -q -ws -t $sel[0]`;
select -r ClustersRegion;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ("convertedSoftMod_"+$sel[0])`;
string $softModHandle=`rename $tempString[1] ("convertedSoftModHandle_"+$sel[0])`;
$tempString=`listConnections ($softMod+".message")`;
string $softModSet=$tempString[0];
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]) $pos[1] $pos[2];
xform -piv ($pos[0]) $pos[1] $pos[2] $softModHandle;
xform -ws -t ($t[0]-$pos[0]) ($t[1]-$pos[1]) ($t[2]-$pos[2]) -ro $r[0] $r[1] $r[2] -s $s[0] $s[1] $s[2] $softModHandle;

if (`getAttr ($fitJoint+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!="ClustersRegion")
			sets -add $softModSet $allFaceGeo[$i];
	}
select $softModHandle;
}

global proc string asFaceNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";
if ($nr==1) $letter="A";
if ($nr==2) $letter="B";
if ($nr==3) $letter="C";
if ($nr==4) $letter="D";
if ($nr==5) $letter="E";
if ($nr==6) $letter="F";
if ($nr==7) $letter="G";
if ($nr==8) $letter="H";
if ($nr==9) $letter="I";
return $letter;
}

global proc int asFaceLetterToNr (string $letter)
{
int $nr;
if ($letter=="") $nr=0;
if ($letter=="A") $nr=1;
if ($letter=="B") $nr=2;
if ($letter=="C") $nr=3;
if ($letter=="D") $nr=4;
if ($letter=="E") $nr=5;
if ($letter=="F") $nr=6;
if ($letter=="G") $nr=7;
if ($letter=="H") $nr=8;
if ($letter=="I") $nr=9;
return $nr;
}

global proc asChooseInput (string $textField)
{
int $confirmed;
float $tempFloat[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $txt,$dialog;
string $sel[]=`ls -sl`;
string $restoreSel[]=$sel;
string $tempString[];

if (!`gmatch $textField "*Joint*"`)
	{
	//Include children
	select -cl;
	string $children[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			select -add `listRelatives -ad -f -type transform $sel[$i]`;
	string $addedSel[]=`ls -sl`;
	$sel=`stringArrayCatenate $sel $addedSel`;
	$sel=`stringArrayRemoveDuplicates $sel`;

	//Not include non-mesh || non-nurbs (unless choose joint)
	string $shapes[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			{
			$nodeType="";
			$shapes=`listRelatives -s -ni -f $sel[$i]`;
			if (size($shapes))
				$nodeType=`nodeType $shapes[0]`;
			if ($nodeType!="nurbsSurface" && $nodeType!="mesh")
				$sel=`stringArrayRemove {$sel[$i]} $sel`;		
			}
	}
select $restoreSel;

$txt=$sel[0];

if (size($sel)>1)
	for ($i=1;$i<size($sel);$i++)
		$txt+=" "+$sel[$i];	

//FaceGeometry validate
if ($textField=="asFaceGeometryTextField" && $sel[0]!="")
	if (size($sel)>1)
		error "Face Geometry must be only 1 object";

//Everything must have skinCluster
string $skinCluster;
for ($i=0;$i<size($sel);$i++)
	{
	if ($textField=="asFaceHeadJointTextField")
		continue;
	$tempString=`listHistory $sel[$i]`;
	$skinCluster="";
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		{
		if ($dialog!="Create New SkinCluster")
			$dialog=`confirmDialog -t "Confirm"
			-m "No SkinCluster found on this geometry"
			-b "Create New SkinCluster" -db "Create New SkinCluster"
			-b "Cancel" -ds "Cancel"`;
		if ($dialog!="Create New SkinCluster")
			return;
		select -cl;
		if (!`objExists $headJoint`)
			{
			joint -n $headJoint;
			float $pos1[]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
			float $pos2[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
			xform -ws -t 0 ($pos1[1]+(($pos2[1]-$pos1[1])/3.0)) 0 $headJoint;
			}
		textField -e -tx $headJoint asFaceHeadJointTextField;
		select $sel[$i] $headJoint;
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		select $sel[$i];
		}
	if ($textField=="asFaceGeometryTextField")
		textField -e -tx $skinCluster asFaceSkinClusterTextField;
	}

//AllFaceGeo validate
if ($textField=="asFaceAllFaceGeoTextField" && $sel[0]!="")
	for ($i=0;$i<size($sel);$i++)
		{
		$tempString=`listRelatives -ni -s $sel[$i]`;
		if (!size($tempString))
			continue;
		if (!(`objectType $tempString[0]`=="mesh" || `objectType $tempString[0]`=="nurbsSurface"))
			continue;
		$tempString=`listHistory $sel[$i]`;
		$skinCluster="";
		for ($y=0;$y<size($tempString);$y++)
			if (`objectType $tempString[$y]`=="skinCluster")
				$skinCluster=$tempString[$y];
		if ($skinCluster=="")
			{
			if (!$confirmed)
				{
				$dialog=`confirmDialog -t "Confirm"
				-m "No SkinCluster found on some of the geometry"
				-b "Create New SkinClusters" -db "Create New SkinClusters"
				-b "Cancel" -ds "Cancel"`;
				if ($dialog!="Create New SkinClusters")
					return;
				}
			$confirmed=1;
			select -cl;
			if (!`objExists $headJoint`)
				joint -n $headJoint;
			select $sel[$i] $headJoint;
			$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
			}
		}

if (!`objExists FaceFitSkeleton`)
	error "First Create Face FitSkeleton Node";

asFaceEnsureFitBase;

textField -e -tx $txt $textField;
//optionVar -sv $textField $txt;
asFaceUpdateInfo 0;
}

global proc asFaceAddIn (string $targets[], string $transform, int $mo)
{
string $trAddIn=$transform+"AddIn";
createNode -n $trAddIn transform;
string $tempString[]=`listRelatives -p $transform`;
parent $trAddIn $tempString[0];
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $trAddIn;
string $cmd="parentConstraint";
if($mo)
	$cmd+=" -mo";
for ($i=0;$i<size($targets);$i++)
	$cmd+=" "+$targets[$i];
$cmd+=" "+$trAddIn;
eval $cmd;

string $trs[]={"t","r","s"};
for ($i=0;$i<size($trs);$i++)
	{
	createNode -n ($trAddIn+$trs[$i]+"plusMinusAverage") plusMinusAverage;
	if ($trs[$i]=="s")
		setAttr ($trAddIn+$trs[$i]+"plusMinusAverage.operation") 3;
	connectAttr ($trAddIn+"."+$trs[$i]+"x") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dx");
	connectAttr ($trAddIn+"."+$trs[$i]+"y") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dy");
	connectAttr ($trAddIn+"."+$trs[$i]+"z") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dz");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"x")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dx");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"y")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dy");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"z")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dz");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dx") ($transform+"."+$trs[$i]+"x");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dy") ($transform+"."+$trs[$i]+"y");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dz") ($transform+"."+$trs[$i]+"z");
	}
}

global proc float asFaceGetScale ()
{
float $scale=1.5;
if (`objExists FaceFitSkeletonHeightShape`)
    {
    float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
    float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
    $scale=$pos1[1]-$pos2[1];
   	}
return $scale;
}

global proc asCreateFaceFitJoint (string $region, float $size, int $color)
{
string $sel[]=`ls -sl -fl`;
float $pos[3]=`xform -q -ws -t $sel[0]`;
float $centerErrorMargin=0.001;
if ($region=="mouthUpper" || $region=="mouthLower" || $region=="eyeBrow0"
	|| `gmatch $region "*Middle"` || $region=="noseTip" || $region=="noseLower")
	if ($pos[0]>$centerErrorMargin || $pos[0]<(-1*$centerErrorMargin))
		error ($region+" needs to be in the center, currently:"+$pos[0]+"\n");
int $jointNumber;
string $jointName;
for ($i=1;$i<99;$i++)
	{
	$jointNumber=$i;
	$jointName=$region+$jointNumber;
	if (!`objExists $jointName`)
		break;
	}
asFaceEnsureFitBase;
for ($i=0;$i<size($sel);$i++)
	{
	$jointName=$region;
	if (size($sel)>1)
		$jointName=$region+$jointNumber;
	$jointNumber++;
	$jointName=`asFaceCreateFitJoint $jointName $size $color`;
	$pos=`xform -q -ws -t $sel[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $jointName;
	}

if (`checkBox -q -ex ("asFaceFit"+$region)`)
	checkBox -e -v 1 -ed 1 ("asFaceFit"+$region);
hilite -r `ls -o $sel`; 
select $sel;
repeatLast -addCommand ("asCreateFaceFitJoint "+$region+" "+$size+" "+$color);

if (`gmatch $region "eyeBrow[0-9]"`)
	asAutoEyeBrowFalloff $region;
}

global proc asAutoEyeBrowFalloff (string $region)
{
float $posA[3],$posB[3];
float $mag;
int $nr=`substring $region 8 8`;
string $previousRegion="eyeBrow"+($nr-1);
if (!`objExists $previousRegion`)
	return;
$posA=`xform -q -ws -t $region`;
$posB=`xform -q -ws -t $previousRegion`;
$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
setAttr ($region+".falloffRadius") $mag;
float $previousRad=`getAttr ($previousRegion+".falloffRadius")`;
if ($mag>$previousRad || $previousRegion=="eyeBrow0")
	setAttr ($previousRegion+".falloffRadius") $mag;
}

global proc string asFaceCreateFitJoint (string $name, float $radius, int $color)
{
if (`objExists $name`)
	error ($name+" Already Exists");

if (!`objExists FaceFitFromSoftMods`)
	createNode -n FaceFitFromSoftMods -p FaceFitSkeleton transform;

select FaceFitFromSoftMods;
joint -n $name;
setAttr ($name+".overrideEnabled") 1;
setAttr ($name+".overrideColor") $color;
addAttr -k 1 -min 0 -dv $radius -ln "falloffRadius" -at double $name;
addAttr -k 1 -ln "falloffMode"  -at "enum" -en "volume:surface:" $name;
addAttr -k 1 -ln "interpolation"  -at "enum" -en "none:linear:smooth:spline:" $name;
if (`gmatch $name "lowerEye*"` || `gmatch $name "upperEye*"` || `gmatch $name "lowerLip*"` || `gmatch $name "upperLip*"`)
	;
else
	{
	setAttr ($name+".falloffMode") 1;
	setAttr ($name+".interpolation") 2;
	}
if (`gmatch $name "*Sculpt*"`)
	setAttr ($name+".falloffMode") 0;
return $name;
}

global proc asFaceUpdateInfo (int $read)
{
string $attrs[]={"Geometry","AllFaceGeo" ,"Eye_L","Eye_R","UpperTeeth","LowerTeeth","Tongue",
	"EyeBrow_L","EyeBrow_R","EyeLash_L","EyeLash_R","HeadJoint","SkinCluster"};
string $text;

for ($i=0;$i<size($attrs);$i++)
	{
	string $texField="asFace"+$attrs[$i]+"TextField";
	if(!`textField -q -ex $texField`)
		continue;
	if ($read)
		{
		$text="";

		if ($attrs[$i]=="HeadJoint") $text="Head_M";
		if (`attributeExists $attrs[$i] FaceFitSkeleton`)
			$text=`getAttr ("FaceFitSkeleton."+$attrs[$i])`;
		textField -e -tx $text $texField;
		}
	else
		{
		if (!`attributeExists $attrs[$i] FaceFitSkeleton`)
			addAttr -ln $attrs[$i] -dt "string" FaceFitSkeleton;
		setAttr -type "string" ("FaceFitSkeleton."+$attrs[$i]) `textField -q -tx $texField`;
		}
	}

//Update CheckBoxes
string $checkBoxes[]=`lsUI -type checkBox`;
for ($i=0;$i<size($checkBoxes);$i++)
	{
	int $value=0;
	if (`gmatch $checkBoxes[$i] "asFaceFit*"`)
		{
		string $obj=`substitute "asFaceFit" $checkBoxes[$i] "FaceFit"`;
		if (`objExists $obj`)
			$value=1;
		checkBox -e -ed $value -v $value $checkBoxes[$i];
		}
	}
}

global proc asCreateFaceController (string $name, string $side, int $color)
{
float $scale=`asFaceGetScale`/5.0;
string $tempString[]=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/15.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
rename $tempString[0] ($name+$side);
sets -add "FaceControlSet" ($name+$side);
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.castsShadows");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.receiveShadows");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.motionBlur");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.primaryVisibility");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.smoothShading");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.visibleInReflections");
connectAttr ctrlBox.RenderSpheres ($name+$side+"Shape.visibleInRefractions");
//disconnectAttr -na ($name+$side+"Shape.instObjGroups[0]") initialShadingGroup.dagSetMembers;
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") $color;
createNode -n ($name+"Attach"+$side) transform;
createNode -n ($name+"Offset"+$side) transform;
createNode -n ($name+"Subtract"+$side) transform;
parent ($name+$side) ($name+"Subtract"+$side);
parent ($name+"Subtract"+$side) ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);
if ($color==6)
	parent ($name+"Attach"+$side) Acontrols;
if ($color==7 || $color==8)
	parent ($name+"Attach"+$side) Bcontrols;
if ($color==10)
	parent ($name+"Attach"+$side) Ccontrols;

if ($color==6)
	sets -e -forceElement asFaceBlueSG ($name+$side);
if ($color==7)
	sets -e -forceElement asFaceGreenSG ($name+$side);
if ($color==8)
	sets -e -forceElement asFaceCyanSG ($name+$side);
if ($color==10)
	sets -e -forceElement asFaceBrownSG ($name+$side);
}
	
global proc asPingPong (string $trnPos, string $name, int $b, string $side, int $color, int $createJoint, int $bindSkin)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
float $scale=`asFaceGetScale`/3.0;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;

float $pos[]=`xform -q -ws -t $trnPos`;

if (!`objExists ClusterSetup`)
	createNode -n ClusterSetup -p FaceMotionSystem transform;
if (!`objExists Brs`)
	{
	createNode -n Brs -p Bcontrols transform;
	orientConstraint -mo $headJoint Brs;
	scaleConstraint -mo $headJoint Brs;
	}

//Alternative attach position (e.g eyeLid)
float $attachPos[]=$pos;
string $altAttPosXform="";
int $nrUpperEyeInner,$nrLowerEyeInner;
for ($nrUpperEyeInner=1;$nrUpperEyeInner<99;$nrUpperEyeInner++) if (!`objExists ("upperEyeInner"+($nrUpperEyeInner+1))`) break;
for ($nrLowerEyeInner=1;$nrLowerEyeInner<99;$nrLowerEyeInner++) if (!`objExists ("lowerEyeInner"+($nrLowerEyeInner+1))`) break;
if ($name=="upperEye1")
	$altAttPosXform="upperEyeInner"+($nrUpperEyeInner/2);
if ($name=="lowerEye1")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner/2);
if ($name=="upperEye2")
	$altAttPosXform="upperEyeInner"+($nrUpperEyeInner/4);	
if ($name=="lowerEye2")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner/4);	
if ($name=="upperEye3")
	$altAttPosXform="upperEyeInner"+($nrLowerEyeInner - ($nrLowerEyeInner/4));	
if ($name=="lowerEye3")
	$altAttPosXform="lowerEyeInner"+($nrLowerEyeInner - ($nrLowerEyeInner/4));	
//if ($name=="upperLip")
//	$altAttPosXform="upperEyeInner4";
if($altAttPosXform!="")
	{
	float $altAttachPos[]=`xform -q -ws -t $altAttPosXform`;
	$attachPos={$altAttachPos[0],$altAttachPos[1],$altAttachPos[2]};
	if ($side=="_L")
		$attachPos={$altAttachPos[0]*-1,$altAttachPos[1],$altAttachPos[2]};
	}

//Alternative control position (e.g lips)
float $controlPos[]=$pos;
string $altCtrlPosXform="";
int $nrUpperLipOuter,$nrLowerLipOuter;
for ($nrUpperLipOuter=1;$nrUpperLipOuter<99;$nrUpperLipOuter++) if (!`objExists ("upperLipOuter"+($nrUpperLipOuter+1))`) break;
for ($nrLowerLipOuter=1;$nrLowerLipOuter<99;$nrLowerLipOuter++) if (!`objExists ("lowerLipOuter"+($nrLowerLipOuter+1))`) break;
if ($name=="upperLip")
	$altCtrlPosXform="upperLipMiddle"+`lipLetterClosestToCenterInY upper`+"0";
if ($name=="lowerLip")
	$altCtrlPosXform="lowerLipMiddle"+`lipLetterClosestToCenterInY lower`+"0";
if ($name=="Lip")
	$altCtrlPosXform="lowerLipOuter"+$nrLowerLipOuter;
if ($name=="upperLipMid")
	$altCtrlPosXform="upperLipMiddle"+`lipLetterClosestToCenterInY upper`+($nrUpperLipOuter/2);
if($altCtrlPosXform!="" && `objExists $altCtrlPosXform`)
	{
	float $altControlPos[]=`xform -q -ws -t $altCtrlPosXform`;
	$controlPos=$altControlPos;
	$attachPos=$controlPos;
	}

//nurbsSphere controller
asCreateFaceController $name $side $color;
xform -ws -t ($controlPos[0]*$b) $controlPos[1] $controlPos[2] ($name+"Attach"+$side);

//Joint + Offset
if ($createJoint)
	{
	select -cl;
	joint -n ($name+"Joint"+$side);
	createNode -n ($name+"JointOffset"+$side) transform;
	parent ($name+"Joint"+$side) ($name+"JointOffset"+$side);
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"JointOffset"+$side);
	parent ($name+"JointOffset"+$side) FaceDeformationFollowHead;
	}
if ($bindSkin)
	{
	string $bindToSkinCluster=$skinCluster;
	skinCluster -e -ai ($name+"Joint"+$side) -lw false -wt 0 $skinCluster;
	}


//Attach
string $tempString[]=`listRelatives -ni -s $geometry`;
string $closestSampler=`createNode -n closestSampler closestPointOnMesh`;
if (!`isConnected ($tempString[0]+".outMesh") closestSampler.inMesh`)
	connectAttr -f ($tempString[0]+".outMesh") closestSampler.inMesh;
if (!`isConnected ($geometry+".worldMatrix[0]") closestSampler.inputMatrix`)
	connectAttr -f ($geometry+".worldMatrix[0]") closestSampler.inputMatrix;

setAttr -type float3 closestSampler.inPosition ($attachPos[0]*$b) $attachPos[1] $attachPos[2];
string $vtx=`getAttr closestSampler.result.closestVertexIndex`;
delete $closestSampler;
select ($geometry+".vtx["+$vtx+"]");
ConvertSelectionToEdges;
string $edges[]=`ls -sl -fl`;
select $edges[0];
$tempString=`duplicateCurve -ch 1 -rn 0 -local 0`;
string $dupCurve=$tempString[0];
rename $dupCurve ($name+"Curve"+$side);
rename $tempString[1] ($name+"CurveEdge"+$side);
setAttr -l 1 ($name+"Curve"+$side+".v") 0;
parent ($name+"Curve"+$side) ClusterSetup;
createNode -n ($name+"PointOnCurveInfo"+$side) pointOnCurveInfo;
setAttr ($name+"PointOnCurveInfo"+$side+".turnOnPercentage") 1;
connectAttr -f ($name+"Curve"+$side+"Shape.worldSpace[0]") ($name+"PointOnCurveInfo"+$side+".inputCurve");
//determine PointOnCurveInfo.parameter
float $tempFloatA[]=`xform -q -ws -t ($name+$side)`;
float $tempFloatB[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAB=`mag<<$tempFloatA[0]-$tempFloatB[0],$tempFloatA[1]-$tempFloatB[1],$tempFloatA[2]-$tempFloatB[2]>>`;
setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 1;
float $tempFloatC[]=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
float $magAC=`mag<<$tempFloatA[0]-$tempFloatC[0],$tempFloatA[1]-$tempFloatC[1],$tempFloatA[2]-$tempFloatC[2]>>`;
if ($magAB<$magAC)
	setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 0;

//avoid double Xform
createNode -n ($name+"PlusMinusAverage"+$side) plusMinusAverage;
setAttr ($name+"PlusMinusAverage"+$side+".operation") 2;
connectAttr -f ($name+"PointOnCurveInfo"+$side+".position") ($name+"Attach"+$side+".t");
connectAttr -f Brs.r ($name+"Attach"+$side+".r");
connectAttr -f Brs.s ($name+"Attach"+$side+".s");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[1]");
disconnectAttr ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
parent -w ($name+"Offset"+$side);
connectAttr -f ($name+"PlusMinusAverage"+$side+".output3D") ($name+"Subtract"+$side+".t");
xform -ws -t ($controlPos[0]*$b) $controlPos[1] $controlPos[2] ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);

if ($createJoint)
	{
	connectAttr ($name+$side+".tx") ($name+"Joint"+$side+".tx");connectAttr ($name+$side+".ty") ($name+"Joint"+$side+".ty");connectAttr ($name+$side+".tz") ($name+"Joint"+$side+".tz");
	connectAttr ($name+$side+".rx") ($name+"Joint"+$side+".rx");connectAttr ($name+$side+".ry") ($name+"Joint"+$side+".ry");connectAttr ($name+$side+".rz") ($name+"Joint"+$side+".rz");
	connectAttr ($name+$side+".sx") ($name+"Joint"+$side+".sx");connectAttr ($name+$side+".sy") ($name+"Joint"+$side+".sy");connectAttr ($name+$side+".sz") ($name+"Joint"+$side+".sz");
	}
select -cl;
refresh;
}

global proc string lipLetterClosestToCenterInY (string $upperLower)
{
string $letter;
string $tempString[]=`ls -type joint ($upperLower+"LipMiddle*0_M")`;
string $closestJoint=$tempString[0];
float $minValue=999;
float $centerPos[]=`xform -q -ws -t ($upperLower+"LipCenter0_M")`;
for ($i=0;$i<size($tempString);$i++)
	{
	float $pos[]=`xform -q -ws -t $tempString[$i]`;
	float $absY=abs($centerPos[1]-$pos[1]);
	if ($absY<$minValue)
		{
		$minValue=$absY;
		$closestJoint=$tempString[$i];
		}
	}
$tempString[0]=`substitute ($upperLower+"LipMiddle") $closestJoint ""`;
$letter=`substitute "0_M" $tempString[0] ""`;
return $letter;
}

global proc softCluster (string $trnPos, string $name, int $b, string $side)
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $falloffRadius=`getAttr ($name+".falloffRadius")`;
float $falloffMode=`getAttr ($name+".falloffMode")`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

if (!`objExists ClustersRegion`)
	{
	if (`objExists tempTargetFullMesh`)
		duplicate -n ClustersRegion tempTargetFullMesh;
	else
		duplicate -n ClustersRegion tempTarget;
	parent ClustersRegion RegionDeformations;
	sets -e -forceElement initialShadingGroup ClustersRegion;
	blendShape -e -tc 0 -t `textField -q -tx asFaceGeometryTextField` `getAttr -s asFaceBS.w` ClustersRegion 1 asFaceBS;
	setAttr asFaceBS.ClustersRegion 1;
	}

select $allFaceGeo;
float $scale=`asFaceGetScale`/3.0;
float $pos[3]=`xform -q -ws -t $trnPos`;
float $tempFloat[];
int $numVtxs[];
int $infNr;
float $value;
float $skinPercents[];
string $skinClusterInfs[];
string $oppositeSide;
select -r ClustersRegion;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;

string $softMod=`rename $tempString[0] ($name+"SoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($name+"SoftModHandle"+$side)`;
$tempString=`listConnections ($name+"SoftMod"+$side+".message")`;
string $softModSet=`rename $tempString[0] ($name+"SoftModSet"+$side)`;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $softModHandle;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;

asPingPong $name $name $b $side 8 0 0;
//setAttr ($name+$side+"Shape.overrideColor") `getAttr ($name+".overrideColor")`;
parent ($name+"Attach"+$side) Acontrols;

setAttr -type float3 ($softModHandle+".t") 1 0 0;
//softMod -e -pr fails in batch, when affecting multiple meshes
//no longer pruning , as this gets tricky when user want to paint outside prune area
//if (`getAttr ($name+".overrideColor")`!=9)
//	softMod -e -pr $softMod;
//changed:trying to bring back -pruning
	dgdirty -a;
if (`getAttr ($name+".overrideColor")`!=9) // Prune softMode does not work well with multiAffectedObjects
	{
	if (`asMayaVersionAsFloat`==2016) //2016 seem to need falloffMode==0, for pruning to work
		{
		setAttr ($softMod+".falloffMode") 0;
		softMod -e -pr $softMod;
		setAttr ($softMod+".falloffMode") $falloffMode;
		}
	else
		softMod -e -pr $softMod;
	}
$tempString=`listConnections ($softMod+".message")`;
select `sets -q $tempString[0]`;
string $vtxs[]=`ls -sl -fl`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;

$tempString=`cluster -n ($name+"Cluster"+$side) -envelope 1`;
string $cluster=$tempString[0];
string $clusterHandle=$tempString[1];
$tempString=`listRelatives -s $clusterHandle`;
string $clusterHandleShape=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].inputGeometry")`;
string $clusterGroupParts=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].groupId")`;
string $clusterGroupId=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$tempString[0];
parent $clusterHandle ClusterSetup;
setAttr -type float3 ($clusterHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $clusterHandle;

asFaceSoftModToCluster $softMod $cluster $vtxs;
delete $softMod;

setAttr -l 1 ($clusterHandle+".v") 0;
connectAttr ($name+$side+".t") ($clusterHandle+".t");
connectAttr ($name+$side+".r") ($clusterHandle+".r");
connectAttr ($name+$side+".s") ($clusterHandle+".s");

//catch (`reorderDeformers $skinCluster $cluster $geometry`);
//catch (`reorderDeformers asFaceBS $cluster $geometry`);

if (`getAttr ($name+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!="ClustersRegion")
			{
			int $haveSkinCluster=0;
			$historyNodes=`listHistory -pdo 1 $allFaceGeo[$i]`;
			for ($y=0;$y<size($historyNodes);$y++)
				if (`nodeType $historyNodes[$y]`=="skinCluster")
					{
					$haveSkinCluster=1;
					$skinCluster=$historyNodes[$y];
					}
			if ($haveSkinCluster)
				catch (`reorderDeformers $skinCluster $cluster $allFaceGeo[$i]`);
			}
	}
}

global proc asFaceSoftModToCluster (string $softMod, string $cluster, string $vtxs[])
{
string $tempString[]=`listConnections ($softMod+".matrix")`;
string $softModHandle=$tempString[0];
setAttr ($softModHandle+".ty") 1;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
string $componentType="vtx";

string $deformMeshs[]=`ls -o $vtxs`;
$deformMeshs=`stringArrayRemoveDuplicates $deformMeshs`;
string $deformXforms[];
for ($i=0;$i<size($deformMeshs);$i++)
	{
	$tempString=`listRelatives -p $deformMeshs[$i]`;
	$deformXforms[$i]=$tempString[0];
	}
setAttr ($softMod+".envelope") 0;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshA"+$i) $deformMeshs[$i];
setAttr ($softMod+".envelope") 1;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshB"+$i) $deformMeshs[$i];
float $sofModDefaultPos[3]=`xform -q -os -piv $softModHandle`;
float $posA[3];
float $posB[3];
for ($i=0;$i<size($deformMeshs);$i++)
    {
		$componentType="vtx";
		if (`objectType $deformMeshs[$i]`=="lattice")
			$componentType="pt";
    string $historyNodes[]=`listHistory $deformMeshs[$i]`;
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 1;
    percent -v 0 $cluster ($deformMeshs[$i]+"."+$componentType+"[0:999999]");
    for ($y=0;$y<size($vtxs);$y++)
        {
        if (!`gmatch $vtxs[$y] ($deformXforms[$i]+"[.]"+$componentType+"*")`)
            continue;
        tokenize $vtxs[$y] "." $tempString;
        $posA=`xform -q -ws -t ("tempMeshA"+$i+"."+$tempString[1])`;
        $posB=`xform -q -ws -t ("tempMeshB"+$i+"."+$tempString[1])`;
        percent -v ($posB[1]-$posA[1]) $cluster $vtxs[$y];
        }
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 0;
     }
for ($i=0;$i<size($deformMeshs);$i++)
	delete ("tempMeshA"+$i) ("tempMeshB"+$i);
clear $vtxs;
}

global proc string asFaceMirror ()
{
string $restoreCmd,$oppositeControl;
int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
	autoKeyframe -state 0;
string $mirrorAttrs[]={"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
string $controls[]=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	if (!`gmatch $controls[$i] "*_L"`)
		continue;
	for ($attr in $mirrorAttrs)
		{
		if (`getAttr -l ($controls[$i]+"."+$attr)`)
			continue;
		$oppositeControl=`substitute "_L" $controls[$i] "_R"`;
		$multiply=1;
		if ($attr=="tx" || $attr=="ry" || $attr=="rz")
			$multiply=-1;
	
		$restoreCmd+="setAttr "+$controls[$i]+"."+$attr+" "+`getAttr ($controls[$i]+"."+$attr)`+";";
		setAttr ($controls[$i]+"."+$attr) (`getAttr ($oppositeControl+"."+$attr)`*$multiply);
		}
	}
if ($autoKeyState)
	$restoreCmd+="autoKeyframe -state 1;";
return $restoreCmd;
}

global proc asFaceMirrorControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";
$tempString=`listConnections ($sel[0]+".s")`;
float $pos[]=`getAttr ($sel[0]+".t")`;
float $rot[]=`getAttr ($sel[0]+".r")`;
float $sca[]=`getAttr ($sel[0]+".s")`;
	asGoToBuildPose faceSetup;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	print "// Detected this controller to control a \"Cluster\", performing Mirror Cluster Weights\n";
	asFaceMirrorClusterWeight;
	}
else
	{
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	print "Detected this controller to control a \"Joint\", performing Mirror Skin Weights";
	}
setAttr -type float3 ($sel[0]+".t") $pos[0] $pos[1] $pos[2];
setAttr -type float3 ($sel[0]+".r") $rot[0] $rot[1] $rot[2];
setAttr -type float3 ($sel[0]+".s") $sca[0] $sca[1] $sca[2];
select $sel;
}

global proc asFaceMirrorClusterWeight ()
{
string $sel[]=`ls -sl`;
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a faceControl";
string $control=$sel[0];

string $restorePoseCmd;
int $multiply;
int $numVtxs[]=`polyEvaluate -v ClustersRegion`;
float $maxDist,$mag;
float $posA[3],$posB[3],$tempFloat[];
string $tempString[],$rightVtxs[];
string $cluster=`substitute "_R" $control "Cluster_R"`;
string $oppositeControl=`substitute "_R" $control "_L"`;
string $oppositeCluster=`substitute "_R" $cluster "_L"`;
if (!`gmatch $control "*_R"` || !`objExists $oppositeCluster`)
	return;
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$cluster+"Set";
string $oppositeClusterSet=`substitute "_R" $clusterSet "_L"`;
if (!`objExists $oppositeClusterSet`)
	return;

//Start off by pruning
setAttr -type float3 ($control+".t") 1 0 0;
cluster -e -pr $cluster;
setAttr -type float3 ($control+".t") 0 0 0;

//Mirror pose before doing left to ensure identical attachment
string $restoreCmd=`asFaceMirror`;

percent -v 0 $oppositeCluster ("ClustersRegion.vtx[0:"+$numVtxs[0]+"]");
select `sets -q ($cluster+"Set")`;
$rightVtxs=`ls -sl -fl`;
$posA=`xform -q -ws -t $control`;
$maxDist=0;
for ($i=0;$i<size($rightVtxs);$i++)
	{
	$posB=`xform -q -ws -t $rightVtxs[$i]`;
	$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>$maxDist)
		$maxDist=$mag;
	}
$maxDist=$maxDist+($maxDist/20.0);

select ClustersRegion;
sets -add ($oppositeCluster+"Set") ClustersRegion;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxDist -dp ($posA[0]*-1) $posA[1] $posA[2];
string $vtxs[]=`ls -sl -fl`;
polySelectConstraint -m 0;
//sets -add ($oppositeCluster+"Set") $vtxs;
string $closestSampler=`createNode -n closestSampler closestPointOnMesh`;
$tempString=`listRelatives -ni -s ClustersRegion`;
connectAttr -f ($tempString[0]+".outMesh") ($closestSampler+".inMesh");
connectAttr -f ("ClustersRegion.worldMatrix[0]") ($closestSampler+".inputMatrix");
int $closestOppositeVtxNr;
global string $gMainProgressBar;
progressBar -e -st ("Mirroring Cluster for: "+$control) -bp -ii 1 -min 0 -max `size($vtxs)` $gMainProgressBar;
for ($i=0;$i<size($vtxs);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		break;
	progressBar -e -s 1 $gMainProgressBar;
	$posB=`xform -q -ws -t $vtxs[$i]`;
	setAttr -type float3 ($closestSampler+".inPosition") ($posB[0]*-1) $posB[1] $posB[2];
	$closestOppositeVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;
	$tempFloat=`percent -q -v $cluster ("ClustersRegion.vtx["+$closestOppositeVtxNr+"]")`;

	if (!`sets -im $clusterSet ("ClustersRegion.vtx["+$closestOppositeVtxNr+"]")`)
		$tempFloat[0]=0;

	percent -v $tempFloat[0] $oppositeCluster $vtxs[$i];
	}
progressBar -e -ep $gMainProgressBar;
setAttr -type float3 ($oppositeControl+".t") 1 1 1;
cluster -e -pr $oppositeCluster;
setAttr -type float3 ($oppositeControl+".t") 0 0 0;
delete $closestSampler;

eval ($restoreCmd);
}

global proc int [] asFaceSelVtxIntArray ()
{
int $intArray[];
string $tempString[];
string $sel[]=`ls -sl -fl`;
for ($i=0;$i<size($sel);$i++)
	{
	tokenize $sel[$i] "[" $tempString;
	$intArray[$i]=`substitute "]" $tempString[1] ""`;
    	}
return $intArray;
}

global proc asHelpImage (string $region)
{
string $asScriptLocation=`asGetScriptLocation`;
if (`window -q -ex faceHelpImage`)
	deleteUI faceHelpImage;
window faceHelpImage;
scrollLayout -w 666 -h 10;

if (`gmatch $region "*asBSWizardStep*"`)
	$region="asBSWizard/"+$region;

formLayout asHelpFormLayout;
image -i ($asScriptLocation+"/AdvancedSkeleton5Files/div/images/help/"+$region+".jpg") asHelpImage;
if (`gmatch $region "*asBSWizardStep*"`)
	button -l "Toggle Default" -c asFaceTglDefault;

formLayout -e
	-af asHelpImage "right" 0
	-af asHelpImage "left" 0
	-af asHelpImage "top" 0
	-af asHelpImage "bottom" 0
	asHelpFormLayout;

//Video Link
string $helpUrl;
string $buttonLabel="Open Video Link";
if ($region=="asDeformSkinCageSliders")
	$helpUrl="https://youtu.be/uMaKwxKXygw";
if ($region=="asDeformSkinCageDWidth")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=153";
if ($region=="asDeformSubWrapCage" || $region=="asDeformSubWrapWrap")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=280";
if ($region=="asDeformSkinLoopsCreate" || $region=="asDeformSkinLoopsSelectAll"
	|| $region=="asDeformSkinLoopsBind" || $region=="asDeformSkinLoopsCutUp")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=151";
if ($region=="asMotionCaptureReadBvh" || $region=="asMotionCaptureConnect")
	{
	$helpUrl="https://sites.google.com/a/cgspeed.com/cgspeed/motion-capture/cmu-bvh-conversion";
	$buttonLabel="Open Link";
	}
if ($region=="asCorrectiveShapesCreate")
	$helpUrl="https://youtu.be/YOIyFB2nK90";
if ($region=="asCorrectiveShapesBake")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=327";
if ($region=="faceFitSkeletonNode")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=357";
if ($region=="asEditBlendShapesCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=663";
if ($region=="asTweakControllersCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=743";
if ($region=="asSelectorDesigner")
	$helpUrl="https://youtu.be/0dpLmKZbEJc";
if ($region=="asPoserDesigner")
	{
	$helpUrl="http://www.studiolibrary.com/";
	$buttonLabel="Open Link";
	}
if ($region=="asWalkDesigner")
	$helpUrl="https://youtu.be/jMTfxKArl1Q";

if ($helpUrl!="")
	{
	string $button=`button -w 200 -h 50 -l $buttonLabel -c ("showHelp -a \""+$helpUrl+"\"")`;
	formLayout -e
		-af $button "top" 715
		-af $button "left" 220
		asHelpFormLayout;
	}
showWindow;
window -e -h 808 faceHelpImage;
}

global proc asFaceTglDefault ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $curImage=`image -q -i asHelpImage`;
string $ann=`image -q -ann asHelpImage`;
if (!`gmatch $curImage "*asBSWizardStep*[0-9][.]*"`)
	return;
if ($ann=="")
	{
	image -e -ann $curImage asHelpImage;
	image -e -i ($asScriptLocation+"/AdvancedSkeleton5Files/div/images/help/asBSWizard/asBSWizardStep0.jpg") asHelpImage;
	}
else
	{
	image -e -ann "" asHelpImage;
	image -e -i $ann asHelpImage;
	}
}

global proc asFaceSquintByLattice ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
float $dist;
float $scale=`asFaceGetScale`;
float $pos[],$pos2[];
string $tempString[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//Restore "Display only tongue geo"
if (!`gmatch $tongue "*[.]*"`)
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
		if (!`getAttr -l ($allFaceGeo[$i]+".v")`)
			setAttr ($allFaceGeo[$i]+".v") 1;
		}

$side="_R";;

if ($geometryFaces=="")
	{
	duplicate -rr -n ("eye_squint"+$side) $geometry;
	parent ("eye_squint"+$side) faceTargets;
	}
else
	{
	duplicate -rr -n ("eye_squint"+$side) tempTarget;
	setAttr ("eye_squint"+$side+".v") 1;
	}
$tempString=`listRelatives -s ("eye_squint"+$side)`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
parent -w eye_squint_R;
setAttr ($geometry+".v") 0;

select ("eye_squint"+$side);
$tempString=`lattice  -divisions 3 4 4 -objectCentered true  -ldv 2 2 2`;
string $ffd=$tempString[0];
string $lattice=$tempString[1];
string $latticeBase=$tempString[2];

$pos=`xform -q -ws -t FitEyeBall`;
xform -ws -t $pos[0] $pos[1] $pos[2] $lattice;
xform -ws -t $pos[0] $pos[1] $pos[2] $latticeBase;
delete `scaleConstraint FitEyeBall $lattice`;
delete `scaleConstraint FitEyeBall $latticeBase`;
scale -r 2 2 2 $lattice;
scale -r 2 2 2 $latticeBase;
setAttr ($lattice+".sx") ($pos[0]*4);
setAttr ($latticeBase+".sx") ($pos[0]*4);
select ($lattice+".pt[1:2][1:2][2]");
scale -r -p $pos[0] $pos[1] $pos[2] 1 0.2 1 ;
$pos=`xform -q -ws -t ($lattice+".pt[0][2][3]")`;
$pos2=`xform -q -ws -t ($lattice+".pt[0][1][3]")`;
$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
move -r 0 0 ($dist*0.2); 
select ("eye_squint"+$side);
//	DeleteHistory;
//	setAttr ("eye_squint"+$side+".v") 0;
//	blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` ("eye_squint"+$side) 1 asFaceBS;

select -cl;
}

global proc asFaceBsSdk (string $ctrl, float $driveValue, string $bs, float $drivenValue)
{
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl $driveValue;
setAttr $bs $drivenValue;
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl 0;
if ($driveValue>0)
	keyTangent -in 0 -itt linear -ott linear $bs;

//pre post infinity
string $nodes[]=`listConnections -s 1 -d 0 -scn 1 $bs`;
for ($i=0;$i<size($nodes);$i++)
	{
	$tempString=`nodeType -inherited $nodes[$i]`;
	if ($tempString[0]=="animCurve")
		{
		setAttr ($nodes[$i]+".preInfinity") 4;
		setAttr ($nodes[$i]+".postInfinity") 4;
		}
	}
}

global proc float[] asGetMidHeadPos ()
{
float $midHeadPos[];
//first look for joints, as the fig might be from before faceFitScaleCurve came about
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $headPos[]=`xform -q -ws -t $headJoint`;
string $tempString[]=`listRelatives -c $headJoint`;
if(size($tempString))
	{
	$temp=`xform -q -ws -t $tempString[0]`;
	$midHeadPos[0]=(($headPos[0]+$temp[0])/2.0);
	$midHeadPos[1]=(($headPos[1]+$temp[1])/2.0);
	$midHeadPos[2]=(($headPos[2]+$temp[2])/2.0);
	}
if (`objExists FaceFitSkeletonHeightShape`)
	{
	float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
	float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
	$midHeadPos={$headPos[0],($pos1[1]+$pos2[1])/2.0,$headPos[2]};
	}

return $midHeadPos;
}

global proc asFaceCtrlBox ()
{
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
if (`objExists ctrlBoxOffset`)
	delete ctrlBoxOffset;
float $scale=`asFaceGetScale`/3.0;
float $temp[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $midHeadPos[]=`asGetMidHeadPos`;
float $boxTZ=($midHeadPos[2]+($scale*1.3));
if (`objExists FitEyeBall`)
	{
	$temp=`xform -q -ws -t FitEyeBall`;
	$boxTZ=$temp[2];
	}

$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBox;
createNode -n ctrlBoxOffset transform;
parent ctrlBox ctrlBoxOffset;
parent ctrlBoxOffset FaceMotionFollowHead;
//parentConstraint -mo $headJoint ctrlBoxOffset;
//scaleConstraint -mo $headJoint ctrlBoxOffset;
addAttr -k 1 -ln "limits" -at bool -dv true ctrlBox;
setAttr ctrlBoxShape.overrideEnabled 1;
setAttr ctrlBoxShape.overrideColor 17;

//Expand length down
move -r 0 -0.4 0 ctrlBoxShape.cv[2:3];
xform -ws -t ($scale*1.8) ($midHeadPos[1]-(0.3*$scale)) $boxTZ ctrlBox;
xform -s ($scale/2.0) $scale ($scale/2.0) ctrlBox;
makeIdentity -a 1 -t 0 -r 0 -s 1 ctrlBox;

//ctrlBoxTemplate
$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBoxTemplate;
parent ctrlBoxTemplate ctrlBox;
setAttr -type float3 ctrlBoxTemplate.t 0 0 0;
setAttr -type float3 ctrlBoxTemplate.s ($scale/6.0) ($scale/6.0) ($scale/6.0);
setAttr ctrlBoxTemplateShape.overrideEnabled 1;
setAttr ctrlBoxTemplateShape.overrideDisplayType 2;

//ctrlTemplate
duplicate -n ctrlTemplate ctrlBoxTemplate;
parent ctrlTemplate ctrlBoxTemplate;
transformLimits -tx -1 1 -ty -1 1 -tz 0 0 -etx 1 1 -ety 1 1 -etz 1 1 ctrlTemplate;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransYLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransYLimitEnable`);
setAttr ctrlTemplateShape.overrideDisplayType 0;
setAttr ctrlTemplate.rz 45;
setAttr -type float3 ctrlTemplate.s 0.2 0.2 0.2;
setAttr ctrlTemplateShape.overrideColor 17;
makeIdentity -a 1 -t 0 -r 1 -s 1 ctrlTemplate;
setAttr -l 1 -k 0 ctrlTemplate.tz;
setAttr -l 1 -k 0 ctrlTemplate.rx;
setAttr -l 1 -k 0 ctrlTemplate.ry;
setAttr -l 1 -k 0 ctrlTemplate.rz;
setAttr -l 1 -k 0 ctrlTemplate.sx;
setAttr -l 1 -k 0 ctrlTemplate.sy;
setAttr -l 1 -k 0 ctrlTemplate.sz;
setAttr -l 1 -k 0 ctrlTemplate.v;
sets -add FaceControlSet ctrlTemplate;

asFaceCreateCtrlBox "Brow_R" ($scale*-0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Brow_L" ($scale*0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Eye_R" ($scale*-0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Eye_L" ($scale*0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Cheek_R" ($scale*-0.25) 0 1;
asFaceCreateCtrlBox "Cheek_L" ($scale*0.25) 0 1;
asFaceCreateCtrlBox "Nose_R" ($scale*-0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Nose_L" ($scale*0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Mouth_M" 0 ($scale*-0.4) 2;
asFaceCreateCtrlBox "MouthCorner_R" ($scale*-0.25) ($scale*-1) 0;
asFaceCreateCtrlBox "MouthCorner_L" ($scale*0.25) ($scale*-1) 0;
scale -r 2 2 2 ctrlBoxMouth_M;

setAttr -l 0 -k 1 ctrlEye_L.sx;setAttr -l 0 -k 1 ctrlEye_L.sy;setAttr -l 0 -k 1 ctrlEye_L.sz;
setAttr -l 0 -k 1 ctrlEye_R.sx;setAttr -l 0 -k 1 ctrlEye_R.sy;setAttr -l 0 -k 1 ctrlEye_R.sz;

/*
for ($i=1;$i<4;$i++)
	{
	if ($tongue=="")
		break;
	asFaceCreateCtrlBox ("Tongue"+$i+"_M") 0 ($scale*(-1.125+($i*-0.075))) 0;
	setAttr ("ctrlBoxTongue"+$i+"_MShape.overrideVisibility") 0;
	scale -r 0.5 0.5 0.5 ("ctrlTongue"+$i+"_M.cv[0:4]");
	asLockAttr ("ctrlTongue"+$i+"_M") 0 0 0 1;
	transformLimits -tz -1 1 -etz 1 1 ("ctrlTongue"+$i+"_M");
	}
*/
/*
if ($upperTeeth!="")
	{
	asFaceCreateCtrlBox "FKTeethUpper_M" ($scale*-0.26) ($scale*-1.22) 0;
	setAttr ctrlBoxFKTeethUpper_MShape.overrideVisibility 0;
	scale -r 1.5 0.5 0.5 ctrlFKTeethUpper_M.cv[0:4];
	asLockAttr ctrlFKTeethUpper_M 0 0 0 1;
	transformLimits -tz -1 1 -etz 1 1 ctrlFKTeethUpper_M;
	}
if ($lowerTeeth!="")
	{
	asFaceCreateCtrlBox "FKTeethLower_M" ($scale*-0.26) ($scale*-1.32) 0;
	setAttr ctrlBoxFKTeethLower_MShape.overrideVisibility 0;
	scale -r 1.5 0.5 0.5 ctrlFKTeethLower_M.cv[0:4];
	asLockAttr ctrlFKTeethLower_M 0 0 0 1;
	transformLimits -tz -1 1 -etz 1 1 ctrlFKTeethLower_M;
	}
*/
addAttr -k 1 -ln "ACtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.ACtrlVis Acontrols.v;
addAttr -k 1 -ln "BCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.BCtrlVis Bcontrols.v;
addAttr -k 1 -ln "CCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.CCtrlVis Ccontrols.v;
addAttr -k 1 -ln "AimCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.AimCtrlVis Aimcontrols.v;
addAttr -k 1 -ln "SquashCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "RubberCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "RenderSpheres" -at bool -dv true ctrlBox;

delete ctrlBoxTemplate;
}

global proc asFaceCreateCtrlBox (string $name, float $x, float $y, int $half)
{
$tempString=`duplicate -rc ctrlBoxTemplate`;
rename $tempString[0] ("ctrlBox"+$name);
rename $tempString[1] ("ctrl"+$name);
setAttr -type float3 ("ctrlBox"+$name+".t") $x $y 0;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransYLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransYLimitEnable")`);

if ($half)
	{
	float $pos0[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[0]")`;
	float $pos2[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[2]")`;
	float $pos3[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[3]")`;
	if ($half==1)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[2]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos3[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[3]");
		transformLimits -tx -1 1 -ty 0 1 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	if ($half==2)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[1]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[0]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[4]");
		transformLimits -tx -1 1 -ty -1 0 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	}
}

global proc asKeepBlendShapes ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;

createNode -n keepTweakedBlendShapes transform;
setAttr keepTweakedBlendShapes.v 0;
string $udas[]=`listAttr -ud FaceFitSkeleton`;
string $keepShps[];
for ($i=0;$i<size($udas);$i++)
	{
	if (`gmatch $udas[$i] "*_tweaked"`)
		if (`getAttr ("FaceFitSkeleton."+$udas[$i])`)
			$keepShps[size($keepShps)]=`substitute "_tweaked" $udas[$i] ""`;
	}
for ($i=0;$i<size($keepShps);$i++)
	{
	setAttr ("asFaceBS."+$keepShps[$i]) 1;
	duplicate -n ($keepShps[$i]+"_tweaked") $geometry;
	parent ($keepShps[$i]+"_tweaked") keepTweakedBlendShapes;
	setAttr ("asFaceBS."+$keepShps[$i]) 0;
	}
}

global proc asRemoveInfluence (string $joint, string $skinCluster)
{
string $infJoints[]=`listConnections -s 1 -d 0 ($skinCluster+".matrix")`;
if (`stringArrayCount $joint $infJoints`)
	skinCluster -e -ri $joint $skinCluster;
}

global proc asBuildFitEyeBall ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $righEyeGeoText=`textField -q -tx asFaceEye_RTextField`;
string $tempString[],$tempString2[],$eyeGeos[];
if ($righEyeGeoText=="")
	error "No Eye Geometry choosen";
if (`objExists FitEyeBall`)
	error "FitEyeBall already exists";
int $hadBodyEye=0;
float $pos[],$rot[];
if (`objExists FKEye_R`)
	{
	$dialog=`confirmDialog -t "Confirm"
		-m "This will replace the Eyes from the Body-setup"
		-b "OK" -db "OK"
		-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		return;
	$hadBodyEye=1;
	string $skinClusters[]=`ls -type skinCluster`;
	for ($i=0;$i<size($skinClusters);$i++)
		{
		//First add Head as inf (if Eye is only inf), since having none inf`s breaks the skinCluster
		$tempString=`listConnections ($skinClusters[$i]+".matrix")`;
		if (size($tempString)==1 && `gmatch $tempString[0] "Eye_*"`) {
			skinCluster -e -ai $headJoint -lw false -wt 1 $skinClusters[$i];
			print ("skinCluster -e -ai "+$headJoint+" -lw false -wt 1 "+$skinClusters[$i]+";\n");
			}
		if (`objExists Eye_R`) asRemoveInfluence Eye_R $skinClusters[$i];
		if (`objExists Eye_L`) asRemoveInfluence Eye_L $skinClusters[$i];
		}
	$pos=`xform -q -ws -t Eye_R`;
	$rot=`xform -q -ws -ro Eye_R`;
	if (`objExists FKOffsetEye_R`) delete FKOffsetEye_R;
	if (`objExists FKOffsetEye_L`) delete FKOffsetEye_L;
	if (`objExists FKAimEye_R`) delete FKAimEye_R;
	if (`objExists FKAimEye_L`) delete FKAimEye_L;
	if (`objExists Eye_R`)delete Eye_R;
	if (`objExists Eye_L`) delete Eye_L;
	if (`objExists AimEye`) delete AimEye;
	if (`objExists Eye`) delete Eye;
	asRemoveUnusedfromBuildPose bodySetup;
	}
float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
asFitModeEnsureShaders;
spaceLocator -n FitEyeBall;
setAttr FitEyeBall.rotateOrder 2;
setAttr -type float3 FitEyeBallShape.localScale 1.5 1.5 1.5;
createNode -n FaceFitEyeBall -p FaceFitSkeleton transform;
setAttr -type float3 FaceFitEyeBall.r 180 -90 0;
parent FitEyeBall FaceFitEyeBall;
setAttr -type float3 FitEyeBall.r 0 0 0;
polySphere -n FitEyeSphere -r 0.5 -sx 8 -sy 8 -ax 0 1 0 -cuv 2 -ch 0;
setAttr FitEyeSphere.overrideEnabled 1;
setAttr FitEyeSphere.overrideDisplayType 2;
parent FitEyeSphere FitEyeBall;
sets -e -forceElement asWhiteSG FitEyeSphere;
sets -e -forceElement asBlackSG FitEyeSphere.f[56:63];
setAttr -type float3 FitEyeSphere.r 0 0 -90;
setAttr -type float3 FitEyeBall.s (0.025*$height) (0.025*$height) (0.025*$height);

if ($hadBodyEye)
	{
	xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] FitEyeBall;
	}
else
	{
	$pos=`xform -q -ws -t $headJoint`;
	xform -ws -t $pos[0] $pos[1] $pos[2] FitEyeBall;
	setAttr -type float3 FitEyeBall.t ($pos[1]/-50.0) ($pos[1]/15.0) ($pos[1]/15.0);
//	setAttr FitEyeBall.ry -90;
	}

//guestimate placement (and scale) based upon 1st selected geo
tokenize $righEyeGeoText $tempString;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "*[.]*"`)
		$eyeGeos[size($eyeGeos)]=$tempString[$i];
if (size($eyeGeos))
	{
	$tempString=`duplicate -n tempEye $eyeGeos[0]`;
	$tempString2=`listRelatives -p $tempString[0]`;
	if ($tempString2[0]!="")
		$tempString=`parent -w $tempString[0]`;
	select $tempString[0];
	CenterPivot;
	float $pos[]=`xform -q -ws -piv $tempString[0]`;
	float $bb[]=`xform -q -ws -bb $tempString[0]`;
	delete $tempString[0];
	if ($pos[1]>0)
		{
		parent -w FitEyeBall;
		if (!$hadBodyEye)
			xform -ws -t $pos[0] $pos[1] $pos[2] FitEyeBall;
		xform -os -s ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) FitEyeBall;
		parent FitEyeBall FaceFitEyeBall;
		}
	}


select FitEyeBall;
print ("// FitEyeBall created, place this to match the eye-ball of your character\n");
checkBox -e -ed 1 -v 1 asFaceFitEyeBall;
}

global proc asFaceEnsureFitBase ()
{
if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;
}

global proc asFaceEnsureShaders ()
{
string $colors[]={"asFaceBlue","asFaceBrown","asFaceGreen","asFaceCyan","asFaceRed"};
float $rs[]={0.0,0.541,0.000,0.0,0.4};
float $gs[]={0.0,0.282,0.275,0.5,0};
float $bs[]={1.0,0.200,0.098,0.5,0};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".ambientColor") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".incandescence") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asFaceEnsureAdvancedBase ()
{
asFaceEnsureShaders;
string $sel[]=`ls -sl`;
if (!`objExists FaceGroup`)
	error "FaceGroup does not exists, must build a Fit-system first";
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
if (!`objExists $headJoint`)
	error ("HeadJoint: \""+$headJoint+"\" Does not exists");
if (`objExists FaceMotionSystem`)
	setAttr FaceMotionSystem.v 1;
if (`objExists FaceMotionSystem`)
	return;

string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;

//top level nodes
createNode -n FaceMotionSystem -p FaceGroup transform;
createNode -n FaceMotionFollowHead -p FaceMotionSystem transform;
createNode -n ControlsSetup -p FaceMotionSystem transform;
createNode -n Acontrols transform;
createNode -n Bcontrols transform;
createNode -n Ccontrols transform;
createNode -n Aimcontrols transform;
parent Acontrols Bcontrols Ccontrols Aimcontrols ControlsSetup;
createNode -n FaceDeformationSystem -p FaceGroup transform;
createNode -n RegionDeformations -p FaceDeformationSystem transform;
createNode -n FaceDeformationFollowHead -p FaceDeformationSystem transform;
parentConstraint $headJoint FaceMotionFollowHead;
scaleConstraint $headJoint FaceMotionFollowHead;
parentConstraint $headJoint FaceDeformationFollowHead;
scaleConstraint $headJoint FaceDeformationFollowHead;

//faceBuildPose
if (!`objExists faceBuildPose`)
	{
	createNode -n faceBuildPose dagPose;
	addAttr -ln udAttr -dt "string"  faceBuildPose;
	}

//Sets
select -cl;
sets -name FaceAllSet;
sets -name FaceControlSet;
if (`objExists "Sets"`)
	{
	sets -add "Sets" FaceAllSet;
	sets -add "Sets" FaceControlSet;
	}
sets -em -n FaceBuildingSets;
sets -add FaceAllSet FaceBuildingSets;
sets -add FaceBuildingSets allBeforeFaceBuild;
select $sel;
}

global proc asAdvancedSquash ()
{
global string $gSelect;
setToolTo $gSelect;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`/3.0;
float $value,$min,$max;
float $pos[3],$pos2[3];
string $name;
string $tempString[],$allFaceGeo[],$historyNodes[],$infs[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
string $allBefore[]=`ls`;

//squashHead
float $squashTopPos[3]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
float $squashBasePos[3]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
float $BaseToTopY=$squashTopPos[1]-$squashBasePos[1];

createNode -n SquashSetup -p FaceMotionSystem transform;
$tempString[0]=`curve -d 1 -p 1 1 1 -p 1 -1 1 -p -1 -1 1 -p -1 1 1 -p 1 1 1 -p 1 1 -1 -p 1 -1 -1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 1 -1 -p 1 1 -1 -p -1 1 -1 -p -1 1 1 -p -1 -1 1 -p -1 -1 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
rename $tempString[0] squashTop_M;
setAttr squashTop_MShape.overrideEnabled 1;
setAttr squashTop_MShape.overrideColor 13;
createNode -n squashTopOffset transform;
parent squashTop_M squashTopOffset;
xform -ws -t 0 $squashTopPos[1] 0 squashTopOffset;
xform -ws -s ($scale/0.75) ($scale/5.0) ($scale/5.0) squashTop_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashTop_M;
sets -add "FaceControlSet" squashTop_M;
duplicate -n SquashControls squashTopOffset;
rename SquashControls|squashTop_M squashBase_M;
xform -ws -t 0 $squashBasePos[1] 0 SquashControls;
duplicate -n squashMiddleOffset squashTopOffset;
rename squashMiddleOffset|squashTop_M squashMiddle_M;
xform -ws -t 0 (($squashBasePos[1]+$squashTopPos[1])/2) 0 squashMiddleOffset;
scale -r 1.5 1 1 squashMiddle_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashMiddle_M;
parent squashTopOffset squashMiddleOffset squashBase_M;

addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 squashTop_M;
createNode -n squashTopVolumeUC unitConversion;
setAttr squashTopVolumeUC.conversionFactor 0.1;
connectAttr squashTop_M.volume squashTopVolumeUC.input;

setAttr -l 1 -k 0 squashTop_M.rx;setAttr -l 1 -k 0 squashTop_M.ry;setAttr -l 1 -k 0 squashTop_M.rz;
setAttr -l 1 -k 0 squashTop_M.sx;setAttr -l 1 -k 0 squashTop_M.sy;setAttr -l 1 -k 0 squashTop_M.sz;
setAttr -l 1 -k 0 squashTop_M.v;
setAttr -l 1 -k 0 squashMiddle_M.rx;setAttr -l 1 -k 0 squashMiddle_M.ry;setAttr -l 1 -k 0 squashMiddle_M.rz;
setAttr -l 1 -k 0 squashMiddle_M.sx;setAttr -l 1 -k 0 squashMiddle_M.sy;setAttr -l 1 -k 0 squashMiddle_M.sz;
setAttr -l 1 -k 0 squashMiddle_M.v;
setAttr -l 1 -k 0 squashBase_M.sx;setAttr -l 1 -k 0 squashBase_M.sy;setAttr -l 1 -k 0 squashBase_M.sz;
setAttr -l 1 -k 0 squashBase_M.v;

select $allFaceGeo;
//Do not include wrapped on`s  (e.g eyebrows)
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$historyNodes=`listHistory -f 0 -pruneDagObjects 1 -lv 4 $allFaceGeo[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`objectType $historyNodes[$y]`=="wrap")
			select -d $allFaceGeo[$i];
	}

$tempString=`lattice  -divisions 2 11 2 -objectCentered true  -ldv 2 2 2`;
rename $tempString[0] squashFfd;
rename $tempString[1] squashFfdLattice;
rename $tempString[2] squashFfdBase;
$tempString=`listConnections squashFfd.message`;
rename $tempString[0] squashFfdSet;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdLattice;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdBase;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdLattice;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdBase;
scale -r 1.25 1.25 1.25 squashFfdLattice;
scale -r 1.25 1.25 1.25 squashFfdBase;
setAttr "squashFfd.outsideLattice" 1;
parent squashFfdBase squashBase_M;
createNode -n squashXup transform;
setAttr -type float3 squashXup.r 90 0 90;
select squashXup;
$pos=`xform -q -ws -t squashFfdLattice.pt[0][1][1]`;
joint -n squashIKX0 -p 0 $pos[1] 0;
select squashXup;
for ($i=1;$i<10;$i++)
    {
    $pos=`xform -q -ws -t squashFfdLattice.pt[0][$i][1]`;
    joint -n ("squashIKX"+$i) -p 0 $pos[1] 0;
    }
setAttr squashIKX1.segmentScaleCompensate 0;
$tempString=`ikHandle -n squashIKHandle -ccv 1 -ns 2 -sol ikSplineSolver -sj squashIKX1 -ee squashIKX9`;
rename $tempString[1] squashIKEffector;
rename $tempString[2] squashIKECurve;
for ($i=0;$i<5;$i++)
    {
    select -r squashIKECurve.cv[$i];
    $tempString=`newCluster " -envelope 1"`;
    rename $tempString[0] ("squashIKCluster"+$i);
    rename $tempString[1] ("squashIKClusterHandle"+$i);
    }  
select -cl;
for ($i=0;$i<10;$i++)
    select -add ("squashIKX"+$i);
select -add squashFfdLattice;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] squashIKSC;

skinPercent -tv squashIKX0 1 squashIKSC squashFfdLattice.pt[0:1][0:1][0:1];
skinPercent -tv squashIKX2 1 squashIKSC squashFfdLattice.pt[0:1][2][0] squashFfdLattice.pt[0:1][2][1];
skinPercent -tv squashIKX3 1 squashIKSC squashFfdLattice.pt[0:1][3][0] squashFfdLattice.pt[0:1][3][1];
skinPercent -tv squashIKX4 1 squashIKSC squashFfdLattice.pt[0:1][4][0] squashFfdLattice.pt[0:1][4][1];
skinPercent -tv squashIKX5 1 squashIKSC squashFfdLattice.pt[0:1][5][0] squashFfdLattice.pt[0:1][5][1];
skinPercent -tv squashIKX6 1 squashIKSC squashFfdLattice.pt[0:1][6][0] squashFfdLattice.pt[0:1][6][1];
skinPercent -tv squashIKX7 1 squashIKSC squashFfdLattice.pt[0:1][7][0] squashFfdLattice.pt[0:1][7][1];
skinPercent -tv squashIKX8 1 squashIKSC squashFfdLattice.pt[0:1][8][0] squashFfdLattice.pt[0:1][8][1];
skinPercent -tv squashIKX9 1 squashIKSC squashFfdLattice.pt[0:1][9:10][0:1];

delete `pointConstraint squashIKClusterHandle4 squashIKClusterHandle3`;
parent squashIKClusterHandle3 squashIKClusterHandle4;
move -r 0 ($scale*-0.1) 0 ;

parent squashIKClusterHandle4 squashTop_M;
parent squashIKClusterHandle2 squashMiddle_M;
parent squashIKClusterHandle0 squashIKClusterHandle1 squashIKX0 squashBase_M;

createNode -n squashIKCurveInfo curveInfo;
connectAttr squashIKECurveShape.worldSpace[0] squashIKCurveInfo.inputCurve;


createNode -n squashIKCurveInfoNormalize multiplyDivide;
setAttr squashIKCurveInfoNormalize.operation 2;
connectAttr squashIKCurveInfo.arcLength squashIKCurveInfoNormalize.input1X;
setAttr squashIKCurveInfoNormalize.input2X `getAttr squashIKCurveInfoNormalize.input1X`;
createNode -n squashIKScale multiplyDivide;

//scale-compansate Main ctrl
createNode -n squashIKCurveInfoMainScale multiplyDivide;
setAttr squashIKCurveInfoMainScale.operation 2;
connectAttr squashIKCurveInfoNormalize.outputX squashIKCurveInfoMainScale.input1X;
connectAttr Main.sy squashIKCurveInfoMainScale.input2X;

connectAttr squashIKCurveInfoMainScale.outputX squashIKScale.input1X;
createNode -n squashIKStretch multiplyDivide;
connectAttr squashIKScale.outputX squashIKStretch.input2X;
setAttr squashIKStretch.input1X `getAttr squashIKX2.tx`;

//connectAttr squashIKScale.outputX squashIKStretch.input1X;
connectAttr ($headJoint+".sx") squashIKScale.input2X;
setAttr "squashIKScale.operation" 2;
for ($i=1;$i<10;$i++)
    connectAttr squashIKStretch.outputX ("squashIKX"+$i+".tx");
createNode -n squashVolume1Over multiplyDivide;
connectAttr squashIKScale.outputX squashVolume1Over.input2X;
setAttr "squashVolume1Over.input1X" 1;
setAttr "squashVolume1Over.operation" 2;
createNode -n squashVolumePow multiplyDivide;
connectAttr squashVolume1Over.outputX squashVolumePow.input1X;
setAttr "squashVolumePow.operation" 3;
setAttr "squashVolumePow.input2X" 0.5;
createNode -n squashBlendTwo blendTwoAttr;
setAttr squashBlendTwo.input[0] 1;
connectAttr squashVolumePow.outputX squashBlendTwo.input[1];
connectAttr squashTopVolumeUC.output squashBlendTwo.attributesBlender;
for ($i=2;$i<9;$i++)
    {
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sy");
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sz");
    }
    
parent squashFfdLattice squashIKECurve squashIKHandle SquashSetup;
parent squashIKX1 $headJoint;
parent SquashControls ControlsSetup;
parentConstraint -mo $headJoint SquashControls;
scaleConstraint $headJoint SquashControls;
delete squashXup;

setAttr -l 1 squashIKX1.v 0;
setAttr -l 1 squashFfdBase.v 0;
setAttr -l 1 squashIKHandle.v 0;
setAttr -l 1 squashIKX0.v 0;
for ($i=0;$i<5;$i++)
    setAttr -l 1 ("squashIKClusterHandle"+$i+".v") 0;

addAttr -k 0 -ln curveVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.curveVis;
connectAttr squashTop_M.curveVis squashIKECurve.v;
addAttr -k 0 -ln LatticeVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.LatticeVis;
connectAttr squashTop_M.LatticeVis squashFfdLattice.v;

//update buildPose
string $controls[]={"squashTop_M","squashMiddle_M","squashBase_M"};
string $setAttrCmd;
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listAttr -k -shortNames $controls[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controls[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controls[$i]+"."+$tempString[$y]+" "+`getAttr ($controls[$i]+"."+$tempString[$y])`+";";
	}
string $existingCmd=`getAttr faceBuildPose.udAttr`;
setAttr -type "string" faceBuildPose.udAttr ($existingCmd+$setAttrCmd);

connectAttr ctrlBox.SquashCtrlVis SquashControls.v;

//FaceAllset
string $allAfter[]=`ls`;
string $allNew[];
for ($i=0;$i<size($allAfter);$i++)
	if (!`stringArrayCount $allAfter[$i] $allBefore`)
		if (`objectType $allAfter[$i]`!="objectSet")
			$allNew[size($allNew)]=$allAfter[$i];
sets -add FaceAllSet $allNew;
sets -remove FaceAllSet `listRelatives -ad FaceFitSkeleton`;

select squashTop_M;
}

global proc asOptimizeSquash ()
{
global string $gMainProgressBar;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $geometryFaces=`asGetGeometryFaces`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $tempInt[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInt[0];

string $allHeadJoints[]=`listRelatives -ad -type joint $headJoint`;
$tempString=`listRelatives -ad -type joint $headJoint`;
$allHeadJoints=`stringArrayCatenate $allHeadJoints $tempString`;
if (`objExists EyeRegion_R`) $allHeadJoints[size($allHeadJoints)]="EyeRegion_R";
if (`objExists EyeRegion_L`) $allHeadJoints[size($allHeadJoints)]="EyeRegion_L";
$allHeadJoints[size($allHeadJoints)]=$headJoint;
select -cl;
progressBar -e -st "Optimizing" -bp -ii 1 -min 0 -max $numVtx $gMainProgressBar;
for ($i=0;$i<$numVtx;$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;return;}

	string $vtx=$geometry+".vtx["+$i+"]";
	$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $vtx`;
	int $headVtx=0;
	for ($y=0;$y<size($infs);$y++)
		{
		if (`stringArrayCount $infs[$y] $allHeadJoints`)
			{
			$headVtx=1;
			break;
			}
		}
	if (!$headVtx)
		select -add $vtx;
	}
sets -rm squashFfdSet `ls -sl`;
InvertSelection;
progressBar -e -ep $gMainProgressBar;
print ("// Optimize complete, now only these selected vtx`s are affected by Squash\n");
}

//-- ASFace Procedures Ends Here --//

global proc string asGetLatestLocalScriptLocation ()
{
string $scriptLocation=`asGetScriptLocation`;
string $latestLocalScriptLocation=$scriptLocation;
string $tempString[];
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	tokenize $scriptLocation "/" $tempString;
	$latestLocalScriptLocation="";
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="AdvancedSkeleton5Files")
			break;
		else
			{
			if ($i>0 || `gmatch $scriptLocation "/*"`)
				$latestLocalScriptLocation+="/";
			$latestLocalScriptLocation+=$tempString[$i];
			}
		}
	}
return $latestLocalScriptLocation;
}

global proc string asGetLatestLocalVersionAsString ()
{
string $latestLocalVersion=`asGetScriptVersionAsString`;
string $scriptLocation=`asGetScriptLocation`;
string $tempString[];
string $latestLocalASFile;
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	$latestLocalASFile=`asGetLatestLocalScriptLocation`+"/AdvancedSkeleton5.mel";
	$latestLocalVersion=`asGetScriptVersionFromFile $latestLocalASFile`;
	}
return $latestLocalVersion;
}

global proc asCheckForUpdates ()
{
//if (!`about -win`)
//	error "This is only avaiable in Windows. For updates, go to: www.animationstudios.com.au/advancedskeleton/downloads";
string $curl=`asGetScriptLocation`+"/AdvancedSkeleton5Files/bin/curl.e";
if (`about -mac`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
text -e -en 0 -l "x.xxx" asUpdateFoundVersion;
checkBox -e -v 0 asBetaCheckBox;
button -e -en 0 asUpdateVersionButton;
waitCursor -st 1;
int $modifier=`getModifiers`;
float $versions[];
string $versionsText;

if ($modifier==13)
	{
	print ("// Checking online for new BETA version\n");
	checkBox -e -v 1 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton5Beta/latestBetaVersion.txt")`;
	}
else
	{
	print ("// Checking online for new version\n");
	checkBox -e -v 0 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton5/latestVersion.txt")`;
	}
string $latestVersionAsString=$versionsText;
float $latestVersion=$versionsText;

string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
float $latestInstalledVersion=`asGetScriptVersionFromFile ($sLoc+"/AdvancedSkeleton5.mel")`;
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton5.mel")`;

if ($latestVersion>$latestInstalledVersion)
	{
	text -e -en 1 -l $latestVersionAsString asUpdateFoundVersion;
	button -e -en 1 asUpdateVersionButton;
	print ("// New version found, click Update, to update to the new version\n");
	}
else
	print ("// Latest version("+$latestVersionAsString+"), is not greater than your latest installed version("+$latestInstalledVersionAsString+")\n");
waitCursor -st 0;
}

global proc string asGetLatestInstalledVersionScriptLocation ()
{
string $sLoc=`asGetScriptLocation`;
string $ts[];
int $numTok=`tokenize $sLoc "/" $ts`;
if ($ts[size($ts)-2]=="oldVersions")
	$sLoc=`substitute ("/"+$ts[$numTok-3]+"/"+$ts[$numTok-2]+"/"+$ts[$numTok-1]) $sLoc ""`;
return $sLoc;
}

global proc asUpdateVersion ()
{
waitCursor -st 1;
string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton5.mel")`;
string $curl=$sLoc+"/AdvancedSkeleton5Files/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeleton5Files/bin/7za.e";
string $newVersionAsString=`text -q -l asUpdateFoundVersion`;
string $newVersionFolder=$sLoc+"/AdvancedSkeleton5Files/newVersions/AdvancedSkeleton_v"+$newVersionAsString;
if (!`file -q -ex $newVersionFolder`)
	sysFile -md $newVersionFolder;
//download
string $newVersionZipFile=$newVersionFolder+"/AdvancedSkeleton5.zip";
//string $newVersionExtractedFolder=$newVersionFolder+"/AdvancedSkeleton5";
string $zipFileUrl="https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton5/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton5.zip";
if (`checkBox -q -v asBetaCheckBox`)
	$zipFileUrl="https://dl.dropboxusercontent.com/u/11249665/AdvancedSkeleton5Beta/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton5.zip";
string $cmd="start\/wait \"Downloading\"  \""+$curl+"\" -k -o \""+$newVersionZipFile+"\" "+$zipFileUrl;
if (`about -mac`) $cmd="\"curl -o "+$newVersionZipFile+" "+$zipFileUrl+"\"";
//if (`about -mac`) $cmd="\"osascript -e \tell application \Terminal\ to do script \echo hello\\";
print ("// Starting Download:"+$cmd+";\n");
//system ($cmd);
evalEcho ("system("+$cmd+")");
//confirm download
if (`file -q -ex $newVersionZipFile`)
	print ("// Downloaded sucessfully:"+$newVersionZipFile+";\n");
else
	error ("// Download failed, could not find:"+$newVersionZipFile+";\n");

//unzip
$cmd="start\/wait \"Unzipping\"  \""+$zip+"\" x \""+$newVersionZipFile+"\" -o\""+$newVersionFolder+"\"";
if (`about -mac`)
  $cmd="unzip "+$newVersionZipFile+" -d "+$newVersionFolder;
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);

//confirm unzip
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton5.mel")`)
	print ("// Unzipped sucessfully:"+$newVersionFolder+"/AdvancedSkeleton5.mel;\n");
else
	error ("// Unzipp failed, could not find:"+$newVersionFolder+"/AdvancedSkeleton5.mel;\n");
//backup $latestInstalledVersion version
string $oldVersionsFolder=$sLoc+"/AdvancedSkeleton5Files/oldVersions/AdvancedSkeleton_v"+$latestInstalledVersionAsString;
print ("// Backing up old version: asCopyFilesInFolder \""+$oldVersionsFolder+"\" \""+$sLoc+"\";\n");
sysFile -md ($oldVersionsFolder+"/AdvancedSkeleton5Files");
asCopyFilesInFolder ($oldVersionsFolder+"/AdvancedSkeleton5Files") ($sLoc+"/AdvancedSkeleton5Files");
sysFile -cp ($oldVersionsFolder+"/AdvancedSkeleton5.mel") ($sLoc+"/AdvancedSkeleton5.mel");
//replace with new version
print ("// Replacing current version with the downloaded version: asCopyFilesInFolder \""+$sLoc+"\" \""+$newVersionFolder+";\n");
asCopyFilesInFolder $sLoc $newVersionFolder;
waitCursor -st 0;
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton5.zip")`)
	sysFile -del ($newVersionFolder+"/AdvancedSkeleton5.zip");
print ("// Updated from "+$latestInstalledVersionAsString+" to "+$newVersionAsString+"\n");
//Re-start
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
evalDeferred -lp ("source \""+$sLoc+"/AdvancedSkeleton5.mel\";AdvancedSkeleton5;");
}

global proc asCopyFilesInFolder (string $destFolder, string $sourceFolder)
{
global string $gMainProgressBar;
if (!`file -q -ex $destFolder`)
    sysFile -md $destFolder;
string $fileList[]=`getFileList -fld ($sourceFolder+"/")`;
if (`size($fileList)`==0)
	return;
progressBar -e -st "Copy files" -bp -ii 1 -min 0 -max (size($fileList)) $gMainProgressBar;
for ($i=0;$i<size($fileList);$i++)
    {
		progressBar -e -s 1 $gMainProgressBar;
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
    if ($fileList[$i]=="incrementalSave" || $fileList[$i]=="distributes" || `gmatch $fileList[$i] "[.]*"`
  		|| $fileList[$i]=="newVersions" || $fileList[$i]=="oldVersions" || $fileList[$i]=="asReleaser.mel" || `gmatch $fileList[$i] "*[.]psd"`)
        continue;
    if (`filetest -d ($sourceFolder+"/"+$fileList[$i])`)
			asCopyFilesInFolder ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i]);
    else
			if (!`sysFile -cp ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i])` && `about -win`)
				{
				error ("Failed to copy file, possible privileges issue. This is common if you downloaded AdvancedSkeleton from the Autodesk store\n"
					+"Follow the steps in the URL below, then redo the updates\n"
					+"https://db.tt/xGk7E5xU\n");
				progressBar -e -ep $gMainProgressBar;
				return;
				}
    }
progressBar -e -ep $gMainProgressBar;
}

global proc asDockWindow (int $dock)
{
int $asDock=`optionVar -q asDock`;
optionVar -iv asDock $dock;
if (`dockControl -q -ex AdvancedSkeletonDockControl`)
	{
	deleteUI -control AdvancedSkeletonDockControl;
	AdvancedSkeleton5;
	}
else if ($dock)
	dockControl -w 296 -fl 0 -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
}

global proc asDockWindowChangeFloatingState ()
{
optionVar -iv asDock (!`dockControl -q -ex AdvancedSkeletonDockControl`);
}

global proc asFitSkeletonImport ()
{
string $dialog;
if (`objExists FitSkeleton`)
	{
	$dialog=`confirmDialog -t "Confirm"
		-m "Replace FitSkeleton ?"
		-b "OK" -db "OK"
		-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		return;
	}

float $existingScale[];
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
string $removeExistingObjs[]={"FitSkeleton","FitSkeletonVisualizers","cylinders","boxes","locators","directions",
	"asRedSG","asRed2SG","asGreenSG","asGreen2SG","asBlueSG","asBlue2SG","asBlackSG","asWhiteSG","asBonesSG",
	"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asBlack","asWhite","asBones"};
for ($i=0;$i<size($removeExistingObjs);$i++)
	if (`objExists $removeExistingObjs[$i]`)
		delete $removeExistingObjs[$i];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/fitSkeletons/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asFitFiles`;
if (`file -q -ex $FitSkeletonFile`)
	file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
if ($existingScale[0]!=0)
	setAttr -type float3 FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
if (`objExists Group|Main` && !`objExists Group|Main|FitSkeleton` && `objExists FitSkeleton`)
	parent FitSkeleton Group|Main;
asFitSkeletonConnectControl;
asUpdateButtonEnables;
}


global proc asFitSkeletonLimbsImport ()
{
string $dialog;
string $tempString[],$tempString2[],$tempString3[];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asLimbFiles`;
float $existingScale[3]={1,1,1};
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
if (`file -q -ex $FitSkeletonFile`)
	file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
if (`objExists Main|FitSkeleton` && `objExists |FitSkeleton`)
	rename |FitSkeleton AdvancedSkeleton_FitSkeleton;
if (`objExists AdvancedSkeleton_FitSkeleton` && `objExists FitSkeleton`)
	{
	setAttr -type float3 AdvancedSkeleton_FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
	$tempString=`listRelatives -f -c -type transform AdvancedSkeleton_FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		tokenize $tempString[$i] "|" $tempString2;
		string $shortName=$tempString2[size($tempString2)-1];
		$tempString2=`ls -l $shortName`;
			{
			if (size($tempString2)>1)
				$dialog=`confirmDialog -t "Confirm"
				-m ($shortName+" already exist")
				-b "Replace" -db "Replace"
				-b "Merge" -ds "Merge"`;
			if ($dialog=="Replace")
				{
				for ($y=0;$y<size($tempString2);$y++)
					if ($tempString2[$y]!=$tempString[$i])
						{
						$tempString3=`listRelatives -p $tempString2[$y]`;
						delete $tempString2[$y];
						if ($tempString3[0]!="")
							parent $tempString[$i] $tempString3[0];
						else
							parent $tempString[$i] FitSkeleton;
						}
				}
			else if (`objExists Root`)
				parent $tempString[$i] Root;
			else
				parent $tempString[$i] FitSkeleton;
			}
		}
	//Transfer SDK`s to FitSkeleton;
	if (`attributeExists drivingSystem AdvancedSkeleton_FitSkeleton`)
		{
		$tempString=`listConnections AdvancedSkeleton_FitSkeleton.drivingSystem`;
		if (!`attributeExists drivingSystem FitSkeleton`)
			addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;
		for ($i=0;$i<size($tempString);$i++)
			connectAttr -na ($tempString[$i]+".drivingSystemOut") FitSkeleton.drivingSystem;
		string $uAs[]=`listAttr -ud AdvancedSkeleton_FitSkeleton`;
		for ($i=0;$i<size($uAs);$i++)
			{
			if (!`gmatch $uAs[$i] "drivingSystem_*"`)
				continue;
			if (!`attributeExists $uAs[$i] FitSkeleton`)
				addAttr -k 0 -ln $uAs[$i] -at bool -dv true -multi FitSkeleton;
			$tempString=`listConnections -p 1 ("AdvancedSkeleton_FitSkeleton."+$uAs[$i])`;
			for ($y=0;$y<size($tempString);$y++)
				connectAttr -f ("FitSkeleton."+$uAs[$i]+"["+$y+"]") $tempString[$y];
			}
		}
	delete AdvancedSkeleton_FitSkeleton;
	}
asFitSkeletonConnectControl;
asUpdateButtonEnables;
}

global proc asFitSkeletonExport ()
{
string $selJoints[]=`ls -sl -type joint `;
string $selJointsLongName[]=`ls -l -sl -type joint `;
int $fitSkeletonVisLocked=`getAttr -l FitSkeleton.v`;
string $tempString[],$tempString2[],$drivingSystems[],$previousFitSkeletonChildren[],$previousSelJointParents[];
string $asScriptLocation=`asGetScriptLocation`;
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletons/";

//Limb only, first check, to determine destinationDir
int $limbOnly=0;
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		$limbOnly=1;
	}
if ($limbOnly)
	$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
string $result[] = `fileDialog2 -fileFilter "*.ma" -dialogStyle 2 -dir $fitSkeletonsDir`;
string $file=$result[0];
if ($file=="")
	return;

$tempString=`listRelatives -p FitSkeleton`;
string $currentParent=$tempString[0];
if ($fitSkeletonVisLocked)
	setAttr -l 0 FitSkeleton.v;
setAttr FitSkeleton.v 1;
if (`objExists $currentParent`)
	parent -w FitSkeleton;
$tempString=`listConnections -s 0 -d 1 -type animCurve`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 1 -d 0 -type transform $tempString[$i]`;
	if ($tempString2[0]!="" && $tempString2[0]!="FitSkeleton")
		if (!`stringArrayCount $tempString2[0] $drivingSystems`)
			$drivingSystems[size($drivingSystems)]=$tempString2[0];
	}

//Limb only ?
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		{
		if (!`objExists previousFitSkeletonChildren`)
			{
			createNode -n previousFitSkeletonChildren transform;
			$previousFitSkeletonChildren=`listRelatives -c -type joint FitSkeleton`;
			parent $previousFitSkeletonChildren previousFitSkeletonChildren;
			}
		$tempString=`listRelatives -p $selJoints[$i]`;
		$previousSelJointParents[$i]=$tempString[0];
		parent $selJoints[$i] FitSkeleton;
		}
	}

select FitSkeleton;
if (size($drivingSystems))
	delete $drivingSystems;
file -force -options "v=0;" -typ "mayaAscii" -es $file;
if (size($drivingSystems))
	undo;

if (`objExists $currentParent`)
	parent FitSkeleton $currentParent;
if ($fitSkeletonVisLocked)
	setAttr -l 1 FitSkeleton.v;

//Limb only ? (restore)
for ($i=0;$i<size($selJoints);$i++)
	if ($previousSelJointParents[$i]!="")
		parent $selJoints[$i] $previousSelJointParents[$i];
if (`objExists previousFitSkeletonChildren`)
	{
	parent `listRelatives -c previousFitSkeletonChildren` FitSkeleton;
	delete previousFitSkeletonChildren;
	}

print ("// FitSkeleton exported to: \""+$file+"\"\n");
}

global proc asOpenDemoFile ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $exampleFoldersDir=$asScriptLocation+"/AdvancedSkeleton5Files/exampleFiles/";
string $exampleFolder=`optionMenu -q -v asDemoOptionMenu`;
string $exampleFile=$exampleFoldersDir+$exampleFolder+"/"+$exampleFolder+".mb";
if (`file -q -ex $exampleFile`)
	{
	if (`saveChanges ""`)
		file -f -o $exampleFile;
	}
else
	waring ("Not Found:"+$exampleFile);
}

global proc asFitChangeLimbType ()
{
string $limbType=`optionMenu -q -v asLimbType`;
if ($limbType=="Spine" || $limbType=="Neck" || $limbType=="Tail")
	checkBox -e -v 1 asLimbMiddle;
else
	checkBox -e -v 0 asLimbMiddle;
}

global proc asFL ()
{
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
		optionVar -iv $framLayouts[$i] `frameLayout -q -cl $framLayouts[$i]`;

}

global proc asReferenceModelBrowser ()
{
global string $selectedNamespaceRadioButton;
string $sNRB=$selectedNamespaceRadioButton;
string $referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
int $referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
int $referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
string $ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
string $topNodesBefore[]=`ls -as`;

if (`asIsMayaLT`)
	error ("Maya LT does not have Reference, Import the model instead");
CreateReferenceOptions;

//Something in here Ran again, makes it work
global string $selectedNamespaceRadioButton;
$sNRB=$selectedNamespaceRadioButton;
$referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
$referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
$referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
$ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
CreateReference;

optionVar -sv referenceOptionsRenamePrefix $referenceOptionsRenamePrefix;
optionVar -iv referenceUseNamespacesDuringFileIO $referenceUseNamespacesDuringFileIO;
optionVar -iv referenceOptionsUseRenamePrefix $referenceOptionsUseRenamePrefix;
optionVar -sv ReferenceMergeOptionValue $ReferenceMergeOptionValue;
if ($sNRB!="")
	$selectedNamespaceRadioButton=$sNRB;
string $topNodesAfter[]=`ls -as`;
select -cl;
for ($i=0;$i<size($topNodesAfter);$i++)
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		select -add $topNodesAfter[$i];

//Hi layer
if (`objExists Hi`)
	{
	if(`objectType Hi`=="displayLayer")
		editDisplayLayerMembers -noRecurse Hi `ls -selection`;
	}
else
	{
	createDisplayLayer -name Hi -number 1 -nr;
	setAttr Hi.displayType 1;
	}
select -cl;
}

global proc asFitTglRLA ()
{
if (!`objExists Visualizers`)
	return;
string $tempString[];
string $visualizers[]=`listRelatives -ad -type transform Visualizers`;
int $onOff,$setOnOff;
for ($i=0;$i<size($visualizers);$i++)
	{
	$tempString=`listRelatives -s $visualizers[$i]`;
	if ($tempString[0]!="" || !`gmatch $visualizers[$i] "*Aim"`)
		continue;
	if (!$setOnOff)
		{
		$onOff=!`getAttr ($visualizers[$i]+".displayLocalAxis")`;
		$setOnOff=1;
		}
	setAttr ($visualizers[$i]+".displayLocalAxis") $onOff;
	}
}

global proc asJointsVisibility (int $onOff)
{
if (!`objExists Main`)
	return;
string $joints[]=`listRelatives -type joint -ad Main`;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asDisplayRigRLA (int $onOff)
{
string $joints[]=`listRelatives -ad -type joint DeformationSystem`;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".displayLocalAxis") $onOff;
}

global proc asCreateFitSkeleton ()
{
if (`objExists FitSkeleton`)
	delete FitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1.5 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FitSkeleton;
setAttr FitSkeletonShape.overrideEnabled 1;
setAttr FitSkeletonShape.overrideColor 29;
scale -r -p 0 0 0 2 2 2 FitSkeleton.cv[0:7];
duplicate -n FitSkeletonHeight FitSkeleton;
parent FitSkeletonHeight FitSkeleton;
parent -add -s FitSkeletonHeightShape FitSkeleton;
delete FitSkeletonHeight;
move -r 0 17 0 FitSkeletonHeightShape.cv[0:7];
setAttr -k 0 -l 1 FitSkeleton.tx;setAttr -k 0 -l 1 FitSkeleton.ty;setAttr -k 0 -l 1 FitSkeleton.tz;
setAttr -k 0 -l 1 FitSkeleton.rx;setAttr -k 0 -l 1 FitSkeleton.ry;setAttr -k 0 -l 1 FitSkeleton.rz;
asEnsureFitSkeletonAttributes;
asFitSkeletonConnectControl;
select FitSkeleton;
}

global proc asEnsureFitSkeletonAttributes ()
{
float $gap=0.75;
if (`optionVar -ex asFitSkeletonGap`)
	$gap=`optionVar -q asFitSkeletonGap`;
if (!`attributeExists visGeoType FitSkeleton`)
	addAttr -k 1 -ln visGeoType -at "enum" -en "cylinders:boxes:spheres:bones" FitSkeleton;
if (!`attributeExists visCylinders FitSkeleton`)
	addAttr -k 0 -ln visCylinders -at bool FitSkeleton;
if (!`attributeExists visBoxes FitSkeleton`)
	addAttr -k 0 -ln visBoxes -at bool FitSkeleton;
if (!`attributeExists visSpheres FitSkeleton`)
	addAttr -k 0 -ln visSpheres -at bool FitSkeleton;
if (!`attributeExists visBones FitSkeleton`)
	addAttr -k 0 -ln visBones -at bool FitSkeleton;
if (!`attributeExists lockCenterJoints FitSkeleton`)
	addAttr -k 1 -ln lockCenterJoints -dv 1 -at bool FitSkeleton;
if (!`attributeExists visGap FitSkeleton`)
	addAttr -k 1 -ln visGap -at double -dv $gap -min 0 -max 1 FitSkeleton;
if (!`attributeExists visGeo FitSkeleton`)
	addAttr -k 1 -ln visGeo -at bool -dv 1 FitSkeleton;
}

global proc asEnsureFitBaseStruct ()
{
if (!`objExists FitSkeletonVisualizers`)
	createNode -n FitSkeletonVisualizers transform;
if (!`objExists Aims`)
	createNode -n Aims -p FitSkeletonVisualizers transform;
if (!`objExists Systems`)
	createNode -n Systems -p FitSkeletonVisualizers transform;
}

global proc asEnsureFitSystems ()
{
if (!`objExists Systems`)
	return;
string $systems[]=`listRelatives -c Systems`;
for ($i=0;$i<size($systems);$i++)
	asEnsureSystem $systems[$i];
}

global proc asFitSkeletonConnectControl ()
{
if (!`objExists FitSkeleton`)
	return;

if(`attributeExists visLocators FitSkeleton`)
	connectControl asVisLocators FitSkeleton.visLocators;
//if(`attributeExists visGeo FitSkeleton`)
//	connectControl asVisGeo FitSkeleton.visGeo;
if(`attributeExists visGeoType FitSkeleton`)
	connectControl asVisGeoType FitSkeleton.visGeoType;
if(`attributeExists visGap FitSkeleton`)
	connectControl asVisGap FitSkeleton.visGap;
if(`attributeExists lockCenterJoints FitSkeleton`)
	connectControl asLockCenterJoints FitSkeleton.lockCenterJoints;
if(`attributeExists visDirections FitSkeleton`)
	connectControl asVisDirections FitSkeleton.visDirections;
if(`attributeExists visDirectionFront FitSkeleton`)
	connectControl asVisDirectionFront FitSkeleton.visDirectionFront;

if(`attributeExists lockCenterJoints FitSkeleton`)
	asFitModeLockCenterJoints;
}

global proc asStraightEndLoc (string $loc, float $lenght)
{
//maintain the `direction` with the end loc
string $parent;
float $pos[]=`getAttr ($loc+".t")`;
$tempString=`listConnections -s 0 -d 1 ($loc+".message")`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		{
		if (`attributeExists "child" $tempString[$i]`)
			if (`isConnected ($loc+".message") ($tempString[$i]+".child")`)
				$parent=$tempString[$i];
		if (`attributeExists "otherChildren" $tempString[$i]`)
			for ($y=0;$y<`getAttr -s ($tempString[$i]+".otherChildren")`;$y++)
				if (`isConnected ($loc+".message") ($tempString[$i]+".otherChildren["+$y+"]")`)
					$parent=$tempString[$i];
		}

if ($parent!="")
	{
	float $pos2[]=`getAttr ($parent+".t")`;
	float $parentLenght=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	if ($lenght==0)
		$lenght=$parentLenght;
	float $lenghtMuliplier=1;
	if ($lenght!=0)
		$lenghtMuliplier=$parentLenght*1/$lenght;
	if (`objExists ($loc+"End")`)
		{
		if (!`getAttr -l ($loc+"End.tx")`)
			setAttr ($loc+"End.tx") ($pos[0]+($pos[0]-$pos2[0])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.ty")`)
			setAttr ($loc+"End.ty") ($pos[1]+($pos[1]-$pos2[1])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.tz")`)
			setAttr ($loc+"End.tz") ($pos[2]+($pos[2]-$pos2[2])/$lenghtMuliplier);
		}
	}
}

global proc string asCreateLimbLoc (string $name, float $pos[], float $scale[],int $rotateOrder)
{
global int $asFitModeHierarchy;
int $isScapula;
if ($name=="Scapula")
	$isScapula=1;
string $tempString[];
//if ($name=="Basic")
//	$name="Basic1";
if (`objExists $name`)
	{
	for ($i=1;$i<999;$i++)
		if (!`objExists ($name+$i)`)
			break;
	$name=($name+$i);
	}

$tempString=`spaceLocator -n $name`;
$tempString=`parent ("|"+$tempString[0]) Markers`;
$name=$tempString[0];

setAttr -type float3 ($name+".s") $scale[0] $scale[1] $scale[2];
setAttr -type float3 ($name+"Shape.localScale") 0 1.5 1.5;
connectAttr FitSkeleton.visLocators ($name+"Shape.v");
setAttr ($name+".t") $pos[0] $pos[1] $pos[2];
if ($isScapula)
	{
	setAttr ($name+"Shape.overrideEnabled") 1;
	setAttr ($name+"Shape.overrideColor") 17;
	}

if (!$asFitModeHierarchy)
	{
	setAttr -k 0 ($name+".rx");
	setAttr -k 0 ($name+".ry");
	setAttr -k 0 ($name+".rz");
	}
setAttr ($name+".rotateOrder") $rotateOrder;

asEnsureLimbLocAttrs $name;
return $name;
}

global proc asEnsureLimbLocAttrs (string $name)
{
if (!`gmatch $name "*End*"`)
	{
	if (!`attributeExists twists $name`)
		{
		addAttr -k 1 -ln twists -at long -min 0 -max 10 $name;
		int $na=`getAttr -s triggerPlusMinusAverage.input1D`;
		connectAttr ($name+".twists") triggerPlusMinusAverage.input1D[$na];
		}
	if (!`attributeExists bendCtrls $name`)
		addAttr -k 1 -ln bendCtrls -at bool $name;
	setAttr -l 1 ($name+".bendCtrls");
	if (!`attributeExists "global" $name`)
		addAttr -k 1 -ln "global" -at bool $name;
	if (!`attributeExists child $name`)
		addAttr -ln child -at "message" $name;
	}
if (!`attributeExists otherChildren $name`)
	addAttr -m -indexMatters 0 -ln otherChildren -at "message" $name;
if (!`attributeExists worldUpObject $name`)
	addAttr -ln worldUpObject -at "message" $name;
if (!`attributeExists noMirror $name`)
	addAttr -ln noMirror -at bool $name;
if (!`attributeExists noMirrorBehaviour $name`)
	addAttr -ln noMirrorBehaviour -at bool $name;
if (!`attributeExists rot $name`)
	{
	addAttr  -k 0 -ln rot -numberOfChildren 3 -at double3 $name;
	addAttr  -p rot -ln rotX -at doubleAngle $name;
	addAttr  -p rot -ln rotY -at doubleAngle $name;
	addAttr  -p rot -ln rotZ -at doubleAngle $name;
	}
}

global proc asEnsureConnectAttr (string $source, string $destination)
{
if (!`isConnected $source $destination`)
	connectAttr -f $source $destination;
}

global proc asCreateRootLimb ()
{
string $limbType="Basic";
$sl=`asGetLimbLetter $limbType`;
string $locs[];
$locs[0]=`asCreateLimbLoc Root {0.0,5.0,0.0} {1,1,1} 0`;
$locs[1]=`asCreateLimbLoc ($locs[0]+"End") {0.0,7.0,0.0} {1,1,1} 0`;
setAttr -l 1 ($locs[0]+".tx");
setAttr -l 1 ($locs[1]+".tx");

//child connect
connectAttr ($locs[1]+".message") ($locs[0]+".child");

//system connect
$system=`asCreateSystem "Basic" $sl`;
connectAttr ($locs[0]+".message") ($system+".start");
connectAttr ($locs[0]+".message") ($system+".mid");
connectAttr ($locs[1]+".message") ($system+".end");
connectAttr ($locs[1]+".message") ($system+".endEnd");

asEnsureSystem $system;
}

global proc asUpdateButtonEnables ()
{
int $hasBodySetup=`objExists "Group"`;
int $hasFaceSetup=`objExists FaceMotionSystem`;
int $hasVisualizers=`objExists FitSkeletonVisualizers`;

//Body
checkBox -e -v $hasVisualizers asVisGeo;
optionMenu -e -en $hasVisualizers asVisGeoType;
floatSliderGrp -e -en $hasVisualizers asVisGap;

checkBox -e -m $hasBodySetup asRebuildConnections;
button -e -m $hasBodySetup asToggleFitSkeletonButton;
string $buildLabel="Build AdvancedSkeleton";
if ($hasBodySetup)
	$buildLabel="ReBuild AdvancedSkeleton";
button -e -l $buildLabel asBuildAdvancedSkeletonButton;

//Face
button -e -m $hasFaceSetup asToggleFitFaceButton;
rowLayout -e -m $hasFaceSetup asFaceRebuildKeepBSRowLayout;
$buildLabel="Build AdvancedFace";
//if ($hasFaceSetup)
//	$buildLabel="ReBuild AdvancedFace";
//button -e -l $buildLabel asBuildAdvancedFaceButton;
button -e -en (!$hasFaceSetup) asBuildAdvancedFaceButton;

text -e -m $hasFaceSetup asBodyText;
text -e -m $hasFaceSetup asFaceText;
button -e -m $hasFaceSetup asGoToBuildPoseFaceButton;
}

global proc asSceneOpened ()
{
global int $asFitModeScriptJobNr4;
$asFitModeScriptJob4Nr=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;
asOffFitMode;

asUpdateButtonEnables;
asFaceUpdateInfo 1;
}

global proc asOffFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr2[];
global int $asFitModeScriptJobNr3;
if (`headsUpDisplay -q -ex HUDFitMode`)
	headsUpDisplay -rem HUDFitMode;

if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr1;
	$asFitModeScriptJobNr1=0;
	}
if (`scriptJob -ex $asFitModeScriptJobNr3` && $asFitModeScriptJobNr3!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr3;
	$asFitModeScriptJobNr3=0;
	}
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
}


global proc asToggleFitFace ()
{
int $fitFaceVis=`getAttr FaceFitSkeleton.visibility`;
setAttr -l 0 FaceFitSkeleton.v;
setAttr -l 1 FaceFitSkeleton.v (!$fitFaceVis);
catchQuiet (`setAttr FaceMotionSystem.v $fitFaceVis`);
button -e -m (!$fitFaceVis) asDelteAdvFaceButton;
checkBox -e -m (!$fitFaceVis) asFaceKeepBlendShapes;
}


global proc asCopyAttrProperties (string $sourceObjAttr, string $destObjAttr)
{
float $temp[];
string $tempString[];
tokenize $sourceObjAttr "[.]" $tempString;
string $sourceObj=$tempString[0];
string $sourceAttr=$tempString[1];
tokenize $destObjAttr "[.]" $tempString;
string $destObj=$tempString[0];
string $destAttr=$tempString[1];
if (`attributeQuery -node $sourceObj -minExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -min $sourceAttr`;
	addAttr -e -min $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -maxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -max $sourceAttr`;
	addAttr -e -max $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMinExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMin $sourceAttr`;
	addAttr -e -softMinValue $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMaxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMax $sourceAttr`;
	addAttr -e -softMaxValue $temp[0] $destObjAttr;
	}
}

global proc asUpdateDrivingSystemsToFitSkeleton ()
{
string $sel[]=`ls -sl`;
//Remove ewxisting FitSkeltonDrivingSystems first
string $systems[]=`listRelatives -c Systems`;
for ($i=0;$i<size($systems);$i++)
	if (`gmatch $systems[$i] "DS_*"`)
		delete $systems[$i];
string $drivingSystems[]=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	$ds="DS_"+$drivingSystems[$i];
	createNode -n $ds -p "Systems" transform;
	string $uAs[]=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($uAs);$y++)
		{
		$dsd=$ds+"_"+$uAs[$y];
		createNode -n $dsd -p $ds transform;
		asLockAttr $dsd 1 1 1 1;
		addAttr -k 1 -ln $uAs[$y] -at double $ds;
		asCopyAttrProperties ($drivingSystems[$i]+"."+$uAs[$y]) ($ds+"."+$uAs[$y]);
		$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$uAs[$y])`;
		for ($z=0;$z<size($tempString);$z++)
			{
			duplicate -n ("Fit_"+$tempString[$z]) $tempString[$z];
			if (`sets -im AllSet ("Fit_"+$tempString[$z])`)
				sets -rm AllSet ("Fit_"+$tempString[$z]);
			addAttr -k 1 -ln ("standinAttr"+$z) -at double $dsd;
			connectAttr ("Fit_"+$tempString[$z]+".output") ($dsd+".standinAttr"+$z);
			}
		}
	}
select $sel;
}

global proc asFitModeEnsureShaders ()
{
string $colors[]={"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asWhite","asBlack","asBones"};
float $rs[]={1.0 , 1.0 , 0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.78};
float $gs[]={0.0 , 0.0 , 1.0 , 1.0 , 0.0 , 1.0 , 1.0 , 0.0 , 0.76};
float $bs[]={0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 1.0 , 1.0 , 0.0 , 0.72};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asCreateSamplerMesh (string $sourceObj)
{
//make a copy of the geometry, so we can freeze transforms and get correct sampler-results
string $tempString[];
duplicate -n samplerMesh $sourceObj;
$tempString=`listRelatives -f -ni -s samplerMesh`;
rename $tempString[0] samplerMeshShape;
asLockAttr samplerMesh 0 0 0 0;
$tempString=`listRelatives -p samplerMesh`;
if ($tempString[0]!="")
	parent -w samplerMesh;
$tempString=`listRelatives -s samplerMesh`;
for ($w=0;$w<size($tempString);$w++)
	if (`getAttr ($tempString[$w]+".intermediateObject")`)
		delete $tempString[$w];
makeIdentity -a 1 -t 1 -r 1 -s 1 samplerMesh;
}

global proc asSelectDeformJoints ()
{
string $sel[]=`ls -sl`;
if (`objExists "DeformSet"`)
	select `sets -q "DeformSet"`;
//Deselect end-joints
string $tempString[];
string $deformJoints[]=`ls -sl`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $deformJoints[$i]`;
	if ($tempString[0]=="")
		select -d $deformJoints[$i];
	}
for ($i=0;$i<size($deformJoints);$i++)
	if ($deformJoints[$i]=="Eye_R" || $deformJoints[$i]=="Eye_L" || $deformJoints[$i]=="Jaw_M")
		select -d $deformJoints[$i];
select -add $sel;
}

global proc asSetSmoothBindOptions ()
{
optionVar
-iv "multipleBindPosesOpt" 0
-iv "bindMethod" 1
-iv "bindTo" 2
-iv "skinMethod" 1
-iv "removeUnusedInfluences" 0
-iv "colorizeSkeleton" 0
-fv "maxInfl" 3
-iv "normalizeWeights" 2
-iv "obeyMaxInfl" 0;
SmoothBindSkinOptions;
}

global proc asOpenSelector ()
{
evalEcho ("source \""+`asGetScriptLocation`+"/AdvancedSkeleton5Files/Selector/biped.mel\"");
}

global proc asCreateTempNodes ()
{
createNode -n TempNodes transform;
string $tempNodes[]={"FKScapula_R","FKScapula_L","FKAnkle_L","FKAnkle_R","FKChest_M","FKElbow_L","FKElbow_R","FKHead_M","FKHip_L","FKHip_R","FKIndexFinger1_L","FKIndexFinger1_R","FKIndexFinger2_L","FKIndexFinger2_R","FKIndexFinger3_L","FKIndexFinger3_R","FKKnee_L","FKKnee_R","FKMiddleFinger1_L","FKMiddleFinger1_R","FKMiddleFinger2_L","FKMiddleFinger2_R","FKMiddleFinger3_L","FKMiddleFinger3_R","FKNeck_M","FKPinkyFinger1_L","FKPinkyFinger1_R","FKPinkyFinger2_L","FKPinkyFinger2_R","FKPinkyFinger3_L","FKPinkyFinger3_R","FKRingFinger1_L","FKRingFinger1_R","FKRingFinger2_L","FKRingFinger2_R","FKRingFinger3_L","FKRingFinger3_R","FKRoot_M","FKShoulder_L","FKShoulder_R","FKSpine1_M","FKThumbFinger1_L","FKThumbFinger1_R","FKThumbFinger2_L","FKThumbFinger2_R","FKThumbFinger3_L","FKThumbFinger3_R","FKToes_L","FKToes_R","FKWrist_L","FKWrist_R"};
for ($i=0;$i<size($tempNodes);$i++)
	createNode -n $tempNodes[$i] -p TempNodes transform;
select `listRelatives -ad TempNodes`;
}

global proc asFitSkeletonFromEdgeLoops ()
{
global string $gMove;
setToolTo $gMove;
float $pos[];
string $loc;
string $skinLoopSets[]=`sets -q SkinLoops`;
for ($i=0;$i<size($skinLoopSets);$i++)
	{
	$loc=`substitute "SkinLoops_" $skinLoopSets[$i] ""`;
	$loc=`substitute "_R" $loc ""`;
	$loc=`substitute "_M" $loc ""`;
	if (!`objExists $loc`)
		continue;
	select $skinLoopSets[$i];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $loc;
	}
select -cl;
}

global proc asCreateSkinLoop (int $mirroring)
{
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
string $fkControl=$sel[size($sel)-1];
string $deformJoint;
if (`objExists DeformSet` && `sets -im DeformSet $fkControl`)
	$deformJoint=$fkControl;
else
	{
	$deformJoint=`substitute "FK" $fkControl ""`;
	if (!`gmatch $fkControl "FK*"`)
		error "No FK control selected";
	}
float $pos[];
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
//float $mirrorTolerance=0.001*$scale;

int $neighboursInLoop;
string $mirrorFkControl;
string $tempString[],$tempString2[],$tempString3[],$mirrorVtxs[];

//validate complete loop
select -d $fkControl;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	select $tempString[$i];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $tempString[$i];
	$tempString2=`ls -sl -fl`;
	$neighboursInLoop=0;
	for ($y=0;$y<size($tempString2);$y++)
		if (`stringArrayCount $tempString2[$y] $tempString`)
			$neighboursInLoop++;
	if ($neighboursInLoop!=2)
		{
		select $tempString[$i];
		if ($mirroring)
			error ("Not a complete loop, on mirrored side");
		else
			error ("Not a complete loop");
		}
	}

if (`objExists ("SkinLoops_"+$deformJoint)`)
	delete ("SkinLoops_"+$deformJoint);

if (!`objExists SkinLoops`)
	sets -em -name SkinLoops;
select $sel;
select -d $fkControl;
sets -name ("SkinLoops_"+$deformJoint);
sets -add  SkinLoops ("SkinLoops_"+$deformJoint);

if (`checkBox -q -v asCreateSkinLoopCheckBox` && !`gmatch $deformJoint "*_M"` && !$mirroring)
	{
	select ("SkinLoops_"+$deformJoint);
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	$tempString2=`ls -sl -o`;
	$tempString3=`listRelatives -p $tempString2[0]`;
	if (`objExists closestSampler`) delete closestSampler;
	if (`objExists samplerMesh`) delete samplerMesh;
	asCreateSamplerMesh $tempString3[0];
	createNode -n closestSampler closestPointOnMesh;
	connectAttr -f samplerMesh.outMesh closestSampler.inMesh;
	
	for ($i=0;$i<size($tempString);$i++)
		{
		select $tempString[$i];
		$pos=`xform -q -ws -t $tempString[$i]`;
		setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		int $closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
		$mirrorVtxs[size($mirrorVtxs)]=$tempString2[0]+".vtx["+$closestVtxIndex+"]";
		}
	select $mirrorVtxs;
	ConvertSelectionToContainedEdges;
	if (`gmatch $deformJoint "*_R"`) $mirrorFkControl=`substitute "_R" $fkControl "_L"`;
	if (`gmatch $deformJoint "*_L"`) $mirrorFkControl=`substitute "_L" $fkControl "_R"`;
	select -add $mirrorFkControl;
	asCreateSkinLoop 1;
	}
if (`objExists closestSampler`) delete closestSampler;
if (`objExists samplerMesh`) delete samplerMesh;
print ("// SkinLoops_"+$deformJoint+" Created\n");
select $sel;
}

global proc asSelectAllSkinLoops ()
{
select SkinLoops;
select -add `ls -sl -o`;
}

global proc asDeleteCutUp ()
{
delete `listConnections CutUp.drawInfo`;
delete CutUp;
}

global proc asBindSkinLoops (int $createCutUp)
{
source removeUnusedInfluences;
global string $gMove;
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*[.]*"`)
		error ("Selection is not a object:"+$sel[$i]);
int $tempInt[],$twistJoints[];
int $haveSkinCluster,$numVtxs,$foundDownSideVtx,$loopAffectsCut;
float $circumference,$radius,$ratio;
float $pos[],$posA[],$posB[],$values[];
string $tempString[],$tempString2[],$deformJoints[],$parentJoints[],$childJoints[],$historyNodes[],$skinClusterJoints[],$infs[];
string $allJointChildren[],$edgeLoopVtxs[],$allEdgeLoopVtxs[],$neighbourVtxs[];
string $skinCluster,$weightTo,$cutName,$twistJoint;
string $skinLoopSets[]=`sets -q SkinLoops`;
$skinLoopSets=`sort $skinLoopSets`;

createNode -n CutUpWIP transform;
sets -em -n SkinLoopWeighted;
sets -em -n SkinLoopSpine;
if ($createCutUp && !`objExists CutUp`)
	{
	createDisplayLayer -e -name CutUp;
	setAttr CutUp.color 29;
	setAttr CutUp.displayType 2;
	}

string $skinLoopObjects[];
select SkinLoops;
$tempString=`ls -sl -o`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	if (!`stringArrayCount $tempString2[0] $skinLoopObjects`)
		$skinLoopObjects[size($skinLoopObjects)]=$tempString2[0];
	}

for ($i=0;$i<size($sel);$i++)
	{
	if (!`stringArrayCount $sel[$i] $skinLoopObjects`)
		{
		print ("// SkinLoops not defined for \""+$sel[$i]+"\", skipping this\n");
		continue;
		}
	if ($createCutUp)
		{//temp geo, to maintain weights on original
		duplicate -n ($sel[$i]+"CutUp") $sel[$i];
		$tempString=`listRelatives -s ($sel[$i]+"CutUp")`;
		for ($w=0;$w<size($tempString);$w++)
			if (`getAttr ($tempString[$w]+".intermediateObject")`)
				delete $tempString[$w];
		$sel[$i]=$sel[$i]+"CutUp";
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			$tempString=`duplicate $skinLoopSets[$y]`;
			rename $tempString[0] ($skinLoopSets[$y]+"CutUp");

			select $skinLoopSets[$y];
			$tempString=`ls -sl -fl`;
			for ($t=0;$t<size($tempString);$t++)
				if (`gmatch $tempString[$t] ($sel[$i]+"[.]*")`)
					{
					sets -add ($skinLoopSets[$y]+"CutUp") $tempString[$t];
					sets -rm $skinLoopSets[$y] $tempString[$t];
					}
			}

		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			rename $skinLoopSets[$y] ($skinLoopSets[$y]+"Temp");
			rename ($skinLoopSets[$y]+"CutUp") $skinLoopSets[$y];
			}
		}
	$haveSkinCluster=0;
	$tempInt=`polyEvaluate -v $sel[$i]`;
	$numVtxs=$tempInt[0];
	if (!$createCutUp)
		$historyNodes=`listHistory $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	if ($haveSkinCluster)
		skinPercent -tv Root_M 1 $skinCluster $sel[$i];
	else
		{
		select Root_M $sel[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		$skinClusterJoints=`listConnections ($skinCluster+".matrix")`;
		$deformJoints[$y]=`substitute "SkinLoops_" $skinLoopSets[$y] ""`;
		$parentJoints[$y]=$childJoints[$y]="";
		$twistJoints[$y]=0;
/*
		for ($x=1;$x<99;$x++)
			{
			tokenize $deformJoints[$y] "_" $tempString;
			if (`objExists ($tempString[0]+"Part"+$x+"_"+$tempString[1])`)
				$twistJoints[$y]=$x;
			else
				break;
			}
*/
		$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$parentJoints[$y]=$tempString[0];
		$tempString=`listRelatives -c -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$childJoints[$y]=$tempString[0];
		if (!`stringArrayCount $deformJoints[$y] $skinClusterJoints`)
			{
			skinCluster -e -lw false -wt 0 -ai $deformJoints[$y] $skinCluster;
			$skinClusterJoints[size($skinClusterJoints)]=$deformJoints[$y];
			}
		if ($parentJoints[$y]!="")
			if (!`stringArrayCount $parentJoints[$y] $skinClusterJoints`)
				{
				skinCluster -e -lw false -wt 0 -ai $parentJoints[$y] $skinCluster;
				$skinClusterJoints[size($skinClusterJoints)]=$parentJoints[$y];
				}
		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		refresh;
		skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
		sets -add SkinLoopWeighted `ls -sl`;
		}
	select -cl;
	for ($y=0;$y<size($skinLoopSets);$y++)
		select -add $skinLoopSets[$y];
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl`;
	select ($sel[$i]+".vtx[0:"+$numVtxs+"]");
	select -d $loopVtxs;
	$nonLoopVtx=`ls -sl -fl`;
	refresh;
	weightHammerVerts;

	//another round of hammer, just near loops, to improve chance of finding $DownSideVtx
	select $loopVtxs;
	GrowPolygonSelectionRegion;
	select -d $loopVtxs;
	weightHammerVerts;

	select SkinLoops;
	ConvertSelectionToVertices;
	$allEdgeLoopVtxs=`ls -sl`;

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		$edgeLoopVtxs=`ls -sl -fl`;
		select $edgeLoopVtxs[0];
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $allEdgeLoopVtxs;
		$neighbourVtxs=`ls -sl -fl`;

		$allJointChildren=`listRelatives -ad -type joint $deformJoints[$y]`;
		for ($z=0;$z<size($neighbourVtxs);$z++)
			{
			if (`sets -im SkinLoopWeighted $neighbourVtxs[$z]`)
				continue;
			$foundDownSideVtx=0;
			select $neighbourVtxs[$z];
			$infs=`skinPercent -ignoreBelow 0.0000001 -q -t $skinCluster $neighbourVtxs[$z]`;
			for ($q=0;$q<size($infs);$q++)
				{//size($infs)==1 means EndPiece
				if (`stringArrayCount $infs[$q] $allJointChildren` || size($infs)==1)
					{
					$cutName=$deformJoints[$y]+"_"+$infs[$q]+"_Cut";
					$foundDownSideVtx=1;
					break;
					}
				}
			if (`objExists ($cutName+"WIP")` || `objExists ($infs[$q]+"_"+$deformJoints[$y]+"_CutWIP")`)
				continue;
			if ($foundDownSideVtx)
				{
				$numSel=0;
				$previousNumSel=-1;
				for ($q=0;$q<100;$q++)
					{
					ConvertSelectionToEdges;
					ConvertSelectionToVertices;
					select -d $allEdgeLoopVtxs;
					$numSel=size(`ls -sl -fl`);
					if ($numSel==$previousNumSel)
						break;
					$previousNumSel=$numSel;
					if ($skinLoopSets[$y]!="SkinLoops_Root_M")
						$z=99;//dont need to check the other $neighbourVtxs
					}
				refresh;

				$tempString=`ls -sl -fl`;
				createNode -n ($cutName+"WIP") -p CutUpWIP transform;
				select $tempString;
				if (!$createCutUp)
					{
					if (!$twistJoints[$y])
						{
						skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
						if (`gmatch $deformJoints[$y] "Spine[1-9]*"` || $deformJoints[$y]=="Chest_M" || $deformJoints[$y]=="Root_M")
							sets -add SkinLoopSpine `ls -sl`;
						}
					if ($twistJoints[$y]==2)// Only works with TwistJoints==2 For Now.
						{
						tokenize $deformJoints[$y] "_" $tempString2;
						for ($w=1;$w<$twistJoints[$y]+1;$w++)
							{
							$twistJoint=$tempString2[0]+"Part"+$w+"_"+$tempString2[1];
							if (!`stringArrayCount $twistJoint $skinClusterJoints`)
								{
								skinCluster -e -lw false -wt 0 -ai $twistJoint $skinCluster;
								$skinClusterJoints[size($skinClusterJoints)]=$twistJoint;
								}
							}
						for ($w=0;$w<size($tempString);$w++)
							{
							$infs=`skinPercent -ignoreBelow 0.0000001 -q -t $skinCluster $tempString[$w]`;
							$values=`skinPercent -ignoreBelow 0.0000001 -q -v $skinCluster $tempString[$w]`;
							$tempString2=`listRelatives -ad -type joint $infs[0]`;
							if (`stringArrayCount $infs[1] $tempString2`)
								$ratio=$values[0];
							else
								$ratio=$values[1];
							tokenize $deformJoints[$y] "_" $tempString2;
							skinPercent -tv ($tempString2[0]+"Part1_"+$tempString2[1]) $ratio 
													-tv ($tempString2[0]+"Part2_"+$tempString2[1]) (1-$ratio)
													$skinCluster $tempString[$w];
							}
						}
					select $tempString;
					sets -add SkinLoopWeighted `ls -sl`;
					}
				if ($createCutUp)
					{
					ConvertSelectionToFaces;
					$tempString=`ls -sl`;
					if (`objExists $cutName`)
						delete $cutName;
					duplicate -n $cutName $sel[$i];
					asLockAttr $cutName 0 0 0 0;
					$tempString2=`listRelatives -s $cutName`;
					for ($w=0;$w<size($tempString2);$w++)
						if (`getAttr ($tempString2[$w]+".intermediateObject")`)
							delete $tempString2[$w];					
					parent $cutName $deformJoints[$y];
					editDisplayLayerMembers -noRecurse CutUp $cutName;
					select -cl;
					for ($q=0;$q<size($tempString);$q++)
						select -add `substitute $sel[$i] $tempString[$q] $cutName`;
					InvertSelection;
					delete;
					select $cutName;
					CenterPivot;
					//cap
					for ($r=0;$r<size($skinLoopSets);$r++)
						{
						select $skinLoopSets[$r];
						$tempString=`ls -sl -o`;
						$loopAffectsCut=0;
						for ($t=0;$t<size($tempString);$t++)
							{
							$tempString2=`listRelatives -p $tempString[$t]`;
							if ($tempString2[0]==$cutName)
								{
								$loopAffectsCut=1;
								break;
								}
							}
						if (!$loopAffectsCut)
							continue;
						select -d ($sel[$i]+".e[0:99999]");
						//get radius of loop
						$circumference=0;
						$tempString=`ls -sl -fl`;
						for ($t=0;$t<size($tempString);$t++)
							{
							select $tempString[$t];
							ConvertSelectionToVertices;
							$tempString2=`ls -sl -fl`;
							$posA=`xform -q -ws -t $tempString2[0]`;
							$posB=`xform -q -ws -t $tempString2[1]`;
							$circumference+=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
							}
						$radius=($circumference/3.14)/2.0;
						select $skinLoopSets[$r];
						select -d ($sel[$i]+".e[0:99999]");
						$tempString=`polyExtrudeEdge -constructionHistory 1 -keepFacesTogether 1 -pvx 1.927402496 -pvy 3.865962148 -pvz 0.184265554 -divisions 1 -twist 0 -taper 1 -offset 0 -thickness 0 -smoothingAngle 30`;
						$extrudedSel=`ls -sl`;
						setToolTo $gMove;
						$pos=`manipMoveContext -q -position "Move"`;
						scale -r -p $pos[0] $pos[1] $pos[2] 0.25 0.25 0.25;
						$posB=`xform -q -ws -piv $cutName`;
						spaceLocator -n tempLoc1;
						xform -ws -t $posB[0] $posB[1] $posB[1] tempLoc1;
						spaceLocator -n tempLoc2;
						xform -ws -t $pos[0] $pos[1] $pos[1] tempLoc2;	
						aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 tempLoc2 tempLoc1;
						parent $cutName tempLoc1;
						select $extrudedSel;
						move -r -ls -wd ($radius*0.5) 0 0;

						parent $cutName $deformJoints[$y];
						delete tempLoc1 tempLoc2;
						select $cutName;
						DeleteHistory;
						sets -rm $skinLoopSets[$r] ($cutName+".e[0:99999]");
						}
					}
				}
			}
		}

	if (!$createCutUp)
		{
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			//Check that skinLoops comes from this object
			$tempString=`sets -q $skinLoopSets[$y]`;
			if (!size($tempString))
				continue;
			tokenize $tempString[0] "[.]" $tempString;
			if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
			if ($tempString[0]!=$sel[$i])
				continue;

			select $skinLoopSets[$y];
			ConvertSelectionToVertices;
			$tempString2=`ls -sl`;
			$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
			if (size($tempString))
				skinPercent -tv $deformJoints[$y] 0.5 -tv $tempString[0] 0.5 $skinCluster `ls -sl`;
			GrowPolygonSelectionRegion;
			select -d $tempString2;
			weightHammerVerts;
			}
		//Extra hammer Spine
		select SkinLoopSpine;
		$tempString=`ls -sl`;
		if (size($tempString))
			weightHammerVerts;
		}
	if ($createCutUp)
		{
		delete $sel[$i];
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			if (`objExists $skinLoopSets[$y]`)
				delete $skinLoopSets[$y];
			rename ($skinLoopSets[$y]+"Temp") $skinLoopSets[$y];
			}
		}

	if (!$createCutUp)
		{
		select $sel[$i];
		removeUnusedInfluences;
		}
	}


delete CutUpWIP SkinLoopWeighted SkinLoopSpine;
select -cl;
catchQuiet (`select $sel`);
if ($createCutUp)
	print "// SkinLoop CutUp completed.\n";
else
	print "// SkinLoop Bind completed.\n";
}

global proc asCopySkinLoopWeights ()
{
string $sel[]=`ls -sl`;

if (!`objExists SkinLoops`)
	error "SkinLoops not created";

int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster,$sourceSC;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

select SkinLoops;
select `ls -sl -o`;
$tempString=`ls -sl`;
string $source=$tempString[0];
$tempString=`ls -sl -showType $source`;
if ($tempString[1]=="mesh")
	{
	$tempString=`listRelatives -p $source`;
	$source=$tempString[0];
	}
$history=`listHistory -pdo 1 $source`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$sourceSC=$history[$y];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 $source`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections ($sourceSC+".matrix")`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections ($sourceSC+".matrix")`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r  $source;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc string asStripSystemLetter (string $system)
{
string $systemNoLetter=$system;
int $numLetters=size($system);
if (`gmatch $system "*[A-Z]"`)
	$systemNoLetter=`substring $system 1 ($numLetters-1)`;
return $systemNoLetter;
}

global proc int asConfirmIfNotInBuildPose ()
{
if (!`objExists DeformSet`)
	return 1;
int $proceed=1;
int $maxTextLines=35;
int $numNonDef;
string $m;
string $deformJointsList[]=`sets -q DeformSet`;
string $checkAttr[]={"rx","ry","rz","sx","sy","sz"};
float $checkValues[]={0,0,0,1,1,1};
for ($i=0;$i<size($deformJointsList);$i++)
	for ($y=0;$y<size($checkAttr);$y++)
		{
		$value=`getAttr ($deformJointsList[$i]+"."+$checkAttr[$y])`;
		if ($value>($checkValues[$y]+0.01) || $value<($checkValues[$y]-0.01))
			{
			$m+=$deformJointsList[$i]+"."+$checkAttr[$y]+" = "+$value+"\n";
			$numNonDef++;
			}
		if ($numNonDef>$maxTextLines)
			{
			$m+="...And more..\n\n";
			$y=999;
			$i=999;
			}
		}
if ($m!="")
	{
	$m+="It is reccomended that you Go to Build Pose";
	string $dialog=`confirmDialog -t "Not in Build Pose"
		-m $m
		-b "Go to Build Pose, and Proceed"
		-b "Just Proceed"
		-b "Cancel"
		-ds "Cancel" -db "Cancel"`;
	if ($dialog=="Go to Build Pose, and Proceed")
		{
		asGoToBuildPose bodySetup;
		refresh;
		}
	if ($dialog=="Go to Build Pose, and Proceed" || $dialog=="Just Proceed")
		$proceed=1;
	else
		$proceed=0;
	}
return $proceed;
}

global proc asLockAttr (string $object, int $trans, int $rot, int $scale, int $vis)
{
setAttr -l $trans -k (!$trans) ($object+".translateX");
setAttr -l $trans -k (!$trans) ($object+".translateY");
setAttr -l $trans -k (!$trans) ($object+".translateZ");
setAttr -l $rot -k (!$rot) ($object+".rotateX");
setAttr -l $rot -k (!$rot) ($object+".rotateY");
setAttr -l $rot -k (!$rot) ($object+".rotateZ");
setAttr -l $scale -k (!$scale) ($object+".scaleX");
setAttr -l $scale -k (!$scale) ($object+".scaleY");
setAttr -l $scale -k (!$scale) ($object+".scaleZ");
setAttr -l $vis -k (!$vis) ($object+".visibility");
}

global proc float asgetCharHeight ()
{
float $height;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
return $height;
}

global proc asCreateSkeleton ()
{
asCreateFromFitGeometry Bone;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;

float $scale;
float $pos[],$pos2[];
string $tempString[];
string $copyBones[]={"Pelvis","Ribs","Eye","Cup","Ankle","ToeBall"};
if (!`objExists WristBone_R`)
	$copyBones[size($copyBones)]="Wrist";
string $joint,$side,$childJoint;
for ($i=0;$i<size($copyBones);$i++)
	for ($a=0;$a<3;$a++)
		{
		if ($a==0) $side="_M";
		if ($a==1) $side="_L";
		if ($a==2) $side="_R";
		$joint=$copyBones[$i]+$side;
		if ($copyBones[$i]=="Pelvis") $joint="Root"+$side;
		if ($copyBones[$i]=="Ribs") $joint="Chest"+$side;
		if ($copyBones[$i]=="ToeBall") $joint="Toes"+$side;
		if (!`objExists $joint` || !`objExists ($copyBones[$i]+"Bone")`)
			continue;
		createNode -n ($copyBones[$i]+"BoneParentConstraint"+$side) transform;
		parent ($copyBones[$i]+"BoneParentConstraint"+$side)  SkeletonGeometry;
		duplicate -n ($copyBones[$i]+"Bone"+$side) ($copyBones[$i]+"Bone");
		parent ($copyBones[$i]+"Bone"+$side) ($copyBones[$i]+"BoneParentConstraint"+$side);
		parentConstraint $joint ($copyBones[$i]+"BoneParentConstraint"+$side);
		setAttr ($copyBones[$i]+"Bone"+$side+".v") 1;
		sets -e -forceElement asBonesSG ($copyBones[$i]+"Bone"+$side);
		editDisplayLayerMembers -noRecurse PolySkeleton ($copyBones[$i]+"Bone"+$side);
		$childJoint=`asRlaChild $joint`;
		if ($copyBones[$i]=="Wrist" && `objExists ("MiddleFinger1"+$side)`) $childJoint=("MiddleFinger1"+$side);
		if ($childJoint!="")
			{
			$pos=`xform -q -ws -t $joint`;
			$pos2=`xform -q -ws -t $childJoint`;
			$scale=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			xform -os -a -s $scale $scale $scale ($copyBones[$i]+"Bone"+$side);
			}
		if ($side=="_L")
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($copyBones[$i]+"Bone"+$side);
		}

//PelvisBone
xform -ws -ro 0 0 0 PelvisBone_M;
$tempString=`listRelatives -type joint -c Root_M`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*_R"`)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		$pos2=`xform -q -ws -t Root_M`;
		xform -ws -t 0 (($pos[1]+$pos2[1])/2.0) (($pos[2]+$pos2[2])/2.0) PelvisBone_M;
		xform -os -a -s ($pos[0]*-1) ($pos[0]*-1) ($pos[0]*-1) PelvisBone_M;
		}

//Ribs
if (`objExists RibsBone_M`)
	{
	$pos=`xform -q -ws -t Root_M`;
	$scale=$pos[1]*0.18;
	if (`objExists Shoulder_R`)
		{
		$pos=`xform -q -ws -t Chest_M`;
		$pos2=`xform -q -ws -t Shoulder_R`;
		$scale=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		}
	xform -os -a -s $scale $scale $scale RibsBone_M;
	}

//MetaCarpals (Wrist)
string $deformJointsList[]=`sets -q "DeformSet"`;
float $childScale[3]={1,1,1};
for ($i=0;$i<size($deformJointsList);$i++)
	{
	string $children[]=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if ($childJoint!="" || size($children)==0)
		continue;
	if ($deformJointsList[$i]=="Root_M")
		continue;
	int $numChar=size($deformJointsList[$i]);
	string $sourceBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone"+`substring $deformJointsList[$i] ($numChar-1) 99`;
	for ($y=0;$y<size($children);$y++)
		{
		$numChar=size($children[$y]);
		string $childBone=`substring $children[$y] 1 ($numChar-2)`+"Bone"+`substring $children[$y] ($numChar-1) 99`;
		string $newBone=`substitute "Bone" $sourceBone ("Bone"+($y+1))`+"_"+$children[$y];
		if (!`objExists $sourceBone`)
			continue;
		duplicate -n $newBone $sourceBone;
		asLockAttr $newBone 0 0 0 0;
		$pos=`xform -q -ws -t $newBone`;
		if ($pos[0]>0)
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 $newBone;
		delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $children[$y] $children[$y] $newBone`;
		if (`objExists $childBone`)
			$childScale=`getAttr ($childBone+".s")`;
		if (`gmatch $children[$y] "Cup_*"` && `objExists PinkyFinger1Bone_R`)
			$childScale=`getAttr PinkyFinger1Bone_R.s`;
		setAttr -type float3 ($newBone+".s") ($childScale[0]*1.5) ($childScale[1]*1.5) ($childScale[2]*1.5);
		$pos=`xform -q -ws -t $children[$y]`;
		$pos2=`xform -q -ws -t $deformJointsList[$i]`;
		$scale=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		setAttr ($newBone+".sx") $scale;
		}
	if (`objExists $sourceBone`)
		delete $sourceBone;
	}

//Ankle
if (`objExists Toes_R` && `objExists AnkleBone_R` && `objExists Ankle_R` && `objExists Heel`)
	{
	$pos=`xform -q -ws -t Heel`;
	xform -ws -t $pos[0] $pos[1] $pos[2] AnkleBone_R;
	$pos=`xform -q -ws -t Toes_R`;
	createNode -n tempAimAt transform;
	xform -ws -t $pos[0] 0 $pos[2] tempAimAt;
	delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "scene" tempAimAt AnkleBone_R`;
	delete tempAimAt;
	$pos=`xform -q -ws -t Toes_R`;
	$pos2=`xform -q -ws -t AnkleBone_R`;
	$scale=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	setAttr AnkleBone_R.sx $scale;
//	$childScale=`getAttr ToesBone_R.s`;
	float $childScaleY=`getAttr Toes.fat`*`getAttr Toes.fatZ`*2;
	setAttr AnkleBone_R.sz $childScaleY;
	$pos=`xform -q -ws -t Ankle_R`;
	setAttr AnkleBone_R.sy $pos[1];
	}

//ToeBallBone_R
if (`objExists ToeBallBone_R` && `objExists Toes_R` && `objExists ToesEnd_R`)
	for ($a=0;$a<3;$a++)
		{
		if ($a==0) $side="_M";
		if ($a==1) $side="_L";
		if ($a==2) $side="_R";
		if (`objExists ("ToeBallBone"+$side)` && `objExists ("ToesBoneParentConstraint"+$side)`)
			delete ("ToesBoneParentConstraint"+$side);
		$pos=`xform -q -ws -t Toes_R`;
		xform -ws -t $pos[0] 0 $pos[2] ToeBallBone_R;
		createNode -n tempAimAt transform;
		$pos=`xform -q -ws -t ToesEnd_R`;
		xform -ws -t $pos[0] 0 $pos[2] tempAimAt;
		delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "scene" tempAimAt ToeBallBone_R`;
		delete tempAimAt;
		}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;

asMirrorGeometry Skeleton 0;

print ("Skeleton created\n");
select -cl;
}

global proc asDeleteSkeleton ()
{
string $deleteObjs[]={"SkeletonGeometry","PolySkeleton","Skeleton_Geometry","Mannequin_Geometry","Skeleton","tempAimAt"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreateFromFitGeometry (string $geo)
{
//$geo=Box, Cyl, Bone
if (!`asConfirmIfNotInBuildPose`)
	return;
string $geoLongName="Boxes";
if ($geo=="Cyl")
	$geoLongName="Cylinders";
if ($geo=="Bone")
	$geoLongName="Skeleton";
string $sourceGeo=$geo;
if (`getModifiers`==4)
	$sourceGeo="Cyl";
if (`objExists ($geoLongName+"Geometry")`)
	error ("\""+$geoLongName+"Geometry\" Alread exists");
if (`objExists ("Poly"+$geoLongName)`)
	error ("\"Poly"+$geoLongName+"\" Alread exists");
createNode -n ($geoLongName+"Geometry") -p Geometry transform;
createDisplayLayer -e -name ("Poly"+$geoLongName);
setAttr ("Poly"+$geoLongName+".color") 14;
if ($geo=="Bone")
	setAttr ("Poly"+$geoLongName+".color") 21;

float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;
float $visGap=`getAttr FitSkeleton.visGap`;
float $pos[],$rot[];
if (`objExists asMirror`)
	delete asMirror;
checkBox -e -v 1 asVisGeo;
asFitGeometry;
setAttr FitSkeleton.visGap 1;
	dgdirty -a;
refresh;
setAttr FitSkeletonVisualizers.v 0;
refresh;

string $joint;
string $aimsAD[]=`listRelatives -ad -type transform Aims`;
for ($i=$y=0;$i<size($aimsAD);$i++)
	if (`gmatch $aimsAD[$i] ("*"+$sourceGeo+"*")`)
		{
		$joint=`substitute $sourceGeo $aimsAD[$i] ""`;
		string $side="_M";
		$pos=`xform -q -ws -t $aimsAD[$i]`;

		if ($pos[0]<$sideTreshold*-1)
			$side="_R";
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==-1 && $side=="_M") continue;
			if ($b==-1 && $side=="_R") $side="_L";

			if (!`objExists ($joint+$side)`)//could be `noMirror`
				continue;

			duplicate -n ($aimsAD[$i]+$side) $aimsAD[$i];
			editDisplayLayerMembers -noRecurse ("Poly"+$geoLongName) ($aimsAD[$i]+$side);
			setAttr ($aimsAD[$i]+$side+".v") 1;
			createNode -n asMirror transform;
			parent ($aimsAD[$i]+$side) asMirror;
			if ($side=="_L")
				{
				setAttr asMirror.sx -1;
				polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($aimsAD[$i]+$side);
//				setAttr ($aimsAD[$i]+$side+".sz") (`getAttr ($aimsAD[$i]+$side+".sz")`*-1);
				}
			parent -w ($aimsAD[$i]+$side);
			delete asMirror;
			createNode -n ($aimsAD[$i]+"ParentConstraint"+$side) -p ($geoLongName+"Geometry") transform;
			asAlign ($aimsAD[$i]+"ParentConstraint"+$side) ($aimsAD[$i]+$side) 1 1 0 0;
			parentConstraint -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			scaleConstraint  -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			parent ($aimsAD[$i]+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			setAttr ($aimsAD[$i]+$side+"Shape.overrideEnabled") 0;
			asLockAttr ($aimsAD[$i]+$side) 1 1 0 0;
//			if ($geo=="Box")
//				asMirrorGeometry Boxes 0; // slower, but looks better
//			refresh;
			}
		}
setAttr FitSkeleton.visGap $visGap;
delete FitSkeletonVisualizers;
}

global proc asCreatePolyBoxes ()
{
asCreateFromFitGeometry Box;
float $fitSkeletonScale=`getAttr FitSkeleton.sx`;
float $mag;
float $scale[3],$posA[3],$posB[3];
string $toes,$heel,$childLabel;
string $tempString[];
string $deformJointsList[]=`sets -q "DeformSet"`;
for ($i=0;$i<size($deformJointsList);$i++)
	{
	int $numChar=size($deformJointsList[$i]);
	string $joint=`substring $deformJointsList[$i] 1 ($numChar-2)`;
	string $side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	if ($tempString[0]=="")
		continue;
	if (`objExists ($joint+"Box"+$side)`)
		continue;
	if (`gmatch $deformJointsList[$i] "*Eye*"`)
		continue;
	createNode -n ($joint+"BoxParentConstraint"+$side) -p BoxesGeometry transform;
	duplicate -n ($joint+"Box"+$side) RootBox_M;
	parent ($joint+"Box"+$side) ($joint+"BoxParentConstraint"+$side);
	setAttr -type float3 ($joint+"Box"+$side+".s") 1 1 1;
	xform -ws -t 0 0.875 -0.875 ($joint+"Box"+$side+".vtx[0]");
	xform -ws -t 0 0.875 0.875 ($joint+"Box"+$side+".vtx[1]");
	xform -ws -t 1 0.875 -0.875 ($joint+"Box"+$side+".vtx[2]");
	xform -ws -t 1 0.875 0.875 ($joint+"Box"+$side+".vtx[3]");
	xform -ws -t 1 -0.875 -0.875 ($joint+"Box"+$side+".vtx[4]");
	xform -ws -t 1 -0.875 0.875($joint+"Box"+$side+".vtx[5]");
	xform -ws -t 0 -0.875 -0.875 ($joint+"Box"+$side+".vtx[6]");
	xform -ws -t 0 -0.875 0.875 ($joint+"Box"+$side+".vtx[7]");
	parentConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
	scaleConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
	$scale={0.1,1,1};
	$scale[1]=`getAttr ($joint+$side+".fat")`*`getAttr ($joint+$side+".fatY")`*$fitSkeletonScale;
	$scale[2]=`getAttr ($joint+$side+".fat")`*`getAttr ($joint+$side+".fatZ")`*$fitSkeletonScale;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	$mag=0;
	for ($y=0;$y<size($tempString);$y++)
		{
		$posA=`xform -q -ws -t $deformJointsList[$i]`;
		$posB=`xform -q -ws -t $tempString[$y]`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($mag>$scale[0]) {
		$scale[0]=$mag;}
		}
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		{
		$tempString=`listRelatives -c -type joint $joint`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*Ball*"`)
				$toes=$tempString[$y];
			if (`gmatch $childLabel "*Heel*"`)
				$heel=$tempString[$y];
			}
		}
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		{
		$posA=`xform -q -ws -t $deformJointsList[$i]`;
		$scale[0]=$posA[1];
		}
	setAttr -type float3 ($joint+"Box"+$side+".s") $scale[0] $scale[1] $scale[2];
	if (`gmatch $deformJointsList[$i] "*Ankle*"` && `objExists $toes` && `objExists ($toes+"Box"+$side)` && `objExists $heel`)
		{
		polySubdivideFacet -dv 1 -m 0 -ch 0 ($joint+"Box"+$side);
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[0]")`;
		xform -ws -t $posA[0] $posA[1] $posA[2] ($joint+"Box"+$side+".vtx[12]");
		$posB=`xform -q -ws -t ($toes+"Box"+$side+".vtx[1]")`;
		xform -ws -t $posB[0] $posB[1] $posB[2] ($joint+"Box"+$side+".vtx[10]");
		xform -ws -t (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) ($joint+"Box"+$side+".vtx[8]");

		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[6]")`;
		xform -ws -t $posA[0] 0 $posA[2] ($joint+"Box"+$side+".vtx[2]");
		$posB=`xform -q -ws -t ($toes+"Box"+$side+".vtx[7]")`;
		xform -ws -t $posB[0] 0 $posB[2] ($joint+"Box"+$side+".vtx[3]");
		xform -ws -t (($posA[0]+$posB[0])/2.0) 0 (($posA[2]+$posB[2])/2.0) ($joint+"Box"+$side+".vtx[11]");

		$posA=`xform -q -ws -t $heel`;
		$posB=`xform -q -ws -t ($joint+"Box"+$side+".vtx[15]")`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		move -r -os -wd 0 ($mag*-1) 0 ($joint+"Box"+$side+".vtx[4:5]") ($joint+"Box"+$side+".vtx[15]");

		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[7]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[7]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[6]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[6]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[5]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[5]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[4]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[4]");
		}
	}

asMirrorGeometry Boxes 0;
print "// PolyBoxes created\n";
select -cl;
}

global proc asDeletePolyBoxes ()
{
if (`objExists "BoxesGeometry"`)
	delete "BoxesGeometry";
if (`objExists "PolyBoxes"`)
	delete "PolyBoxes";
}

global proc asCreateBoolean ()
{
global string $gMainProgressBar;
int $vs[];
string $tempString[],$tempString2[],$boxes[];
string $dupObj,$dupBox,$joint,$puppet,$restoreVisCmd;

if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	refresh;
	}
string $dialog=`confirmDialog -t "Boolean"
	-m "Attempt to Boolean selected geometry with PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "BoxesGeometry"`)
	error "No BoxesGeometry in scene !";
$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}


string $objs[]=`ls -sl`;
if (size($objs)<1)
	error "No Objects Selected !";

if (!`objExists Bool`)
	{
	createDisplayLayer -e -name Bool;
	setAttr Bool.color 21;
	setAttr Bool.displayType 2;
	}
dgdirty -a;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Creating Booleans" -bp -ii 1 -min 0 -max (size($objs)) $gMainProgressBar;
for ($i=0;$i<size($objs);$i++)
	{
	$restoreVisCmd+="setAttr "+$objs[$i]+".v "+`getAttr ($objs[$i]+".v")`+";";
	setAttr ($objs[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($objs);$i++)
	{
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
		$joint=`substitute "Box" $boxes[$y] ""`;
		if (`objExists ($tempString[0]+"Bool"+"_"+$tempString[1])`)
			warning ("Object \""+$tempString[0]+"Bool"+"_"+$tempString[1]+"\" Already exists...\n");
		$bool=`createNode -n ($tempString[0]+"Bool"+"_"+$tempString[1]) transform`;
		delete $bool;
		$dupObj=$objs[$i]+"_"+$boxes[$y];
		duplicate -n $dupObj $objs[$i];
		$tempString=`listRelatives -p $dupObj`;
		if ($tempString[0]!="")
			parent -w $dupObj;
		setAttr ($dupObj+".visibility") 0;
		$dupBox=$objs[$i]+"_"+$boxes[$y]+"Box";
		duplicate -n $dupBox $boxes[$y];
		asLockAttr $dupBox 0 0 0 0;
		parent -w $dupBox;
		select -r $dupObj $dupBox;
		refresh;
		$tempString=`polyBoolOp -n $dupObj -op 3 -ch 0 $dupObj $dupBox`;
		if (`objExists $dupObj`) delete $dupObj;
		if (`objExists $dupBox`) delete $dupBox;
		rename $tempString[0] $bool;
		$vs=`polyEvaluate -v $bool`;
		if (!$vs[0])
			delete  $bool;
		else
			{
			parent $bool $joint;
			editDisplayLayerMembers -noRecurse Bool $bool;
			}
		}
	}
eval ($restoreVisCmd);
progressBar -e -ep $gMainProgressBar;

print ("// Boolean created\n");
select -cl;
}

global proc asDeleteBoolean ()
{
string $all[]=`ls -r 1 -type transform "*Bool_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Bool`)
	delete Bool;
}

global proc asCreateWarp ()
{
global string $gMainProgressBar;
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
string $dialog=`confirmDialog -t "Warp"
	-m "Attempt to Warp selected geometry to PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	}
if (!`objExists Warp`)
	{
	createDisplayLayer -e -name Warp;
	setAttr Warp.color 28;
	setAttr Warp.displayType 2;
	}
int $sideFactor,$isEndJoint,$divisions;
int $tempInt[];
float $pos[],$facePos[];
string $restoreVisCmd;
string $tempString[],$tempString2[],$boxes[];
string $sel[]=`ls -sl`;
string $wrapBox,$SG;
string $multiSGs[];
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
createNode -n closestSampler closestPointOnMesh;

$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	$restoreVisCmd+="setAttr "+$sel[$i]+".v "+`getAttr ($sel[$i]+".v")`+";";
	setAttr ($sel[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -ni -s $sel[$i]`;
	string $meshNode=$tempString[0];
	$tempString=`listConnections ($tempString[0]+".instObjGroups")`;
	if ($tempString[0]!="")
		$SG=$tempString[0];
	else
		{
		//faceAssigned shaders
		for ($y=0;$y<`getAttr -s ($meshNode+".instObjGroups.objectGroups")`;$y++)
			{
			if($y==0)
				{
				//temp copy of mesh, so we can freeze xforms
				$tempString=`duplicate -n tempMesh $sel[$i]`;
				setAttr -l 0 tempMesh.tx;setAttr -l 0 tempMesh.ty;setAttr -l 0 tempMesh.tz;
				setAttr -l 0 tempMesh.rx;setAttr -l 0 tempMesh.ry;setAttr -l 0 tempMesh.rz;
				setAttr -l 0 tempMesh.sx;setAttr -l 0 tempMesh.sy;setAttr -l 0 tempMesh.sz;
				setAttr -l 0 tempMesh.v 0;
				catchQuiet (`parent -w tempMesh`);
				makeIdentity -a 1 -t 1 -r 1 -s 1 tempMesh;
				connectAttr -f tempMesh.outMesh closestSampler.inMesh;
				}
			$tempString=`listConnections -type shadingEngine ($meshNode+".instObjGroups.objectGroups["+$y+"].objectGrpColor")`;
			if ($tempString[0]!="")
				$multiSGs[size($multiSGs)]=$tempString[0];
			}
		}
	progressBar -e -st ("Creating Warps for:"+$sel[$i]) -bp -ii 1 -min 0 -max (size($boxes)) $gMainProgressBar;
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;return;}
		progressBar -e -s 1 $gMainProgressBar;
		if (`gmatch $boxes[$y] "*_L_*"`)
			$sideFactor=-1;
		else
			$sideFactor=1;
		$joint=`substitute "Box" $boxes[$y] ""`;
		tokenize $boxes[$y] "_" $tempString;
		for ($z=1;$z<99;$z++)
			if (!`objExists ($tempString[0]+"Warp"+$z+"_"+$tempString[1])`)
				break;
		$warpBox=$tempString[0]+"Warp"+$z+"_"+$tempString[1];
		$isEndJoint=0;
		$tempString=`listRelatives -type joint -c $joint`;
		if (!size($tempString))
			$isEndJoint=1;
		else if (!`sets -im DeformSet $tempString[0]`)
			$isEndJoint=1;			
		duplicate -n $warpBox $boxes[$y];
		setAttr -k 1 -l 0 ($warpBox+".tx");setAttr -k 1 -l 0 ($warpBox+".ty");setAttr -k 1 -l 0 ($warpBox+".tz");
		setAttr -k 1 -l 0 ($warpBox+".rx");setAttr -k 1 -l 0 ($warpBox+".ry");setAttr -k 1 -l 0 ($warpBox+".rz");
		parent $warpBox	$joint;
		$divisions=2;
		if ($joint=="Head_M")
			$divisions=4;
		catch (`polySmooth -mth 0 -dv $divisions -bnr 1 -c 1 -kb 1 -ksb 1 -khe 1 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $warpBox`);
		scale -r -ocp 1 0.7 0.7 ($warpBox+".e[0:15]");
		scale -r -ocp 1 0.9 0.9 ($warpBox+".vtx[34:50]") ($warpBox+".vtx[52]") ($warpBox+".vtx[54]") ($warpBox+".vtx[56]") ($warpBox+".vtx[58]") ($warpBox+".vtx[60]") ($warpBox+".vtx[62]") ($warpBox+".vtx[64]") ($warpBox+".vtx[74:89]");
		select $sel[$i];
		select -add $warpBox;
		transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;

		select $warpBox;
		DeleteHistory;

		//round ends
		if (size($multiSGs))
			{
			$tempInt=`polyEvaluate -f $warpBox`;
			for ($z=0;$z<$tempInt[0];$z++)
				{
				if (`progressBar -q -ic $gMainProgressBar`)
					{progressBar -e -ep $gMainProgressBar;return;}
				$pos=`xform -q -ws -t ($warpBox+".f["+$z+"]")`;
				$facePos[0]=$facePos[1]=$facePos[2]=0;
				for ($a=0;$a<size($pos);$a=$a+3)
					{$facePos[0]+=$pos[$a];$facePos[1]+=$pos[$a+1];$facePos[2]+=$pos[$a+2];}
				$facePos[0]/=(size($pos)/3);$facePos[1]/=(size($pos)/3);$facePos[2]/=(size($pos)/3);
				setAttr closestSampler.inPosition $facePos[0] $facePos[1] $facePos[2];
				int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
				for ($a=0;$a<size($multiSGs);$a++)
					if (`sets -im $multiSGs[$a] ($sel[$i]+".f["+$closestFaceIndex+"]")`)
						sets -e -forceElement $multiSGs[$a] ($warpBox+".f["+$z+"]");
				}

			}
		else
			{
			$tempString=`listRelatives -ni -s $warpBox`;
			sets -e -forceElement $SG $tempString[0];
			}

		editDisplayLayerMembers -noRecurse Warp $warpBox;
		refresh;
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
progressBar -e -ep $gMainProgressBar;
eval ($restoreVisCmd);

print ("// Warp created\n");
select -cl;
}

global proc asDeleteWarp ()
{
string $all[]=`ls -r 1 -type transform "*Warp*_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Warp`)
	delete Warp;
}

global proc asCreateMannequin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

if (`objExists MannequinGeometry`)
	error "MannequinGeometry already exists";
createNode -n MannequinGeometry transform;
parent MannequinGeometry "Geometry";

if (!`objExists Mannequin`)
	{
	createDisplayLayer -e -name Mannequin;
	setAttr Mannequin.color 24;
	setAttr Mannequin.displayType 2;
	editDisplayLayerMembers -noRecurse Mannequin  MannequinGeometry;
	}
float $charHeight=`asgetCharHeight`;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];
float $temp[],$temp2[],$temp3[];
int $sideFactor;
vector $childVec;
string $skipJoints[]={"Spine[0-9]*","Root_M","Chest_M","Jaw_M","Head_*","Eye_*"};

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
setAttr Mannequin_Geometry.v 0;
setAttr Skeleton_Geometry.v 0;

$tempString=`listRelatives -c -type transform Mannequin_Geometry`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 1;

for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if (`gmatch $deformJointsList[$i] "Wrist_*"`)
		for ($y=0;$y<size($children);$y++)
			if (`gmatch $children[$y] "MiddleFinger1_*"`)
				$childJoint=$children[$y];
	if ($childJoint=="")
		continue;
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	int $skipMe=0;

	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$children=`listRelatives -c -type joint $childJoint`;
		$childJoint=$children[0];
		}
	$temp=`xform -q -ws -t $deformJointsList[$i]`;
	$temp2=`xform -q -ws -t $childJoint`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;

	//spine
	if ($deformJointsList[$i]=="Root_M" || `gmatch $deformJointsList[$i] "*Spine[0-9]*"` || `gmatch $deformJointsList[$i] "*Chest*"` || `gmatch $deformJointsList[$i] "*Head_*"`)
		{
		if (`gmatch $deformJointsList[$i] "Head_*"`)
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Head`;
		else
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Root`;
		$poly=$tempString[0];
//		parentConstraint $deformJointsList[$i] $poly;
		delete `parentConstraint $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		xform -os -s ($lenght/1) ($charHeight/10) ($charHeight/10) $poly;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}

	

	for ($y=0;$y<size($skipJoints);$y++)
		if (`gmatch $deformJointsList[$i] $skipJoints[$y]`)
			$skipMe=1;
	if ($skipMe) continue;

	if (`gmatch $deformJointsList[$i] "*Ankle*"` || `gmatch $deformJointsList[$i] "Toes*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Foot`;
		$poly=$tempString[0];
		xform -ws -t $temp[0] 0 $temp[2] $poly;
		xform -os -s ($lenght/1) ($lenght/1) ($lenght/1) $poly;
		//take on -ws .ry
		$temp3=`xform -q -ws -ro $deformJointsList[$i]`;
		if (`gmatch $deformJointsList[$i] "*Ankle*"`)
			$temp3=`xform -q -ws -ro $childJoint`;
		xform -ws -ro 0 ($temp3[1]-90) 0 $poly;
		//move forward
		move -r -os -wd 0 0 ($lenght/-4.0) $poly;
//		parentConstraint -mo $deformJointsList[$i] $poly;
		delete `parentConstraint -mo $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	else
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Limb") Mannequin_Limb`;
		$poly=$tempString[0];
		xform -os -s ($lenght) ($lenght/2) ($lenght/2) $poly;
		if (`gmatch $deformJointsList[$i] "Wrist*"`)
			setAttr ($poly+".sy") (`getAttr ($poly+".sy")`*3);
		if (`gmatch $deformJointsList[$i] "Toes*"`)
			setAttr ($poly+".sz") (`getAttr ($poly+".sz")`*3);
		if (`gmatch $deformJointsList[$i] "*Finger*"`)
			xform -os -s $lenght ($charHeight/70) ($charHeight/70) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($lenght*1.1) ($charHeight/10) ($charHeight/10) $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`)
			{
			setAttr ($poly+".sx") (`getAttr ($poly+".sx")`*-1);
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 $poly;
			}
//		parentConstraint $deformJointsList[$i] $poly;
		delete `parentConstraint $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($poly+"Shape.opposite") 0;
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Sphere`;
	$poly=$tempString[0];
	xform -os -s ($lenght/2) ($lenght/2) ($lenght/2) $poly;
	if (`gmatch $deformJointsList[$i] "*Finger*"`)
		xform -os -s ($charHeight/50) ($charHeight/50) ($charHeight/50) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "Wrist*"`)
		xform -os -s ($charHeight/20) ($charHeight/20) ($charHeight/20) $poly;
	if (`gmatch $deformJointsList[$i] "Shoulder_*"` || `gmatch $deformJointsList[$i] "Hip_*"`)
		xform -os -s ($charHeight/7) ($charHeight/7) ($charHeight/7) $poly;

//	parentConstraint $deformJointsList[$i] $poly;
	delete `parentConstraint $deformJointsList[$i] $poly`;
	parent $poly MannequinGeometry;
	catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//	scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	refresh;
	}
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;

if (`objExists shaderMannequin`) delete shaderMannequin;
if (`objExists shaderMannequinSG`) delete shaderMannequinSG;
shadingNode -n shaderMannequin -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name shaderMannequinSG;
connectAttr -f shaderMannequin.outColor shaderMannequinSG.surfaceShader;
setAttr -type float3 shaderMannequin.color 0.78 0.63 0.42;
setAttr shaderMannequin.ambientColor -type double3 0.53 0.42 0.25;

sets -e -forceElement shaderMannequinSG MannequinGeometry;


print ("// Mannequin created\n");
select -cl;
}

global proc asDeleteMannequin ()
{
string $deleteObjs[]={"MannequinGeometry","Mannequin_Geometry","Mannequin","wood","woodSG","woodShader"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asHidePolyBoxes (int $onOff)
{
if (!`objExists "BoxesGeometry"`)
	error "BoxesGeometry does not exists !\n";
setAttr -l 0 "BoxesGeometry.visibility";
setAttr -l ($onOff) "BoxesGeometry.visibility" (!$onOff);
if (!$onOff)
	setAttr -l ($onOff) "BoxesGeometry.visibility";
}

global proc asMirrorGeometry (string $geometry, int $L2R)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
int $vs[];
float $scale[3],$pos[3];
string $box,$matchBox;
string $allPCs[]=`listRelatives -type transform -c ($geometry+"Geometry")`;
for ($i=0;$i<size($allPCs);$i++)
	{
	$box=`substitute "ParentConstraint" $allPCs[$i] ""`;
	if ($L2R)
		$matchBox=`substitute "_L" $box "_R"`;
	else
		$matchBox=`substitute "_R" $box "_L"`;

	if ($box==$matchBox || `gmatch $box "*_M"`)
		continue;

	if (!`objExists $matchBox`)
		continue;

	$scale=`getAttr ($box+".scale")`;
	setAttr -type float3 ($matchBox+".scale") $scale[0] $scale[1] $scale[2];
	$vs=`polyEvaluate -v $box`;
	for ($y=0;$y<$vs[0];$y++)
		{
		$pos=`xform -q -ws -t ($box+".vtx["+$y+"]")`;
		xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($matchBox+".vtx["+$y+"]");
		}
	}
}

global proc asMirrorControlCurves (int $L2R, string $set)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
string $controlObjects[]=`sets -q $set`;
string $shapes[];
string $oppositeShape,$oppositeControlObject;
float $pos[];
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($controlObjects);$i++)
	{
	$shapes=`listRelatives -s $controlObjects[$i]`;
	if ($shapes[0]=="")
		continue;
	$objType=`objectType $shapes[0]`;
	if ($objType!="nurbsCurve")
		continue;

	if ($L2R)
		{
		if (!`gmatch $shapes[0] "*_L*"`)
			continue;
		}
	else
		{
		if (!`gmatch $shapes[0] "*_R*"`)
			continue;
		}

	if ($L2R)
		{
		$oppositeShape=`substitute "_L" $shapes[0] "_R"`;
		$oppositeControlObject=`substitute "_L" $controlObjects[$i] "_R"`;
		}
	else
		{
		$oppositeShape=`substitute "_R" $shapes[0] "_L"`;
		$oppositeControlObject=`substitute "_R" $controlObjects[$i] "_L"`;
		}

	if (!`objExists $oppositeShape`)
		continue;

	$form=`getAttr ($shapes[0]+".form")`;
	$spans=`getAttr ($shapes[0]+".spans")`;
	$degrees=`getAttr ($shapes[0]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;

	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($shapes[0]+".cv["+$y+"]")`;
		if ($y==0)	$z=2;
		if ($y==1)	$z=3;
		if ($y==2)	$z=0;
		if ($y==3)	$z=1;
		if ($y==4)	$z=2;
		if ($set=="SkinCageCurvesSet")
			{
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$z+"]");
			if ($y==2)
				xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv[4]");
			}
		else
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$y+"]");
		}

	//Mirror slideJoints
	if ($set=="SkinCageCurvesSet")
		{
		string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $controlObjects[$i]`;
		int $haveSliderJoint[4];
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
				$haveSliderJoint[$y]=1;
			else
				$haveSliderJoint[$y]=0;
		if ($haveSliderJoint[0] || $haveSliderJoint[1] || $haveSliderJoint[2] || $haveSliderJoint[3])
			{
			select $oppositeControlObject;
			asCreateSliders;
			//mirror .slide values
			for ($y=0;$y<4;$y++)
				{
				string $sliderJoint=$skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y;
				string $oppositeSliderJoint;
				if ($L2R) $oppositeSliderJoint=`substitute "_L" $sliderJoint "_R"`;
				else $oppositeSliderJoint=`substitute "_R" $sliderJoint "_L"`;
				if ($y==0) $oppositeSliderJoint=`substitute "0" $oppositeSliderJoint "2"`;
				if ($y==1) $oppositeSliderJoint=`substitute "1" $oppositeSliderJoint "3"`;
				if ($y==2) $oppositeSliderJoint=`substitute "2" $oppositeSliderJoint "0"`;
				if ($y==3) $oppositeSliderJoint=`substitute "3" $oppositeSliderJoint "1"`;
				if (`objExists $sliderJoint` && `objExists $oppositeSliderJoint`)
					setAttr ($oppositeSliderJoint+".slide") `getAttr ($sliderJoint+".slide")`;
				}
			}
		else // sliders might have been deleted, this should also mirror
			{
			string $oppositeSkinCurveSliderInfo[]=`asSkinCurveSliderInfo $oppositeControlObject`;
			int $oppositeHaveSliderJoint[4];
			for ($y=0;$y<4;$y++)
				if (`objExists ($oppositeSkinCurveSliderInfo[0]+"_"+$oppositeSkinCurveSliderInfo[1]+"Slider"+$y)`)
					$oppositeHaveSliderJoint[$y]=1;
			if ($oppositeHaveSliderJoint[0] || $oppositeHaveSliderJoint[1] || $oppositeHaveSliderJoint[2] || $oppositeHaveSliderJoint[3])
				{
				select $oppositeControlObject;
				asDeleteSliders;
				}
			}
		}
	}
select $sel;
}

global proc asScaleControlCurves ()
{
//scale selected if any control curves are selected, otherwice scale all
float $scale=`floatField -q -v ScaleCCFloatField`;
string $controlObjects[];
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (`sets -im ControlSet $sel[$i]`)
		$controlObjects[size($controlObjects)]=$sel[$i];
if (!size($controlObjects))
	$controlObjects=`sets -q "ControlSet"`;
string $controlCurves[];
string $tempString[];
for ($i=0;$i<size($controlObjects);$i++)
	{
	$tempString=`listRelatives -s $controlObjects[$i]`;
	if (!size($tempString))
		continue;
	select -cl;
	refresh;
	select -cl;
	for ($y=0;$y<100;$y++)
		select -add ($tempString[0]+".cv["+$y+"]");
	scale -r $scale $scale $scale;
	}
select $sel;
}

global proc string[] asSkinCurveSliderInfo (string $skinCurve)
{
string $info[];//[0]=$deformJoint [1]=start/middle/end [2]=restoreWeightsToJoint
string $childJoint;
string $tempString[];
tokenize $skinCurve "_" $tempString;
string $deformJoint=$tempString[0]+"_"+$tempString[1];
$info[0]=$deformJoint;
if (`gmatch $skinCurve "*_middleProfile"`)
	$info[1]="middle";
if (`gmatch $skinCurve "*_startProfile"`)
	$info[1]="start";
if (`gmatch $skinCurve "*_endProfile"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile1"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile[2-9]"`)
	{
	//First some traversing to find the childJoint
	$tempString=`listRelatives -c -type joint $deformJoint`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
		if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
		}
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -c -type joint $childJoint`;
		$childJoint="";
		for ($i=0;$i<size($tempString);$i++)
			{
			if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
			if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
			}
		}
	//Then see if it`s the lastTwister
	int $stringLenght=`size $skinCurve`;
	int $twistNr=`substring $skinCurve $stringLenght $stringLenght`;
	string $nextTwistProfile=`substring $skinCurve 1 ($stringLenght-1)`+($twistNr+1);
	if (!`objExists $nextTwistProfile`)
		{
		$info[0]=$childJoint;
		$info[1]="start";
		}
	}
//[2]=restoreWeightsToJoint
if (`gmatch $skinCurve "*_twistProfile1"`)
	{
	tokenize $skinCurve "_" $tempString;
	string $twistJoint=$tempString[0]+"Part1_"+$tempString[1];
	if (`objExists $twistJoint`)
		$info[2]=$twistJoint;
	else
		$info[2]=$info[0];
	}
else
	{
	$tempString=`listRelatives -p $info[0]`;
	if (`gmatch $skinCurve "*_endProfile"`)
		$info[2]=$info[0];
	else
		$info[2]=$tempString[0];
	}
return $info;
}

global proc asCreateMoCap ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
if (`objExists "MoCap"`)
	error "MoCap skeleton already exists !";
if (!`objExists "Main"`)
	error "No AdvancedSKeleton In Scene!";
string $deformJoints[]=`listRelatives -type joint -ad "DeformationSystem"`;
string $keyDeformJoints[],$tempString[],$parent[],$names[],$extra[];
string $extr;
for ($a=$i=0;$a<size($deformJoints);$a++)
	{
	if (`gmatch $deformJoints[$a] "*_50"`)
		continue;
	if (`gmatch $deformJoints[$a] "*Slider[0-9]*"`)
		continue;
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $deformJoints[$a]`)
			continue;
	tokenize $deformJoints[$a] "_" $tempString;
	$extr="FKExtra"+$tempString[0]+"_"+$tempString[1];
	if (`gmatch $deformJoints[$a] "*Part[0-9]*"`)
		continue;
	$keyDeformJoints[$i]=$deformJoints[$a];
	$extra[$i]=$extr;
	$tempString[0]=$keyDeformJoints[$i];
	for ($y=0;$y<99;$y++)
		{
		$tempString=`listRelatives -p $tempString[0]`;
		if (!`gmatch $tempString[0] "*Part[0-9]*"`)
			{
			tokenize $tempString[0] "_" $tempString;
			$parent[$i]=$tempString[0]+"_MoCap_"+$tempString[1];
			break;
			}
		}
	tokenize $keyDeformJoints[$i] "_" $tempString;
	string $name=$tempString[0]+"_MoCap_"+$tempString[1];
	if (!`stringArrayCount $name $names`)
		{
		$names[$i]=$name;
		$i++;
		}
	}

string $topJoint;
for ($i=0;$i<size($names);$i++)
	{
	select -cl;
	joint -n $names[$i];
	if ($i==size($names)-1)
		{
		createNode -n "MoCap" transform;
		createNode -n "CenterOffset" transform;
		asAlign "CenterOffset" RootExtraX_M 1 0 0 0;
		parent "MoCap" "Group";
		parent "CenterOffset" "MoCap";
		parent $names[$i] "CenterOffset";
		connectAttr ($names[$i]+".translate") ("RootExtraX_M.translate");
		$topJoint=$names[$i];
		}
	asAlign $names[$i] $keyDeformJoints[$i] 1 1 1 0;
	setAttr ($names[$i]+".rotateOrder") 1;
	if (`objExists $extra[$i]`)
		setAttr ($extra[$i]+".rotateOrder") 1;
	}

for ($i=0;$i<size($names);$i++)
	{
	if (`objExists $parent[$i]`)
		parent $names[$i] $parent[$i];
	}
for ($i=0;$i<size($names);$i++)
	{
	if (`objExists ($names[$i]+"_blendColor")`)
		delete ($names[$i]+"_blendColor");
	createNode -n ($names[$i]+"_blendColor") blendColors;
	connectAttr ($names[$i]+".rotate") ($names[$i]+"_blendColor.color1");
	addAttr -k 1 -ln "blend" -at double -min 0 -max 1 -dv 1 $names[$i];
	connectAttr ($names[$i]+".blend") ($names[$i]+"_blendColor.blender");
	if (`objExists $extra[$i]`)
		connectAttr ($names[$i]+"_blendColor.output") ($extra[$i]+".rotate");
	}
setAttr "MoCap.translateZ" ($charHeight/-3);
//orientConstraint -mo $topJoint "RootExtraX_M";
select $sel;
}

global proc asSetAllFK ()
{
string $controlSetMembers[]=`sets -q ControlSet`;
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".FKIKBlend") 0;
if (`objExists HipSwinger_M`)
	if (`attributeExists stabilize HipSwinger_M`)
		setAttr "HipSwinger_M.stabilize" 0;
}

global proc float asGetSceneFps () 
{
float $fps;
string $fpsName=`currentUnit -q -time`;
if ($fpsName=="game") $fps=15;
if ($fpsName=="film") $fps=24;
if ($fpsName=="pal") $fps=25;
if ($fpsName=="ntsc") $fps=30;
if ($fpsName=="show") $fps=48;
if ($fpsName=="palf") $fps=50;
if ($fpsName=="ntscf") $fps=60;
if ($fpsName=="millisec") $fps=1000;
if ($fpsName=="sec") $fps=1;
if ($fpsName=="min") $fps=0.0166667;
if ($fpsName=="hour") $fps=0.000277778;
if (`gmatch $fpsName "*fps"`)
	$fps=`substitute "fps" $fpsName ""`;
return $fps;
}

global proc asReadBVH ()
{
global string $gMainProgressBar;
string $filename=`fileDialog -dm "*.bvh"`;
if (!`file -q -ex $filename`)
	return;

if (!`objExists bvhFile`)
	createNode -n bvhFile transform;

select -cl;
string $topNodesBefore[]=`ls -as`;

int $i=-1;
int $x,$lineNum,$frameNr,$motionBegin,$motionHasBegun;
int $jointNum,$chNum;
int $numChannels[];
float $offsetX,$offsetY,$offsetZ,$value;
float $rot[];
$fileId=`fopen $filename "r"`;
string $nextLine = `fgetline $fileId`;
while ( size( $nextLine ) > 0 )
	{
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionBegin)
		$lineNum++;
	$nextLine = `fgetline $fileId`;
	}
$motionBegin=0;
fclose $fileId;
$fileId=`fopen $filename "r"`;
$nextLine = `fgetline $fileId`;
string $joints[],$buffer[],$channels[],$localChannels[];
float $currentTime=`currentTime -q`;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
currentTime -e -20;

progressBar -e -st "AdvancedSkeleton" -bp -ii 1 -min 0 -max ($lineNum+1) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
while ( size( $nextLine ) > 0 )
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		fclose $fileId;
		}

	tokenize $nextLine $buffer;
	if (`gmatch $nextLine "*}*"`)
		pickWalk -d up;
	if (`gmatch $nextLine "*JOINT*"` || `gmatch $nextLine "*ROOT*"` || `gmatch $nextLine "*End Site*"`)
		{
		$i++;
		$joints[$i]=$buffer[1];
		if ($joints[$i]=="Site")
			$joints[$i]=$joints[$i]+$i;
		joint -n ("MoCap"+$joints[$i]);
		setAttr ("MoCap"+$joints[$i]+".rotateOrder") 2;
		if (`gmatch $nextLine "*JOINT*"`)
			setKeyframe ("MoCap"+$joints[$i]+".rotate");
		}
	if (`gmatch $nextLine "*OFFSET*"`)
		{
		$offsetX=$buffer[1];
		$offsetY=$buffer[2];
		$offsetZ=$buffer[3];
		setAttr -type float3 ("MoCap"+$joints[$i]+".translate") $offsetX $offsetY $offsetZ;
		}
	if (`gmatch $nextLine "*CHANNELS*"`)
		{
		$numChannels[$i]=$buffer[1];
		for ($x=2;$x<size($buffer);$x++)
			$channels[$i]=$channels[$i]+`asReWord $buffer[$x]`+";";
		}

	if ($motionBegin)
		$motionHasBegun=1;
	if (`gmatch $nextLine "Frame Time:*"`)
		$motionBegin=1;
	if ($motionHasBegun)
		{
		progressBar -e -s 1 $gMainProgressBar;
		$jointNum=0;
		tokenize $channels[$jointNum] ";" $localChannels;
		$chNum=-1;
		for ($y=0;$y<size($buffer);$y++)
			{
			$chNum++;
			if ($chNum>$numChannels[$jointNum]-1)
				{
				$jointNum++;
				if (`gmatch $joints[$jointNum] "Site*"`)
					$jointNum++;
				tokenize $channels[$jointNum] ";" $localChannels;
				$chNum=0;
				}
			$value=$buffer[$y];
//			currentTime -e ($frameNr+1);
			if (`gmatch $localChannels[$chNum] "*rotate*"`)
				{
				if ($localChannels[$chNum]=="rotateX")
					$rot[0]=$value;
				if ($localChannels[$chNum]=="rotateY")
					$rot[1]=$value;
				if ($localChannels[$chNum]=="rotateZ")
					$rot[2]=$value;
				if ($chNum==2 || $chNum==5)
					{
					asSetMoCapRot ("MoCap"+$joints[$jointNum]) $rot;
					setKeyframe -t $frameNr ("MoCap"+$joints[$jointNum]+".rotate");
					}
				}
			else
				setKeyframe -v $value -t $frameNr ("MoCap"+$joints[$jointNum]+"."+$localChannels[$chNum]);
			}
		$frameNr++;
		}
	$nextLine = `fgetline $fileId`;
	}
progressBar -e -ep $gMainProgressBar;
currentTime -e $currentTime;
autoKeyframe -state $autoKeyframe;
fclose $fileId;

string $topNodesAfter[]=`ls -as`;
string $moCapTopNode;
for ($i=0;$i<size($topNodesAfter);$i++)
	{
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		{
		$moCapTopNode=$topNodesAfter[$i];
		parent $moCapTopNode bvhFile;
		}
	}

//clean statics
string $bhvJoints[]=`listRelatives -ad -type joint bvhFile`;
select $bhvJoints;
delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1;

//Scale to match Root height
string $tempString[]=`listConnections -scn 1 ($moCapTopNode+".ty")`;
if ($tempString[0]!="")
	{
	$tyAnimCurve=$tempString[0];
	string $tempString[]=`listRelatives -c -type joint DeformationSystem`;
	string $root=$tempString[0];
	float $rootHeigh=`getAttr ($root+".ty")`;
	float $keyValues[]=`keyframe -in 0 -q -vc $tyAnimCurve`;
	float $scaleFactor=$rootHeigh/$keyValues[0];
	setAttr -type float3 bvhFile.s $scaleFactor $scaleFactor $scaleFactor;
	}
//Scale keys to match frameRate
float $bvhFps=`floatField -q -v asBVHfps`;
float $sceneFps=`asGetSceneFps`;
float $scaleTime=$sceneFps/$bvhFps;
string $animCurves[];
select -cl;
for ($i=0;$i<size($bhvJoints);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -scn 1 -type animCurve $bhvJoints[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		selectKey -add -k -t "0:99999" $animCurves[$y];
	}
scaleKey -iub false -ts $scaleTime -tp 0 -fs $scaleTime -fp 0 -vs 1 -vp 0 -animation keys ;

playbackOptions -min 0 -ast 0 -max ($frameNr*$scaleTime) -aet ($frameNr*$scaleTime);
currentTime 0;

select -cl;
}

global proc asDeleteMocap ()
{
if (`objExists MoCap`)
	delete MoCap;
delete `ls -type blendColors "*_MoCap_*_blendColor"`;
}

global proc asDeleteBHV ()
{
if (`objExists bvhFile`)
	delete bvhFile;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asAutoMapMocap ()
{
float $charHeight=`asgetCharHeight`;
string $tempString[]=`listRelatives -c -type joint bvhFile`;
string $bvhTopJoint=$tempString[0];
$tempString=`listRelatives -c -type joint CenterOffset`;
string $moCapTopJoint=$tempString[0];
$tempString=`pointConstraint $bvhTopJoint $moCapTopJoint`;
setAttr ($tempString[0]+".offsetZ") ($charHeight/3);

catch (`orientConstraint -mo $bvhTopJoint $moCapTopJoint`);

catch (`orientConstraint -mo MoCapRightUpLeg Hip_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftUpLeg Hip_MoCap_L`);
catch (`orientConstraint -mo MoCapRightLeg Knee_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftLeg Knee_MoCap_L`);
catch (`orientConstraint -mo MoCapRightFoot Ankle_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftFoot Ankle_MoCap_L`);
catch (`orientConstraint -mo MoCapRightToeBase Toes_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftToeBase Toes_MoCap_L`);

catch (`orientConstraint -mo MoCapLowerBack Root_MoCap_M`);
catch (`orientConstraint -mo MoCapSpine Spine1_MoCap_M`);
catch (`orientConstraint -mo MoCapSpine1 Chest_MoCap_M`);
catch (`orientConstraint -mo MoCapRightShoulder Scapula_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftShoulder Scapula_MoCap_L`);
catch (`orientConstraint -mo MoCapRightArm Shoulder_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftArm Shoulder_MoCap_L`);
catch (`orientConstraint -mo MoCapRightForeArm Elbow_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftForeArm Elbow_MoCap_L`);
catch (`orientConstraint -mo MoCapRightHand Wrist_MoCap_R`);
catch (`orientConstraint -mo MoCapLeftHand Wrist_MoCap_L`);

catch (`orientConstraint -mo MoCapRThumb ThumbFinger2_MoCap_R`);
catch (`orientConstraint -mo MoCapLThumb ThumbFinger2_MoCap_L`);

catch (`orientConstraint -mo MoCapNeck1 Neck_MoCap_M`);
catch (`orientConstraint -mo MoCapHead Head_MoCap_M`);
}

global proc asDeleteMocapMap ()
{
delete `listRelatives -ad -type constraint MoCap`;
string $mocapJoints[]=`listRelatives -ad -type joint MoCap`;
for ($i=0;$i<size($mocapJoints);$i++)
	setAttr -type float3 ($mocapJoints[$i]+".r") 0 0 0;
}

global proc asSetMoCapRot (string $obj, float $rot[])
{
setAttr -type float3 ($obj+".rotate") 0 0 0;
float $rotX=$rot[0];
float $rotY=$rot[1];
float $rotZ=$rot[2];
rotate -r -os 0 0 $rotZ $obj;
rotate -r -os $rotX 0 0 $obj;
rotate -r -os 0 $rotY 0 $obj;
}

global proc string asReWord (string $bvhWord)
{
if ($bvhWord=="Xposition")
	return "translateX";
if ($bvhWord=="Yposition")
	return "translateY";
if ($bvhWord=="Zposition")
	return "translateZ";
if ($bvhWord=="Xrotation")
	return "rotateX";
if ($bvhWord=="Yrotation")
	return "rotateY";
if ($bvhWord=="Zrotation")
	return "rotateZ";
return "";
}

global proc asCreatePartialJoints ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $dialog=`confirmDialog -t "Confirm"
	-m "Create Partial Joints for all deformJoints ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "DeformSet"`)
	return;

float $charHeight=`asgetCharHeight`;
int $sideFactor;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $children[],$partialJoints[],$zero[],$parents[],$buffer[],$tempString[];
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$children=`listRelatives -type joint -c $deformJointsList[$i]`;
	$parents=`listRelatives -type joint -p $deformJointsList[$i]`;
	if (!size($children) || !size($parents) || `gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	select $deformJointsList[$i];
	tokenize $deformJointsList[$i] "_" $buffer;
	$partialJoints[$i]=$buffer[0]+"50_"+$buffer[1];
	$partialJoints[$i]=$buffer[0]+"_"+$buffer[1]+"_50";
	$zero[$i]=$buffer[0]+"_"+$buffer[1]+"_00";
	if (`objExists $partialJoints[$i]`)
		error ("PartialJoints already exists");
	joint -n $partialJoints[$i];
	parent $partialJoints[$i] $parents[0];
	setAttr ($partialJoints[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $partialJoints[$i];
	sets -add "DeformSet" $partialJoints[$i];
	select $parents[0];
	createNode -n $zero[$i] transform;
	parent $zero[$i] $parents[0];
	setAttr -type float3 ($zero[$i]+".t") 0 0 0;
	setAttr -type float3 ($zero[$i]+".r") 0 0 0;
	setAttr ($zero[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $zero[$i];
	$tempString=`orientConstraint $zero[$i] $deformJointsList[$i] $partialJoints[$i]`;
	$tempString=`pointConstraint $deformJointsList[$i] $partialJoints[$i]`;
	setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
	}
select -cl;
for ($i=0;$i<size($deformJointsList);$i++)
	if (`gmatch $partialJoints[$i] "*_?_50"`)
		select -add $partialJoints[$i];
}

global proc asDeletePartialJoints ()
{
if (!`objExists "DeformSet"`)
	return;

string $DeformationSystemNodes[]=`listRelatives -ad "DeformationSystem"`;
for ($i=0;$i<size($DeformationSystemNodes);$i++)
	if (`attributeExists partialJoint $DeformationSystemNodes[$i]`)
		delete $DeformationSystemNodes[$i];
}

global proc asPopulateDrivingSystemsPopupMenu (string $action)
{
string $popupMenu="as"+$action+"DrivingSystemsPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
int $numKeys,$delete;
if ($action=="Delete") $delete=1;
float $keyValues[];
string $cmd,$animCurve;
string $drivingSystems[],$tempString[],$attrs[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	if (`gmatch $drivingSystems[$i] "*_L"`)
		continue;
	//$menu1s
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph") $sm=0;
	$lev1Menu=`menuItem -sm $sm -l $drivingSystems[$i]`;
	if ($action=="Graph")
		{
		string $udAttrs[]=`listAttr -ud $drivingSystems[$i]`;
		$cmd="select ";
		for ($attr in $udAttrs)
			{
			$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$attr)`;
			for ($node in $tempString)
				$cmd+=$node+" ";
			}
		$cmd+=";GraphEditor;";
		menuItem -e -c $cmd $lev1Menu;
		continue;
		}

	//$menu2s
	$attrs=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		setParent -menu $lev1Menu;
		$lev2Menu=`menuItem -sm $sm -l $attrs[$y]`;
	
		//$menu3s
		$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$attrs[$y])`;
		$animCurve=$tempString[0];
		$numKeys=`keyframe -q -keyframeCount $animCurve`;
		for ($x=0;$x<$numKeys;$x++)
			{
			$keyValues=`keyframe -in $x -q -fc $animCurve`;
			$keyValues[0]=`asRoundOff $keyValues[0] 3`;
			if($keyValues[0]==0)
				continue;
			$cmd="asEditDrivingSystem "+$delete+" "+$drivingSystems[$i]+" "+$attrs[$y]+" "+$keyValues[0];
			setParent -menu $lev2Menu;
			$lev3Menu=`menuItem -sm 0 -l $keyValues[0] -c $cmd`;
			}
		}
	}
}

global proc asAutoFindAndEditDrivingSystem ()
{
string $drivingSystems[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
string $drivingSystem="";
string $driveAttr="";
float $driveValue=0;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	string $udAttrs[]=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($udAttrs);$y++)
		{
		float $value=`getAttr ($drivingSystems[$i]+"."+$udAttrs[$y])`;
		$value=`asRoundOff $value 3`;
		if ($value!=0)
			{
			if ($drivingSystem!="")
				error ("Found multiple driver values set: "+$drivingSystem+"."+$driveAttr+" AND "+$drivingSystems[$i]+"."+$udAttrs[$y]);
			$drivingSystem=$drivingSystems[$i];
			$driveAttr=$udAttrs[$y];
			$driveValue=$value;
			}
		}
	}
if ($drivingSystem=="")
	warning "Either right click on this button to edit specific drive-values, or set a driver-value, and click the button";
else
	asEditDrivingSystem 0 $drivingSystem $driveAttr $driveValue;
}

global proc asEditDrivingSystem (int $delete, string $obj, string $attr, float $value)
{
int $numDriven;
float $drivenValues[];
string $stripName;
string $drivenObjs[],$drivenAttrs[],$drivenSdkNode[];
string $tempString2[];
string $tempString[]=`listConnections -scn 1 ($obj+"."+$attr)`;
setAttr ($obj+"."+$attr) $value;
for ($i=0;$i<size($tempString);$i++)
	if (size(`ls -type animCurve $tempString[$i]`))	
		{
		tokenize $tempString[$i] "_" $tempString2;
		$drivenSdkNode[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+"_";
			}
		$stripName=`substring $tempString[$i] 5 99`;
		if (`gmatch $stripName "[0-9]*"`)
			$stripName=`substring $stripName 2 99`;
		tokenize $stripName "_" $tempString2;
		$drivenObjs[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+"_";
			}
		string $drivenAttr=$tempString2[size($tempString2)-1];
		if (`gmatch $drivenAttr "*[0-9]"`)
			{
			int $numChars=size($drivenAttr);
			$drivenAttr=`substring $drivenAttr 1 ($numChars-1)`;
			}
		$drivenAttrs[$numDriven]=$drivenAttr;
		$drivenValues[$numDriven]=`getAttr ($drivenSdkNode[$numDriven]+"."+$drivenAttrs[$numDriven])`;
		$numDriven++;
		}

asGoToBuildPose bodySetup;

if ($delete)
	{
	//remove entry in buildPose
	string $buildPoseCmd=`getAttr buildPose.udAttr`;
	tokenize $buildPoseCmd ";" $tempString;
	string $newBuildPoseCmd="";
	for ($i=0;$i<size($tempString);$i++)
		if (!`gmatch $tempString[$i] ("setAttr "+$obj+"."+$attr+"*")`)
			$newBuildPoseCmd+=$tempString[$i]+";";
	setAttr -type "string" buildPose.udAttr $newBuildPoseCmd;
	//remove associated SdkXforms (that dont have another drivers driving them as well)
	$tempString=`listConnections -scn 1 -s 0 -d 1 ($obj+"."+$attr)`;
	for ($i=0;$i<size($tempString);$i++)
		if (size(`ls -type animCurve $tempString[$i]`))
			{
			$tempString2=`listConnections -scn 1 -s 0 -d 1 ($tempString[$i]+".output")`;
			$SdkXform=$tempString2[0];
			$tempString2=`listConnections -scn 1 -s 1 -d 0 $SdkXform`;
			if(size($tempString2)==1)
				{
				parent `listRelatives -c $SdkXform` `listRelatives -p $SdkXform`;
				delete $SdkXform;
				}
			}
	//remove attr
	deleteAttr ($obj+"."+$attr);
	//remove controller if there`s no attributes left
	$tempString=`listAttr -ud $obj`;
	if (!size($tempString))
		delete $obj;
	return;
	}

for ($i=0;$i<size($drivenObjs);$i++)
	setAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i]) $drivenValues[$i];
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
headsUpDisplay -s 2 -b 0 -bs "medium" -l ("Editing Driving System:  "+$obj+"."+$attr+"="+$value) -lfs "large" HUDEDSMode;
rowLayout -e -en 1 asDSEditChoicesRowLayout;

//select one of the drivenControls, to hint what to modify
select $drivenObjs;
}

global proc asDrivingSystemEditCancel ()
{
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
rowLayout -e -en 0 asDSEditChoicesRowLayout;
asGoToBuildPose bodySetup;
}

global proc asDrivingSystemEditApply ()
{
asCreateDrivingSystem;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
rowLayout -e -en 0 asDSEditChoicesRowLayout;
}

global proc asCreateDrivingSystemLayout ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global string $asDSAltPivot;
global int $asDSAdvancedOptions;
string $tempString[];
tokenize $asDSMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asDSMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asDSMessage+=$tempString[$i]+"\n";
	$asDSMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout -adj 0;
columnLayout -adj 0;
	text -l $asDSMessage;
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 1 asDSInputsColumnLayout;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 asDSAttrNameTextField;
		setParent..;
	rowLayout -nc 3 asDSControlNameRowLayout;
		text -w 100 -l "Control Name:";
		textField -w 80 asDSObjNameTextField;
		setParent..;
	rowLayout -en 0 -nc 4 asDSUseControlRowLayout; 
	    separator -w 5 -st none;
	    checkBox -w 95 -l "Use Control:"
	    	-onc "optionMenu -e -en 1 asDSObjNameOptionMenu;rowLayout -e -en 0 asDSControlNameRowLayout;checkBox -e -en 0 asDSMirrorCheckBox;"
	    	-ofc "optionMenu -e -en 0 asDSObjNameOptionMenu;rowLayout -e -en 1 asDSControlNameRowLayout;checkBox -e -en 1 asDSMirrorCheckBox;"
	    	asDSUseControlCheckBox;
    	optionMenu -en 0 asDSObjNameOptionMenu;
		setParent..;
	if ($asDSAdvancedOptions)
		{
		separator;
		text -l "Attribute limits:";
		rowLayout -en 1 -nc 8;
			checkBox -w 40 -v 1 -l "min:" asDSAttrHasMin;
			floatField -w 30 -v 0 -pre 1 asDSAttrMin;
			separator -w 10 -st none;
			checkBox -w 40 -v 1 -l "max:" asDSAttrHasMax;
			floatField -w 30 -v 10 -pre 1 asDSAttrMax;
			setParent..;
		separator -h 5 -st none;
		checkBox -l "Use Soft limits" -v 1 asDSAttrSoftLimits;
		}
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 0;
	rowLayout -nc 3 asDSMirrorRowLayout;
			text -w 100 -l "Mirror:";
    	checkBox -l "" -v 1 asDSMirrorCheckBox;
		setParent..;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asCreateDrivingSystemGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;

//populate asDSObjNameOptionMenu
string $drivingSystems[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
if (size($drivingSystems))
	rowLayout -e -en 1 asDSUseControlRowLayout;
setParent -menu asDSObjNameOptionMenu;

//This proc also used by CreateNewBlendShape, then $drivingSystems are actuall faceCtrls
if ($asDSMessage=="Create New BlendShape")
	{
	clear $drivingSystems;
	if (`objExists ctrlBox`)
		{
		$tempString=`listRelatives -c -type transform ctrlBox`;
		for ($i=0;$i<size($tempString);$i++)
			$drivingSystems[$i]=`substitute "Box" $tempString[$i] ""`;
		}
	}

for ($i=0;$i<size($drivingSystems);$i++)
	{
	if (`gmatch $drivingSystems[$i] "*_L"`)
		continue;
	menuItem -l $drivingSystems[$i];
	}

//fill out fields if we are editing
if ($asDSObjName!="")
	{
	textField -e -ed 0 -tx $asDSAttrName asDSAttrNameTextField;
	rowLayout -e -en 0 asDSControlNameRowLayout;
	checkBox -e -en 1 -v 1 asDSUseControlCheckBox;
	optionMenu -e -en 1 -v $asDSObjName asDSObjNameOptionMenu;
	columnLayout -e -m 0 asDSInputsColumnLayout;

	string $oppositeObjName="";
	if (`gmatch $asDSObjName "*_R"`) $oppositeObjName=`substitute "_R" $asDSObjName "_L"`;
	if (`gmatch $asDSObjName "*_L"`) $oppositeObjName=`substitute "_L" $asDSObjName "_R"`;
	if (!`objExists $oppositeObjName`)
		{
		checkBox -e -v 0 asDSMirrorCheckBox;
		rowLayout -e -en 0 asDSMirrorRowLayout;
		}
	}
}

global proc string asCreateSDKXform (string $drivenObj)
{
global string $asDSAltPivot;
string $tempString[]=`listRelatives -p $drivenObj`;
string $parent=$tempString[0];
string $child=$drivenObj;
int $isFace=0;
if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivenObj`)
		$isFace=1;

string $sdkXform;
if (`gmatch $parent "*Extra*"`)
	{
	$child=$parent;
	$tempString=`listRelatives -p $parent`;
	$parent=$tempString[0];
	}
for ($y=1;$y<99;$y++)
	{
	$sdkXform="SDK"+$y+$drivenObj;
	if (!`objExists $sdkXform`)
		break;
	}
createNode -n $sdkXform -p $parent transform;
sets -add AllSet $sdkXform;
setAttr ($sdkXform+".rotateOrder") `getAttr ($drivenObj+".rotateOrder")`;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1;

//$asDSAltPivot
// could be _R, but should be _L
if (`gmatch $drivenObj "*_L"` && `gmatch $asDSAltPivot "*_R"`)
	$asDSAltPivot=`substitute "_R" $asDSAltPivot "_L"`;
if ($asDSAltPivot!="" && `objExists $asDSAltPivot`)
	{
	createNode -n ($sdkXform+"AltPivotOffset1") transform;
	createNode -n ($sdkXform+"AltPivotOffset2") transform;
	sets -add AllSet ($sdkXform+"AltPivotOffset1") ($sdkXform+"AltPivotOffset2");
	asAlign ($sdkXform+"AltPivotOffset1") $asDSAltPivot 1 1 0 1;
	asAlign ($sdkXform+"AltPivotOffset2") $sdkXform 1 1 0 0;
	asAlign $sdkXform $asDSAltPivot 1 1 0 1;
	$tempString=`listRelatives -p $sdkXform`;
	parent ($sdkXform+"AltPivotOffset1") $tempString[0];
	parent $sdkXform ($sdkXform+"AltPivotOffset1");
	parent ($sdkXform+"AltPivotOffset2") $sdkXform;
	parent $child ($sdkXform+"AltPivotOffset2");
	}
else if (!$isFace)
	parent $child $sdkXform;

//connect Face $sdkXform
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
if ($isFace)
	{
	int $numChar=size($child);
	string $fitJoint=`substring $child 1 ($numChar-2)`;
	string $side=`substring $child ($numChar-1) 99`;
	string $destinaton=$fitJoint+"Joint"+$side;
	if (!`objExists $destinaton`)
		$destinaton=$fitJoint+"Cluster"+$side+"Handle";
	if (!`objExists ($fitJoint+"DSPlust"+$side)`)
		for ($y=0;$y<size($trs);$y++)
			{
			createNode -n ($fitJoint+"DSPlus"+$trs[$y]+$side) plusMinusAverage;
			connectAttr ($child+"."+$trs[$y]) ($fitJoint+"DSPlus"+$trs[$y]+$side+".input3D[0]");
			for ($z=0;$z<size($xyz);$z++)
				connectAttr -f ($fitJoint+"DSPlus"+$trs[$y]+$side+".output3D"+$xyz[$z]) ($destinaton+"."+$trs[$y]+$xyz[$z]);
			int $numExisting=`getAttr -s ($fitJoint+"DSPlus"+$trs[$y]+$side+".input3D")`;
			connectAttr ($sdkXform+"."+$trs[$y]) ($fitJoint+"DSPlus"+$trs[$y]+$side+".input3D["+$numExisting+"]");
			}
	}
return $sdkXform;
}

global proc asCreateDrivingSystemGetName ()
{
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global float $asDSAttrMin;
global float $asDSAttrMax;
global int $asDSMirror;
int $result;
$asDSAttrName=`textField -q -tx asDSAttrNameTextField`;
if (`rowLayout -q -en asDSControlNameRowLayout`)
	$asDSObjName=`textField -q -tx asDSObjNameTextField`;
else
	$asDSObjName=`optionMenu -q -v asDSObjNameOptionMenu`;
$asDSAttrHasMin=1;
$asDSAttrHasMax=1;
$asDSAttrSoftLimits=1;
$asDSAttrMin=0;
$asDSAttrMax=10;
if (`checkBox -q -ex asDSAttrHasMin`) $asDSAttrHasMin=`checkBox -q -v asDSAttrHasMin`;
if (`checkBox -q -ex asDSAttrHasMax`) $asDSAttrHasMax=`checkBox -q -v asDSAttrHasMax`;
if (`checkBox -q -ex asDSAttrSoftLimits`) $asDSAttrSoftLimits=`checkBox -q -v asDSAttrSoftLimits`;
if (`floatField -q -ex asDSAttrMin`) $asDSAttrMin=`floatField -q -v asDSAttrMin`;
if (`floatField -q -ex asDSAttrMax`) $asDSAttrMax=`floatField -q -v asDSAttrMax`;
$asDSMirror=`checkBox -q -v asDSMirrorCheckBox`;
}

global proc string[] asCreateDrivingSystem ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global string $asDSAltPivot;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global int $asDSMirror;
global int $asDSAdvancedOptions;
global int $asBuilding;
global int $asRebuilding;
global float $asDSAttrMin;
global float $asDSAttrMax;

if (!`objExists FitSkeleton`)
	error "FitSkeleton not found";

$asDSAdvancedOptions=0;
int $modifier=`getModifiers`;
if ($modifier==4)
	$asDSAdvancedOptions=1;
int $isFace=0;
string $sel[]=`ls -sl`;
string $sdkXforms[];

int $isEditing,$reusingSdkXform;
float $runValues[],$pos[],$drivenValues[];
float $poseValue,$currentValue,$maxDistAmoungDrivens,$minX,$maxX,$minY,$maxY,$minZ,$maxZ,$difX,$difY,$difZ,$controlScale,$min,$dist;
string $parent,$child,$obj,$drivenObj,$drivenAttr,$m,$controllerName,$sdkXform,$side,$oppositeSide;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$drivens[],$sdkDrivens[],$runObjAttrs[],$checkObjAttr[],$drivenObjs[],$buildPoseCmds[],$runCmds[];
string $existingSdkXforms[];
float $driverValue=10;
float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;

//Do we come from AdvancedSkeleton BUILD Mode ?
int $comeFromASBuild=0;
if ($asBuilding || $asRebuilding)
	$comeFromASBuild=1;
else
	{
	$asDSObjName="";
	$asDSAttrName="";
	}

//Do we come from EditDrivingSystemMode ?
int $comeFromEDSMode=0;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	$tempString[0]=`headsUpDisplay -q -l HUDEDSMode`;
	tokenize $tempString[0] "[:]" $tempString;
	$tempString[1]=`strip $tempString[1]`;
	tokenize $tempString[1] "=" $tempString;
	$driverValue=$tempString[1];
	tokenize $tempString[0] "[.]" $tempString;
	$asDSObjName=$tempString[0];
	$asDSAttrName=$tempString[1];
	$comeFromEDSMode=1;
	}

//Find driven attribute(s)
//get $buildPoseCmds
$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}

for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<size($buildPoseCmds);$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
	{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			tokenize $objAttr "." $tempString3;
			$obj=$tempString3[0];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;

			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				{
				$tempString2=`listRelatives -p $obj`;
				if ($tempString2[0]=="DrivingSystem")
					error ("Found \""+$checkObjAttr[$z]+"\", which is a DrivingSystem attribute. To modify this right>click on the \"Edit\" button");
				else
					{
					//Creating new DrivingSystem
					$drivens[size($drivens)]=$checkObjAttr[$z];
					if (!`stringArrayCount $obj $drivenObjs`)
						$drivenObjs[size($drivenObjs)]=$obj;
					}
				if (`gmatch $checkObjAttr[$z] "*_L*[.]*"`)
					error ("Found modified values on the Left side ("+$checkObjAttr[$z]+"), Only modify Right side (or middle)");
				}
			}
		}
	}
if (size($drivens)==0)
	error ("Found no driven attributes, all controls are in Build-Pose");

string $buildPoseNode="buildPose";
if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivenObjs[0]`)
		{
		$isFace=1;
		$buildPoseNode="faceBuildPose";
		}

if ($comeFromEDSMode)
	{
	$isEditing=1;
	$m="Edit:  "+$asDSObjName+"."+$asDSAttrName+"="+$driverValue+"\n\n";
	for ($i=0;$i<size($drivens);$i++)
		{
		float $value=`getAttr $drivens[$i]`;
		$value=`asRoundOff $value 3`;
		$m+=$drivens[$i]+" = "+$value+"\n";	
		}
	}
else
	{
	$m="Create system to drive these attributes?\n\n";
	for ($i=0;$i<size($drivens);$i++)
		{
		float $value=`getAttr $drivens[$i]`;
		$value=`asRoundOff $value 3`;
		$m+=$drivens[$i]+" = "+$value+"\n";
		}
	}

$asDSMessage=$m;

if (!$comeFromASBuild)
	{
	string $dialogResult=`layoutDialog -t "Confirm" -ui asCreateDrivingSystemLayout`;
	if ($dialogResult!="OK")
		return {""};
	}

$side="_M";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	if (`gmatch $drivenObjs[$i] "*_R"`) $side="_R";
	if (`gmatch $drivenObjs[$i] "*_L"`) $side="_L";
	if ($side!="_M") break;
	}
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1 && !$asDSMirror)
		continue;
	if ($b==-1 && $side=="_M")
		continue;
	if      ($b==-1 && $side=="_R") {$side="_L";$oppositeSide="_R";}
	else if ($b==-1 && $side=="_L") {$side="_R";$oppositeSide="_L";}
	for ($i=0;$i<size($drivenObjs);$i++)
		if ($b==-1)
			$drivenObjs[$i]=`substitute $oppositeSide $drivenObjs[$i] $side`;
	for ($i=0;$i<size($drivens);$i++)
		if ($b==-1)
			$drivens[$i]=`substitute $oppositeSide $drivens[$i] $side`;

	string $controllerName=$asDSObjName;
	if (!`gmatch $controllerName "*_[A-Z]"`)
		$controllerName+=$side;
	if ($asDSObjName=="")
		for ($y=1;$y<99;$y++)
			{
			$controllerName="DrivingSystem"+$y+$side;
			if (!`objExists $controllerName`)
				break;
			}
	string $attrName=$asDSAttrName;
	if ($attrName=="")
		for ($y=1;$y<99;$y++)
			{
			$attrName="driver"+$y;
			if (!`attributeExists $attrName $controllerName`)
				break;
			}


//	if ($b==-1){$side=$oppositeSide;if ($side=="_R") $oppositeSide="_L";if ($side=="_L") $oppositeSide="_R";}
	if (`objExists $controllerName`) //use-existing-Control
		{
//		$controllerName=$asDSObjName;
		if ($b==-1) $controllerName=`substitute $oppositeSide $controllerName $side`;
		}
	else
		asCreateDrivingSystemController $controllerName $drivenObjs;

	if (!`attributeExists $attrName $controllerName`)
		{
		addAttr -k 1 -ln $attrName -at double $controllerName;
		if ($asDSAttrHasMin && $asDSAttrSoftLimits)
			addAttr -e -ln "test2" -hasSoftMinValue 1 -softMinValue $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMin && !$asDSAttrSoftLimits)
			addAttr -e -ln "test2" -min $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && $asDSAttrSoftLimits)
			addAttr -e -ln "test2" -hasSoftMaxValue 1 -softMaxValue $asDSAttrMax ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && !$asDSAttrSoftLimits)
			addAttr -e -ln "test2" -max $asDSAttrMax ($controllerName+"."+$attrName);
		}
	else
		{
		if ($driverValue<0)
			addAttr -e -softMinValue $driverValue ($controllerName+"."+$attrName);
		else if ($driverValue>10)
			addAttr -e -softMaxValue $driverValue ($controllerName+"."+$attrName);
		}

	for ($i=0;$i<size($drivens);$i++)
		{
		tokenize $drivens[$i] "[.]" $tempString;
		$drivenAttr=$tempString[1];
		$reusingSdkXform=0;
		if ($drivenObj!=$tempString[0])//first attr in new obj
			{
			$drivenObj=$tempString[0];
			
			//See if there is a existing SDKXfrom for this driver/target combo
			$existingSdkXforms=`ls ("SDK*"+$drivenObj)`;
			for ($y=0;$y<size($existingSdkXforms);$y++)
				{
				$tempString2=`listConnections -scn 1 -s 1 -d 0 $existingSdkXforms[$y]`;
				for ($z=0;$z<size($tempString2);$z++)
					{
					$tempString3=`listConnections -scn 1 -s 1 -d 0 -p 1 $tempString2[$z]`;
					for ($a=0;$a<size($tempString3);$a++)
						if ($tempString3[$a]==$controllerName+"."+$attrName)
							{
							$sdkXform=$existingSdkXforms[$y];
							$reusingSdkXform=1;
							}
					}
				}
			if (!$reusingSdkXform)
				$sdkXform=`asCreateSDKXform $drivenObj`;
			$sdkDrivens[$i]=$sdkXform+"."+$drivenAttr;
			}
		$sdkDrivens[$i]=$sdkXform+"."+$drivenAttr;
		$sdkXforms[size($sdkXforms)]=$sdkXform;
		}
	
	if ($b==1)
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;

	if ($b==-1)	//use asMirror to get mirrorValues
		{
		string $restorePoseCmd=`asGetRestorePoseCmd`;
		if (`window -q -ex tempWindow`)
			deleteUI tempWindow;
		window tempWindow;
		columnLayout;
		optionMenu tempWindowOptionMenu;
			menuItem -l ":";
		text -l "ControlSet " tempWindowControlSetsText;
		optionVar -sv asMOSide "asMOSideR2L";
		optionVar -sv asMOSpace "asMOSpaceMain";
		optionVar -sv asMOAxis "asMOAxisX";
		optionVar -sv asMOSelOnly "asMOSelOnlyAll";
		if ($isFace)
			text -e -l "FaceControlSet " tempWindowControlSetsText;
		asMirror tempWindow;
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;
		deleteUI tempWindow;
		eval($restorePoseCmd);
		}

	for ($i=0;$i<size($sdkDrivens);$i++)
		setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValues[$i] -dv $driverValue -cd ($controllerName+"."+$attrName) $sdkDrivens[$i];
	string $restorePoseCmd=`asGetRestorePoseCmd`;
	if ($isFace)
		asGoToBuildPose faceSetup;
	else
		asGoToBuildPose bodySetup;
	for ($i=0;$i<size($sdkDrivens);$i++)
		setDrivenKeyframe -itt "linear" -ott "linear" -v `getAttr $drivens[$i]` -dv 0 -cd ($controllerName+"."+$attrName) $sdkDrivens[$i];
	for ($i=0;$i<size($sdkDrivens);$i++)
		setInfinity -pri cycleRelative -poi cycleRelative $sdkDrivens[$i];
	eval($restorePoseCmd);
	if (!$isEditing)
		setAttr -type "string" ($buildPoseNode+".udAttr") (`getAttr ($buildPoseNode+".udAttr")`+";setAttr "+$controllerName+"."+$attrName+" 0;");
	//AltPivot attribute
	for ($i=0;$i<size($sdkDrivens);$i++)
		{
		if ($asDSAltPivot=="")
			continue;
		$tempString=`listConnections $sdkDrivens[$i]`;
		addAttr -ln altPivot -dt "string" $tempString[0];
		setAttr -type "string" ($tempString[0]+".altPivot") $asDSAltPivot;
		}
	}
select -cl;
if ($isFace)
	asGoToBuildPose faceSetup;
else
asGoToBuildPose bodySetup;
asOptimizeDrivingSystemControllers;
if (!$asBuilding && !$asRebuilding)
	asDrivingSystemToFitSkeleton;
return $sdkXforms;
}

global proc asOptimizeDrivingSystemControllers ()
{
string $sel[]=`ls -sl`;
int $numChar;
float $maxDist,$maxY;
float $pos[3],$pos2[3];
string $constraintTo,$deformJoint,$rlaChild,$endJoint;
string $tempString[],$animCurves[],$allDrivenObjs[],$allDrivenDeformJoints[],$longNames[],$parents[],$drivingSystems[];
createNode -n tempSamplerOffset transform;
createNode -n tempSampler -p tempSamplerOffset transform;

if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($a=0;$a<size($drivingSystems);$a++)
	{
	$tempString=`listConnections -s 1 -d 0 ($drivingSystems[$a]+".tx")`;
	if ($tempString[0]!="" && `objectType $tempString[0]`=="parentConstraint")
		delete $tempString[0];
//	if (`objExists ($drivingSystems[$a]+"_parentConstraint1")`)
//		delete ($drivingSystems[$a]+"_parentConstraint1");
	asLockAttr $drivingSystems[$a] 0 0 0 1;

	//Find common ancestors
	clear $allDrivenDeformJoints;
	clear $longNames;
	$animCurves=`listConnections -s 0 -d 1 -type animCurve $drivingSystems[$a]`;	
	for ($i=0;$i<size($animCurves);$i++)
		{
		tokenize $animCurves[$i] "_" $tempString;
		$numChar=`size $animCurves[$i]` - `size($tempString[size($tempString)-1])` - 1;
		$allDrivenObjs[$i]=`substring $animCurves[$i] 4 $numChar`;
		if (`gmatch $allDrivenObjs[$i] "[0-9]*"`)
			$allDrivenObjs[$i]=`substring $allDrivenObjs[$i] 2 99`;
		$deformJoint=$allDrivenObjs[$i];
		if (`gmatch $allDrivenObjs[$i] "FK*"`)
			$deformJoint=`substitute "FK" $allDrivenObjs[$i] ""`;
		if (!`stringArrayCount $deformJoint $allDrivenDeformJoints`)
			$allDrivenDeformJoints[size($allDrivenDeformJoints)]=$deformJoint;
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$tempString=`ls -l $allDrivenDeformJoints[$i]`;
		$longNames[$i]=$tempString[0];
		select $drivingSystems[$a];
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 1 0 $allDrivenDeformJoints[$i] $drivingSystems[$a];
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		tokenize $longNames[$i] "|" $parents;
		for ($y=size($parents)-2;$y>-1;$y--)
			{
			$numOthersHaveThisParent=0;
			for ($z=0;$z<size($longNames);$z++)
			if (`gmatch $longNames[$z] ("*|"+$parents[$y]+"|*")`)
				$numOthersHaveThisParent++;
			if ($numOthersHaveThisParent==size($longNames))
				{
				$constraintTo=$parents[$y];
				$i=999;$y=-999;$z=999;
				}
			}
		}

	delete `parentConstraint $drivingSystems[$a] tempSamplerOffset`;
	$pos=`xform -q -ws -t $constraintTo`;
	$maxDist=0;
	$maxY=0;
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$endJoint=$allDrivenDeformJoints[$i];
		$rlaChild=`asRlaChild $allDrivenDeformJoints[$i]`;
		if ($rlaChild!="")
			$endJoint=$rlaChild;
		$pos2=`xform -q -ws -t $endJoint`;
		float $mag=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		if ($mag>$maxDist)
			$maxDist=$mag;
		delete `pointConstraint $endJoint tempSampler`;
		float $yValue=`getAttr tempSampler.ty`;
		$yValue=`abs($yValue)`;
		if ($yValue>$maxY)
			$maxY=$yValue;
		if ($maxY<$maxDist/2.0) $maxY=$maxDist/2.0; // cap at half lenght
		}
	if ($maxDist<0.01) $maxDist=0.5;
	if ($maxY<0.01) $maxY=0.5;

	delete `pointConstraint $constraintTo $drivingSystems[$a]`;
	if (`objExists ($drivingSystems[$a]+"_aimConstraint1")`)
		delete ($drivingSystems[$a]+"_aimConstraint1");
	parentConstraint -mo $constraintTo $drivingSystems[$a];
	setAttr -type float3 ($drivingSystems[$a]+".s") ($maxDist*1.2) ($maxY*1.2) 1;
	asLockAttr $drivingSystems[$a] 1 1 1 1;
	}
if (`objExists tempSamplerOffset`)
	delete tempSamplerOffset;

select $sel;
}

global proc asCreateDrivingSystemController (string $objName, string $drivenObjs[])
{
int $isChildOfOtherDriven;
string $tempString[],$tempString2[];
string $constraintTo="Root_M";

$tempString=`circle -n $objName -c 0 0 0 -nr 0 0 1 -sw 180 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
$objName=$tempString[0];
scale -r -1 1 1 ($objName+".cv[0:10]");
sets -add AllSet $objName;
sets -add AllSet ($objName+"Shape");
sets -add ControlSet $objName;
setAttr ($objName+"Shape.overrideEnabled") 1;
setAttr ($objName+"Shape.overrideColor") 17;
if (!`objExists DrivingSystem`)
	{
	createNode -n DrivingSystem -p MotionSystem transform;
	connectAttr Main.drvSysVis DrivingSystem.v;
	sets -add AllSet DrivingSystem;
	}
parent $objName DrivingSystem;

string $deformJoint=$drivenObjs[0];
if (`gmatch $drivenObjs[0] "FK*"`)
$deformJoint=`substitute "FK" $drivenObjs[0] ""`;
if (`objExists $deformJoint`)
	$constraintTo=$deformJoint;
asAlign $objName $drivenObjs[0] 1 1 0 0;
string $rlaChild=`asRlaChild $deformJoint`;
if (`objExists $rlaChild`)
	{
	float $scale=`getAttr ($rlaChild+".tx")`;
	setAttr -type float3 ($objName+".s") $scale $scale $scale;
//	scale -r $scale $scale $scale ($objName+".cv[0:10]");
	}

string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
//if (`objExists ($objName+"_pointConstraint1")`)
//	delete ($objName+"_pointConstraint1");
if (`objExists $constraintTo`)
	parentConstraint -mo $constraintTo $objName;
eval($restorePoseCmd);
asLockAttr $objName 1 1 1 1;
}

global proc asCreateAngleAttrs (string $joint)
{
string $sel[]=`ls -sl`;
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
float $charHeight=`asgetCharHeight`;
int $sideFactor=1;
if (`gmatch $joint "*_L"`)
	$sideFactor=-1;
string $FKjoint=$joint;
if (`objExists ("FK"+$joint)`)
	$FKjoint="FK"+$joint;
string $XYZ[]={"X","Y","Z"};
string $xyz[]={"x","y","z"};
string $RGB[]={"R","G","B"};
string $posNegs[]={"Pos","Neg"};
for ($i=0;$i<size($XYZ);$i++)
	{
	addAttr -k 1 -ln ("angle"+$XYZ[$i]) -at double $joint;
	addAttr -k 0 -ln ("angle"+$XYZ[$i]) -at double $FKjoint;
	setAttr -e -channelBox true ("FK"+$joint+".angle"+$XYZ[$i]);
	connectAttr -f ($joint+".angle"+$XYZ[$i]) ($FKjoint+".angle"+$XYZ[$i]);
	}
if (!`objExists AngleSystem`)
	{
	createNode -n AngleSystem -p MotionSystem transform;
	setAttr AngleSystem.inheritsTransform 0;
	}

string $tempString[]=`listRelatives -p $joint`;
string $parent=$tempString[0];

createNode -n ($joint+"AngleSamplerBaseParent") -p AngleSystem transform;
createNode -n ($joint+"AngleSamplerBase") -p ($joint+"AngleSamplerBaseParent") transform;
pointConstraint $parent ($joint+"AngleSamplerBaseParent");
orientConstraint $parent ($joint+"AngleSamplerBaseParent");
delete `orientConstraint $joint ($joint+"AngleSamplerBase")`;
pointConstraint $joint ($joint+"AngleSamplerBase");

for ($i=1;$i<size($XYZ);$i++)
	for ($y=0;$y<size($posNegs);$y++)
		{
		string $loc=$joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y];
		spaceLocator -n $loc;
		parent $loc ($joint+"AngleSamplerBase");
		setAttr -type float3 ($loc+".t") 0 0 0;
		setAttr -type float3 ($loc+".r") 0 0 0;
		setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
		}
setAttr ($joint+"AngleSamplerYPos.tz") ($sideFactor*-1*0.7071104);
setAttr ($joint+"AngleSamplerYNeg.tz") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZPos.ty") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZNeg.ty") ($sideFactor*-1*0.7071104);

createNode -n ($joint+"AngleSamplerRotate") -p ($joint+"AngleSamplerBase") transform;
orientConstraint $joint ($joint+"AngleSamplerRotate");

string $loc=$joint+"AngleSamplerEnd";
spaceLocator -n $loc;
parent $loc ($joint+"AngleSamplerRotate");
setAttr -type float3 ($loc+".t") ($sideFactor*0.7071104) 0 0;
setAttr -type float3 ($loc+".r") 0 0 0;
setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);

for ($y=0;$y<size($posNegs);$y++)
	{
	createNode -n ($joint+"OneMinus"+$posNegs[$y]) plusMinusAverage;
	setAttr ($joint+"OneMinus"+$posNegs[$y]+".operation") 2;
	setAttr -type float3 ($joint+"OneMinus"+$posNegs[$y]+".input3D[0]") 1 1 1;
	}
//Y & Z
for ($i=1;$i<size($XYZ);$i++)
	{
	for ($y=0;$y<size($posNegs);$y++)
		{
		createNode -n ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]) distanceBetween;
		connectAttr -f ($joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y]+"Shape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point1");
		connectAttr -f ($joint+"AngleSamplerEndShape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point2");
		connectAttr -f ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".distance") ($joint+"OneMinus"+$posNegs[$y]+".input3D[1].input3D"+$xyz[$i]);
		}
	createNode -n ($joint+"AngleCondition"+$XYZ[$i]) condition;
	setAttr ($joint+"AngleCondition"+$XYZ[$i]+".operation") 2;
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".firstTerm");
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".secondTerm");
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".colorIfTrue"+$RGB[$i]);
	createNode -n ($joint+"AngleInverse"+$XYZ[$i]) unitConversion;
	setAttr ($joint+"AngleInverse"+$XYZ[$i]+".conversionFactor") -1;
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleInverse"+$XYZ[$i]+".input");
	connectAttr -f ($joint+"AngleInverse"+$XYZ[$i]+".output") ($joint+"AngleCondition"+$XYZ[$i]+".colorIfFalse"+$RGB[$i]);
	connectAttr -f ($joint+"AngleCondition"+$XYZ[$i]+".outColor.outColor"+$RGB[$i]) ($joint+".angle"+$XYZ[$i]);
	}
//X
createNode -n ($joint+"AngleXMultiplyDivide") multiplyDivide;
setAttr ($joint+"AngleXMultiplyDivide.operation") 2;
setAttr -type float3 ($joint+"AngleXMultiplyDivide.input2") 90 1 1;
if (`objExists ("TwistBalancer"+$joint)`) // tapping into existing twist system
	connectAttr -f ("TwistBalancer"+$joint+".rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
else // create twist deriver
	{
	select ($joint+"AngleSamplerBase");
	joint -n ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXUnTwistEnd");
	setAttr ($joint+"AngleXUnTwistEnd.tx") ($charHeight/12.0*$sideFactor);
	select ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXBalancer");
	orientConstraint -mo ($joint) ($joint+"AngleXBalancer");
	ikHandle -n ($joint+"AngleXUnTwistIK") -ns 2 -sol "ikRPsolver" -sj ($joint+"AngleXUnTwist") -ee ($joint+"AngleXUnTwistEnd");
	parent ($joint+"AngleXUnTwistIK") ($joint+"AngleSamplerBase");
	parentConstraint -mo $joint ($joint+"AngleXUnTwistIK");
	createNode -n ($joint+"AngleXUnTwistPoleVec") -p ($joint+"AngleSamplerBase") transform;
	poleVectorConstraint ($joint+"AngleXUnTwistPoleVec") ($joint+"AngleXUnTwistIK");
	connectAttr -f ($joint+"AngleXBalancer.rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
	}
connectAttr ($joint+"AngleXMultiplyDivide.output.outputX") ($joint+".angleX");

setAttr -l 1 ($joint+"AngleSamplerBaseParent.v") 0;
eval($restorePoseCmd);
select $sel;
}

global proc string asCreateBlendedAttribute (string $drivers[])
{
string $sel[]=`ls -sl`;
string $tempString[],$driverObjs[],$driverAttrs[];
string $attr,$setAnglesCmd;
for ($i=0;$i<size($drivers);$i++)
	{
	tokenize $drivers[$i] "[.]" $tempString;
	$driverObjs[$i]=$tempString[0];
	$driverAttrs[$i]=$tempString[1];
	$attr+=$driverAttrs[$i];
	if (`getAttr $drivers[$i]`>=0)
		$attr+="Pos";
	else
		$attr+="Neg";
	if ($i<size($drivers)-1)
		$attr+="_";

	$tempString[0]="FK"+`substitute "angle" $drivers[$i] "rotate"`;
	if (`objExists $tempString[0]`)
		$setAnglesCmd+="setAttr "+$tempString[0]+" "+`getAttr $tempString[0]`+";";
	}

createNode -n BlendedCorrectiveDriver transform;
addAttr -ln driverObj -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverObj $driverObjs[0];
addAttr -ln driverAttr -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverAttr $attr;

if (`attributeExists $attr $driverObjs[0]`)
	{
	select $sel;
	return $attr;
	}

addAttr -k 0 -ln $attr -at double $driverObjs[0];
setAttr -e -channelBox true ($driverObjs[0]+"."+$attr);
if (!`gmatch $driverObjs[0] "FK*"` && `objExists ("FK"+$driverObjs[0])`)
	{
	addAttr -k 0 -ln $attr -at double ("FK"+$driverObjs[0]);
	setAttr -e -channelBox true ("FK"+$driverObjs[0]+"."+$attr);
	connectAttr ($driverObjs[0]+"."+$attr) ("FK"+$driverObjs[0]+"."+$attr);
	}

string $mpd,$sr;
string $previousOutput=$driverObjs[0]+"."+$driverAttrs[0];
for ($i=1;$i<size($drivers);$i++)
	{
	$sr=$driverObjs[0]+$attr+"SetRange"+$i;
	$mpd=$driverObjs[0]+$attr+"MultiplyDivide"+$i;
	createNode -n $sr setRange;

	connectAttr -f $previousOutput ($sr+".valueX");
	connectAttr -f ($driverObjs[$i]+"."+$driverAttrs[$i]) ($sr+".valueY");
	setAttr -type float3 ($sr+".max") 1 1 1;
	setAttr ($sr+".oldMaxX") `getAttr ($sr+".valueX")`;
	setAttr ($sr+".oldMaxY") `getAttr ($sr+".valueY")`;
	addAttr -k 1 -ln dvX -at double -dv `getAttr ($sr+".valueX")` $sr;
	addAttr -k 1 -ln dvY -at double -dv `getAttr ($sr+".valueY")` $sr;

	createNode -n $mpd multiplyDivide;
	connectAttr ($sr+".outValueX") ($mpd+".input1.input1X");
	connectAttr ($sr+".outValueY") ($mpd+".input2.input2X");
	if (`getAttr ($sr+".valueX")`<0)	//reverse negative numbers X
		{
		setAttr ($sr+".minX") 1;
		setAttr ($sr+".maxX") 0;
		setAttr ($sr+".oldMinX") (`getAttr ($sr+".oldMaxX")`);
		setAttr ($sr+".oldMaxX") 0;
		}
	if (`getAttr ($sr+".valueY")`<0)	//reverse negative numbers Y
		{
		setAttr ($sr+".minY") 1;
		setAttr ($sr+".maxY") 0;
		setAttr ($sr+".oldMinY") (`getAttr ($sr+".oldMaxY")`);
		setAttr ($sr+".oldMaxY") 0;
		}
	if ($i==(size($drivers))-1)
		{
		addAttr -ln setAnglesCmd -dt "string" $mpd;
		setAttr -type "string" ($mpd+".setAnglesCmd") $setAnglesCmd;
		}
	$previousOutput=($mpd+".outputX");

	}
connectAttr -f $previousOutput ($driverObjs[0]+"."+$attr);
select $sel;
return $attr;
}

global proc string[] asSetBlendedAttribute (string $driverObj, string $driverAttr, float $value, int $getDriversMode)
{
string $tempString[],$drivers[];
string $setAnglesCmd;
int $connectedToMultDiv=1;
string $plug=$driverObj+"."+$driverAttr;
float $dvs[];
while ($connectedToMultDiv)
	{
	$connectedToMultDiv=0;
	$tempString=`listConnections -s 1 -d 0 -scn 1 $plug`;
	string $nodeA=$tempString[0];
	if(size($tempString)>0)
		{
		if (`objectType $nodeA`=="multiplyDivide")
			{
			$connectedToMultDiv=1;
			$plug=$nodeA+".input1.input1X";
			if (`attributeExists setAnglesCmd $nodeA`)
				$setAnglesCmd=`getAttr ($nodeA+".setAnglesCmd")`;
			}
		else if (`objectType $nodeA`=="setRange")
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueY")`;
			$drivers[size($drivers)]=$tempString[0];
			$dvs[size($dvs)]=`getAttr ($nodeA+".dvY")`;
			
			$tempString=`listConnections -s 1 -d 0 -p 0 -scn 1 ($nodeA+".valueX")`;
			string $nodeB=$tempString[0];
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueX")`;
			if (`objectType $nodeB`=="multiplyDivide")
				{
				$connectedToMultDiv=1;
				$plug=$nodeA+".valueX";
				}
			else
				{
				$drivers[size($drivers)]=$tempString[0];
				$dvs[size($dvs)]=`getAttr ($nodeA+".dvX")`;
				}
			}
		}
	
	}

//For inbetweens, just find the values were all inputs are equal, and sum up to total
if ($value<1)
	for ($i=0;$i<size($dvs);$i++)
		{
		float $temp=`pow $dvs[$i] 2`;
		$dvs[$i]=`sqrt($temp*$value)`;
		}

for ($i=0;$i<size($drivers);$i++)
	if (!$getDriversMode)
		{
		string $setDriver=$drivers[$i];
		if (`gmatch $setDriver "*[.]angle*"`)// blended angles
			{
/*
			tokenize $setDriver "[.]" $tempString;
			string $driverObj=$tempString[0];
			string $driverAttr=$tempString[1];
			asSetRotationFromAngle $driverObj $driverAttr $dvs[$i];
*/
			//Updated, since the separate individual rotations affects all other "angles"
			eval $setAnglesCmd;
			}
		else
			{
			string $FKDriver="FK"+$drivers[$i];
			if (`objExists $FKDriver`)
				$setDriver=$FKDriver;
			setAttr $setDriver $dvs[$i];
			}
		}
$drivers=`sort $drivers`;
return $drivers;
}

global proc string asCreateCorrectiveShape ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl -o`;
string $tempString[],$tempString2[];
if(size($sel)==0)
	error "No mesh selected, select geometry on your character";
if (size($sel)>1)
	error "More than 1 object selected, Only 1 object must be selected";
if (`gmatch $sel[0] "*__*"`)
	error "Selected object IS a Corrective Shape. Select geometry on your character";
if ($sel[0]!="")
	if (`objectType $sel[0]`=="mesh")
		$sel=`listRelatives -p $sel[0]`;
$tempString=`listRelatives -ni -s $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not geometry";
if (`objectType $tempString[0]`!="mesh")
	error "Selected object is not a mesh";

string $controlSetMembers[];
if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;

//string $tr[]={"t","r"};
//string $xyz[]={"x","y","z"};
string $drivers[],$keyableAttr[];
string $objAttr;
float $poseValue,$currentValue;
//Find driving attribute(s)
string $buildPoseCmds[],$runCmds[];
//get $buildPoseCmds
if (`objExists ControlSet`)
	$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}
string $runObjAttrs[],$checkObjAttr[];
float $runValues[];
for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<2;$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKExtra*"`)//must filter FKExtraJaw_M & FKExtraEye_*, so just filter all Extra
				continue;
			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;
			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				$drivers[size($drivers)]=$checkObjAttr[$z];
			}
		}
	}
if (size($drivers)==0)
	error ("Found no driving attribute, all values are in Build-Pose");

//For twistDistributed limbs, if not using "Angle", then rx is not excepted, neighter is any mix
if (!`checkBox -q -v asCorrectiveAngleCheckBox`)
	{
	if (`gmatch $drivers[0] "*[.]rotateX"` || `size($drivers)`>1)
		{
		tokenize $drivers[0] "[.]" $tempString;
		int $numChar=size($tempString[0]);
		string $fitJoint=`substring $tempString[0] 3 ($numChar-2)`;
		if (`objExists $fitJoint`)
			if (`attributeExists twistJoints $fitJoint` || `attributeExists inbetweenJoints $fitJoint`)
				{
				warning "Due to \"twistJoints\" or \"inbetweenJoints\" beeing used, rotation values will not work, Now turning On \"Angle\" rotations.";
				checkBox -e -v 1 asCorrectiveAngleCheckBox;
				asCreateCorrectiveShape;
				return "";
				}
		}
	}

for ($i=0;$i<size($drivers);$i++)
	{
	string $nonFKDriver=`substitute "FK" $drivers[$i] ""`;
	if (`objExists $nonFKDriver`)
//		if (!`gmatch $drivers[0] "FK*[.]translate*"`) //(FK*.t* dont have zero default values)
			$drivers[$i]=$nonFKDriver;
	}

tokenize $drivers[0] "[.]" $tempString;
string $deformObj=$sel[0];
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $directDriverAttr=$driverAttr;
float $dv=`getAttr $drivers[0]`;
float $idv=0;

//angle driver
if (`checkBox -q -v asCorrectiveAngleCheckBox`)
	if (`gmatch $driverAttr "r*"`)//rotation && !blended
		{
		if (!`attributeExists "angleX" $driverObj`)
			asCreateAngleAttrs $driverObj;

		//Max 90 degrees
		float $FKdv=`getAttr ("FK"+$drivers[0])`;
		if (abs($FKdv)>90)
			{
			warning ("Angle rotation more than 90 degrees, now reducing rotation to 90.");
			if ($dv>0) $dv=90;
			if ($dv<0) $dv=-90;
			setAttr ("FK"+$drivers[0]) $dv;
			}
		for ($i=0;$i<size($drivers);$i++)
			{
			if (`gmatch $drivers[$i] "*[.]rotate*"`)
				{
				$drivers[$i]=`substitute "rotate" $drivers[$i] "angle"`;
				$driverAttr=`substitute "rotate" $driverAttr "angle"`;
				}
			$idv=$dv;
			$dv=`getAttr ($driverObj+"."+$driverAttr)`;
			if (`gmatch $driverAttr "*X"` && `objExists ("TwistBalancer"+$driverObj)`)
				{
				//$idv special case if RX from a twist-system
				$idv=`getAttr ("TwistBalancer"+$driverObj+"."+$directDriverAttr)`;
				}
			}
		//2 rotation attributes could be translated to 3 angle attributes
		string $XYZ[]={"X","Y","Z"};
		if (size($drivers)>1)
			for ($i=0;$i<size($drivers);$i++)
				{
				for ($y=0;$y<size($XYZ);$y++)
					{
					string $check=$driverObj+".angle"+$XYZ[$y];
					float $checkVal=`getAttr $check`;
					if (abs($checkVal)>0.001)
						if (!`stringArrayCount $check $drivers`)
							{
							$drivers[size($drivers)]=$check;
							$drivers=`sort $drivers`;
							}
					}
				}
		}

if (size($drivers)>1)
	{
	//We might have arrived back here from already created blendAttr
	if (`objExists BlendedCorrectiveDriver`)
		{
		$driverObj=`getAttr BlendedCorrectiveDriver.driverObj`;
		$driverAttr=`getAttr BlendedCorrectiveDriver.driverAttr`;
		$dv=`getAttr ($driverObj+"."+$driverAttr)`;
		}
	else
		{
		string $m="Create Corrective Shape from blend of these drivers?\n\n";
		for ($i=0;$i<size($drivers);$i++)
			{
			float $value=`getAttr $drivers[$i]`;
			$value=`asRoundOff $value 3`;
			$m+=$drivers[$i]+" = "+$value+"\n";
			}
		if (!$asSkipConfirm)
			if (`confirmDialog -t "Multiple Drivers Found"
				-m $m
				-b "OK" -b "Cancel" -db "Cancel"
				-ds "Cancel"`!="OK")
					return "";
		asCreateBlendedAttribute $drivers;
		asCreateCorrectiveShape;
		return "";
		}
	}

string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
$dv=`asRoundOff $dv 3`;

float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr+"__"+$posNeg;

if (size($drivers)==1 && !$asSkipConfirm)
	{
	string $dialog=`confirmDialog -t "Single Driver Found"
		-m ("Create Corrective Shape from this driver?\n\n"+$driverObj+"."+$driverAttr+" = "+$dv)
		-b "OK" -b "Cancel" -db "Cancel"
		-ds "Cancel"`;
	if ($dialog!="OK")
		return "";
	}

asCorrectiveDuplicate $attrCode $sel[0];

addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;

return $attrCode;
}

global proc float asCorrectiveGetIV (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $iv=1;
string $bs=$deformObj+"Corrective";
if (!`objExists $bs`)
	return 1;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
float $maxKeyVal;
string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount ($driverObj+"__"+$driverAttr+"__"+$posNeg) $weights`)
	{
	$tempString=`listConnections ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
	float $keyXValues[]=`keyframe -q -fc $tempString[0]`;
	float $keyYValues[]=`keyframe -q -vc $tempString[0]`;
	float $xvalueAtOneY=$keyXValues[size($keyXValues)-1];
	for ($i=0;$i<size($keyYValues);$i++)
		if ($keyYValues[$i]==1)
			$xvalueAtOneY=$keyXValues[$i];

	$iv=$dv/$xvalueAtOneY;
	$iv=`asRoundOff $iv 3`;
	}
return $iv;
}

global proc asCorrectiveDuplicate (string $attrCode, string $source)
{
float $charHeight=`asgetCharHeight`;
duplicate -n $attrCode $source;
asLockAttr $attrCode 0 0 0 0;
string $tempString[]=`listRelatives -p $attrCode`;
if ($tempString[0]!="")
	parent -w $attrCode;
$tempString=`listRelatives -f -s $attrCode`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="mesh")
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
$tempString=`listRelatives -f -s $attrCode`;
rename $tempString[0] ($attrCode+"Shape");

rowLayout -e -en 1 asCorrectiveEditChoicesRowLayout;
button -e -en 0 asCreateCorrectiveButton;
button -e -en 0 asEditCorrectiveButton;
button -e -en 0 asDeleteCorrectiveButton;
button -e -en 0 asGraphCorrectiveButton;
string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	
setAttr ($group+".v") 0;

$tempString=`ls -sl -l $source`;
if (!`gmatch $tempString[0] "|Group|*"`)
	{
	setAttr ($source+".v") 0;
	if (!`attributeExists "correctiveShapeModeHidden" $group`)
		addAttr -ln "correctiveShapeModeHidden" -dt "string" $group;
	setAttr -type "string" ($group+".correctiveShapeModeHidden") $source;
	}

//setAttr ($attrCode+".tx") ($charHeight*0.5);
select $attrCode;
SculptGeometryTool;

headsUpDisplay -s 2 -b 0 -bs "medium" -l "Corrective Shape Mode" -lfs "large" HUDCSMMode;
scriptJob -runOnce true -e deleteAll "asExitCorrectiveShapeMode";
scriptJob -runOnce true -nodeDeleted $attrCode "asExitCorrectiveShapeMode";
}

global proc asConnectCorrectiveShape ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $tempString[];
if (size($sel)<1)
	error "Select the Corrective Shape";
if (`gmatch $sel[0] "*[.]*"`)
	$sel=`ls -sl -o`;
if (`objectType $sel[0]`!="transform")
	{
	$tempString=`listRelatives -p $sel[0]`;
	$sel[0]=$tempString[0];
	}
if (size($sel)!=1)
	error "Select only the Corrective Shape";
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
string $restoreCmds[];
tokenize `substituteAllString $sel[0] "__"  "|"` "|" $tempString;
string $deformObj=$tempString[0];
string $driverObj=$tempString[1];
string $driverAttr=$tempString[2];
float $dv=`getAttr ($sel[0]+".driverValue")`;
float $idv=`getAttr ($sel[0]+".indirectDriverValue")`;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
float $iv=`getAttr ($sel[0]+".inbetweenValue")`;
int $deleteMode=`objExists DeleteCorrectiveShape`;
string $deltaShape=$driverObj+"__"+$driverAttr+"__"+$posNeg;
string $sdk=$deformObj+"Corrective_"+$deltaShape;
float $keyXValues[];
if (`objExists $sdk`)
	$keyXValues=`keyframe -q -fc $sdk`;
if ($sel[0]==$deformObj)
	error "Can not use itself as Corrective Shape, Select the Corrective Shape";
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;

int $isJoystick=0;
$tempString=`ls -l $driverObj`;
if (`gmatch $tempString[0] "*|ctrlBox|*"`)
	$isJoystick=1;
float $mirrorDv=$dv;
string $mirrorPosNeg=$posNeg;
if (($driverAttr=="translateX" && !$isJoystick) || (`gmatch $driverObj "FK*"` && `gmatch $driverAttr "translate*"`))
	{
	$mirrorDv=$dv*-1;
	if ($posNeg=="pos") $mirrorPosNeg="neg";
	if ($posNeg=="neg") $mirrorPosNeg="pos";
	}
int $doMirror=0;
string $mirrorDriverObj,$FKMirrorDriverObj,$mirrorDeltaShape,$mirrorSdk;
string $side="_R";
string $mirrorDriverAttr=$driverAttr;
string $mirrorSide="_L";
if (`gmatch $driverObj "*_L"`)
	{
	$side="_L";
	$mirrorSide="_R";
	}
if (`checkBox -q -v asCorrectiveMirrorCheckBox`)
	{
	$mirrorDriverObj=`substitute $side $driverObj $mirrorSide`;
	$FKMirrorDriverObj=`substitute $side $FKDriverObj $mirrorSide`;
	$mirrorDeltaShape=`substitute $side $deltaShape $mirrorSide`;
	if ($mirrorPosNeg!=$posNeg)
		$mirrorDeltaShape=`substitute $posNeg $mirrorDeltaShape $mirrorPosNeg`;
	$mirrorSdk=`substitute $side $sdk $mirrorSide`;

	if (`objExists $mirrorDriverObj` && $driverObj!=$mirrorDriverObj)
		{
		$doMirror=1;
		//angle attrs
		if (`gmatch $driverAttr "angle*"`)
			if (!`attributeExists "angleX" $mirrorDriverObj`)
				asCreateAngleAttrs $mirrorDriverObj;
		//blended attrs
		if (`gmatch $driverAttr "*_*"`)
			{
			string $drivers[]=`asSetBlendedAttribute $driverObj $driverAttr 0 1`;
			string $mirroredDrivers[];
			float $driverValues[],$mirroredDriverValues[],$rotates[];
			for ($i=0;$i<size($drivers);$i++)
				{
				$driverValues[$i]=`getAttr $drivers[$i]`;
				$mirroredDriverValues[$i]=$driverValues[$i];
				$mirroredDrivers[$i]=`substitute $side $drivers[$i] $mirrorSide`;
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						$rotates=`getAttr ($FKDriverObj+".r")`;
						setAttr -type float3 ($FKDriverObj+".r") 0 0 0;
						}
					}
				else
					setAttr $drivers[$i] 0;
				if ((`gmatch $mirroredDrivers[$i] "*[.]translateX"` && !$isJoystick) || (`objExists ("FK"+$driverObj)` && `gmatch $mirroredDrivers[$i] "*[.]translate*"`))
					$mirroredDriverValues[$i]=$driverValues[$i]*-1;
				//temporary mirror blended pose
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						setAttr -type float3 ($FKMirrorDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
					}
				else
					setAttr $mirroredDrivers[$i] $mirroredDriverValues[$i];
				}
			//asCreateBlendedAttribute
			$mirrorDriverAttr=`asCreateBlendedAttribute $mirroredDrivers`;
			$mirrorDeltaShape=$mirrorDriverObj+"__"+$mirrorDriverAttr+"__pos";
			//restore blended pose
			for ($i=0;$i<size($drivers);$i++)
				{
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						setAttr -type float3 ($FKMirrorDriverObj+".r") 0 0 0;
						setAttr -type float3 ($FKDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
						}
					}
				else
					{
					setAttr $mirroredDrivers[$i] 0;
					setAttr $drivers[$i] $driverValues[$i];					
					}
				}
			}
		}
	}

string $history[]=`listHistory $deformObj`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			{
			setAttr ($history[$i]+".envelope") 0;
			$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
			}
duplicate -n $deltaShape $deformObj;
asLockAttr $deltaShape 0 0 0 0;
$tempString=`listRelatives -p $deltaShape`;
if ($tempString[0]!="")
	parent -w $deltaShape;

addAttr -k 1 -ln driverValue -at double -dv $dv $deltaShape;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $deltaShape;
if($doMirror && !$deleteMode)
	{
	duplicate -n $mirrorDeltaShape $deformObj;
	asLockAttr $mirrorDeltaShape 0 0 0 0;
	$tempString=`listRelatives -p $mirrorDeltaShape`;
	if ($tempString[0]!="")
		parent -w $mirrorDeltaShape;
	addAttr -k 1 -ln driverValue -at double -dv $mirrorDv $mirrorDeltaShape;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $mirrorDeltaShape;
	}

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

//Inverse shapes from other deformers
//if (`gmatch $driverAttr "*_*"` && `objExists ($deformObj+"Corrective")`)
duplicate -n ($deltaShape+"_componentReverse") $deformObj;
$tempString=`listRelatives -p ($deltaShape+"_componentReverse")`;
if ($tempString[0]!="")
	parent -w ($deltaShape+"_componentReverse");
select $sel[0] $deformObj ($deltaShape+"_componentReverse");
blendShape -n ($deltaShape+"_componentReverseBS") -frontOfChain -w 0 1 -w 1 1;

$history=`listHistory $deformObj`;
string $weights[];
if (`objExists ($deformObj+"Corrective.w")`)
	$weights=`listAttr -m ($deformObj+"Corrective.w")`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			if ($history[$i]==($deformObj+"Corrective"))
				if (`gmatch $driverAttr "*_*"`)
					for ($y=0;$y<size($weights);$y++)
						{
						if ($weights[$y]!=$deltaShape)
							setAttr ($deformObj+"Corrective."+$weights[$y]) 0;
						}
select ($deltaShape+"_componentReverse");
DeleteHistory;
select ($deltaShape+"_componentReverse") $sel[0];
blendShape -n ($deltaShape+"_componentReverseBS2") -frontOfChain -w 0 1;
select $sel[0];
DeleteHistory;
for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);
delete ($deltaShape+"_componentReverse");

//Restore bsTargets that were rest to Zero, by dgdirty. SDK`s will ensure restore.
dgdirty -a;
//eval ($resetTargetsRestoreCmd);

select $deltaShape $deformObj;
asCorrectiveConnectBS;

$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
	setAttr ($deformObj+"Corrective."+$deltaShape) 1;

int $incOnce,$numVtxMoved;
int $numVtxs[]=`polyEvaluate -v $deltaShape`;
float $mag,$prevMag,$move;
float $tol=0.001;
float $selPos[]=`xform -q -ws -t $sel[0]`;
float $deformPos[]=`xform -q -ws -t $deformObj`;
xform -ws -t $deformPos[0] $deformPos[1] $deformPos[2] $sel[0];
float $posA[3],$posA2[3],$posB[3],$temp[3];
string $xyz[]={"x","y","z"};

//get current FKIK blend values
string $controlSetMembers[];
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
string $restoreFKIKCmds[];
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`gmatch $controlSetMembers[$i] "FKIK*_*"`)
		if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
			$restoreFKIKCmds[size($restoreFKIKCmds)]="setAttr "+$controlSetMembers[$i]+".FKIKBlend "+`getAttr ($controlSetMembers[$i]+".FKIKBlend")`+";";

string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

float $zv=`getAttr ($driverObj+"."+$driverAttr)`;
$zv=`asRoundOff $zv 3`;
float $mirrorZv;
if($doMirror)
	{
	$mirrorZv=`getAttr ($mirrorDriverObj+"."+$mirrorDriverAttr)`;
	$mirrorZv=`asRoundOff $mirrorZv 3`;
	}

//restore all FKIK blend values as berfore GoToBuildPose, since we might have changed to FK to do corrective
for ($i=0;$i<size($restoreFKIKCmds);$i++)
	eval ($restoreFKIKCmds[$i]);

eval($restorePoseCmd);
dgdirty -a;

//Go to `Corrective` Pose, (not guranteed to already be in this pose, specially if editing Existing target)
//asGoToCorrectivePose $driverObj $driverAttr $dv;
//refresh;

$tempString=`listRelatives -f -s $deformObj`;
string $preDeformMesh;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		$preDeformMesh=$tempString[$i];

//matrix loop utilities
float $xPoint[],$yPoint[],$zPoint[],$newPos[];
createNode -n correctiveMatrixUtilities transform;
createNode -n matrix2xform parentConstraint;
createNode -n matrix2scale scaleConstraint;
createNode -n invMReaderOffset transform;
addAttr -ln theMatrix -dt "matrix" invMReaderOffset;
createNode -n invMReader -p invMReaderOffset transform;
createNode -n invMNewPos -p invMReader transform;
createNode -n defOffset transform;
createNode -n corPos -p defOffset transform;
connectAttr -f corPos.translate invMNewPos.translate;
connectAttr -f corPos.rotate invMNewPos.rotate;
connectAttr -f corPos.scale invMNewPos.scale;
//invMReaderOffset.theMatrix to matrixInverter.xform
createNode -n matrixInverter transform;
createNode -n matrix2xform2 parentConstraint;
createNode -n matrix2scale2 scaleConstraint;
connectAttr invMReaderOffset.theMatrix  matrix2xform2.target[0].targetParentMatrix;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateX matrixInverter.translate.translateX;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateY matrixInverter.translate.translateY;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateZ matrixInverter.translate.translateZ;
connectAttr matrix2xform2.constraintRotate.constraintRotateX matrixInverter.rotate.rotateX;
connectAttr matrix2xform2.constraintRotate.constraintRotateY matrixInverter.rotate.rotateY;
connectAttr matrix2xform2.constraintRotate.constraintRotateZ matrixInverter.rotate.rotateZ;
connectAttr invMReaderOffset.theMatrix matrix2scale2.target[0].targetParentMatrix;
connectAttr matrix2scale2.constraintScale matrixInverter.scale;
//matrixInverter.inverseMatrix to invMReader.xform
connectAttr matrixInverter.inverseMatrix matrix2xform.target[0].targetParentMatrix;
connectAttr matrix2xform.constraintTranslate.constraintTranslateX invMReader.translate.translateX;
connectAttr matrix2xform.constraintTranslate.constraintTranslateY invMReader.translate.translateY;
connectAttr matrix2xform.constraintTranslate.constraintTranslateZ invMReader.translate.translateZ;
connectAttr matrix2xform.constraintRotate.constraintRotateX invMReader.rotate.rotateX;
connectAttr matrix2xform.constraintRotate.constraintRotateY invMReader.rotate.rotateY;
connectAttr matrix2xform.constraintRotate.constraintRotateZ invMReader.rotate.rotateZ;
connectAttr matrixInverter.inverseMatrix matrix2scale.target[0].targetParentMatrix;
connectAttr matrix2scale.constraintScale invMReader.scale;
parent matrix2xform matrix2scale invMReaderOffset defOffset matrixInverter matrix2xform2 matrix2scale2 correctiveMatrixUtilities;
//setAttr ($deformObj+"Corrective.envelope") 0;

//Existing blendShape nodes causes a inverse (&multiplied) deformation, so envelope off these.
$history=`listHistory $deformObj`;
clear $restoreCmds;
string $bsNodes[];
string $skinCluster;
for ($i=0;$i<size($history);$i++)
	{
	if (`objectType $history[$i]`=="skinCluster" && $skinCluster=="")
		$skinCluster=$history[$i];
	if (`objectType $history[$i]`=="blendShape" && $history[$i]!="asFaceBS")
		{
		setAttr ($history[$i]+".envelope") 0;
		$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
		}
	}

//Make sure the corrective is the first BS before the skinCluster
catchQuiet (`reorderDeformers $skinCluster ($deformObj+"Corrective") $deformObj`);
//And before "asFaceBS"
if (`objExists "asFaceBS"`)
	catchQuiet (`reorderDeformers "asFaceBS" ($deformObj+"Corrective") $deformObj`);

//xyz Offsets`s
move -r 1 0 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n xOffsetts $deformObj;
move -r -1 1 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n yOffsetts $deformObj;
move -r 0 -1 1 ($preDeformMesh+".vtx[0:999999]");
duplicate -n zOffsetts $deformObj;
move -r 0 0 -1 ($preDeformMesh+".vtx[0:999999]");
asLockAttr xOffsetts 0 0 0 0;
asLockAttr yOffsetts 0 0 0 0;
asLockAttr zOffsetts 0 0 0 0;
parent xOffsetts yOffsetts zOffsetts correctiveMatrixUtilities;

progressBar -e -st ("Computing Delta Shape") -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
for ($i=0;$i<$numVtxs[0];$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
		blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
		delete $deltaShape;
		if (`objExists $mirrorDeltaShape`)
			delete $mirrorDeltaShape;
		delete correctiveMatrixUtilities;
		select $sel[0];
		print ("// Corrective Shape Cancelled	\n");
		return;
		}
	if ($deleteMode)
		break;
	progressBar -e -s 1 $gMainProgressBar;

	$posA=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	$posB=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;

	if (abs($posA[0]-$posB[0])<$tol && abs($posA[1]-$posB[1])<$tol && abs($posA[2]-$posB[2])<$tol)
		continue;

	$numVtxMoved++;

	//inverseMatrix
	float $nonDefPos[]=`xform -q -ws -t ($preDeformMesh+".vtx["+$i+"]")`;
	float $defPos[]=`xform -q -ws -t ($deformObj+".vtx["+$i+"]")`;
	float $corPos[]=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;
	xform -ws -t $nonDefPos[0] $nonDefPos[1] $nonDefPos[2] invMReaderOffset;

	xform -ws -t $defPos[0] $defPos[1] $defPos[2] defOffset;
	xform -ws -t $corPos[0] $corPos[1] $corPos[2] corPos;

	$xPoint=`xform -q -ws -t ("xOffsetts.vtx["+$i+"]")`;
	$yPoint=`xform -q -ws -t ("yOffsetts.vtx["+$i+"]")`;
	$zPoint=`xform -q -ws -t ("zOffsetts.vtx["+$i+"]")`;

	setAttr -type "matrix" invMReaderOffset.theMatrix 
	($xPoint[0]-$defPos[0]) ($xPoint[1]-$defPos[1]) ($xPoint[2]-$defPos[2]) 0
	($yPoint[0]-$defPos[0]) ($yPoint[1]-$defPos[1]) ($yPoint[2]-$defPos[2]) 0
	($zPoint[0]-$defPos[0]) ($zPoint[1]-$defPos[1]) ($zPoint[2]-$defPos[2]) 0
	0 0 0 1;

	$newPos=`xform -q -ws -t invMNewPos`;
	xform -ws -t $newPos[0] $newPos[1] $newPos[2] ($deltaShape+".vtx["+$i+"]");
	}
progressBar -e -ep $gMainProgressBar;
//setAttr ($deformObj+"Corrective.envelope") 1;
delete correctiveMatrixUtilities;
xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
print ("//Calculated "+$numVtxMoved+" vtx for deltashape\n");

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
eval($restorePoseCmd);
dgdirty -a;

if($doMirror && !$deleteMode)
	{
	createNode -n ($deltaShape+"MirrorGroup") transform;
	parent $deltaShape ($deltaShape+"MirrorGroup");
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	duplicate -n ($mirrorDeltaShape+"Default") $mirrorDeltaShape;
	select ($mirrorDeltaShape+"Default") $deltaShape;
	blendShape -n tempMirrorCorrectiveBS -frontOfChain;
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 1;
	select $mirrorDeltaShape $deltaShape;
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 0;
	select $mirrorDeltaShape;
	DeleteHistory;
	delete ($mirrorDeltaShape+"Default");
	select $mirrorDeltaShape $deformObj;
	asCorrectiveConnectBS;
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	}
if ($deleteMode)
	{
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	print ("deleting "+$deltaShape+", (inbetweenValue="+$iv+", value="+$dv+")\n");
	blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
	selectKey -add -k -f $dv $sdk;
	cutKey -animation keys -clear;
	}
delete $deltaShape;
delete $sel[0];
if($doMirror && !$deleteMode)
	delete $mirrorDeltaShape ($deltaShape+"MirrorGroup");
if ($deleteMode)
	delete DeleteCorrectiveShape;
$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if ($iv<1)
	;//print ("Inbetweener..skipping SDK..\n");
if ($iv==1) //SDK for inbetweens not done here
	if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
		{
		if (`objExists $sdk`) if (size($keyXValues)<2) delete $sdk;
		setDrivenKeyframe 														-v 0 -dv $zv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv $dv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		if($doMirror && !$deleteMode)
			{
			if (`objExists $mirrorSdk`) {float $mirrorKeyValues[]=`keyframe -q -fc $mirrorSdk`;if (size($mirrorKeyValues)<2) delete $mirrorSdk;}
			setDrivenKeyframe 														-v 0 -dv $mirrorZv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv $mirrorDv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			}
		}

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;


string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	
setAttr ($group+".v") 1;
asExitCorrectiveShapeMode;
autoKeyframe -state $autoKeyframe;
select $deformObj;
setToolTo $gSelect;
}

global proc asCancelCorrectiveShape ()
{
global string $gSelect;
string $tempString[];
string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		{
		delete $rootLevelObjects[$i];
		tokenize $rootLevelObjects[$i] "_" $tempString;
		if (`objExists $tempString[0]`)
			select $tempString[0];
		}
if (`objExists "Group"`)
	setAttr "Group.v" 1;
asExitCorrectiveShapeMode;
setToolTo $gSelect;
}

global proc asExitCorrectiveShapeMode ()
{
//setAttr "Group.v" 1; crashes maya :(
rowLayout -e -en 0 asCorrectiveEditChoicesRowLayout;
button -e -en 1 asCreateCorrectiveButton;
button -e -en 1 asEditCorrectiveButton;
button -e -en 1 asDeleteCorrectiveButton;
button -e -en 1 asGraphCorrectiveButton;

string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	

if (`attributeExists "correctiveShapeModeHidden" $group`)
	setAttr (`getAttr ($group+".correctiveShapeModeHidden")`+".v") 1;
if (`headsUpDisplay -q -ex HUDCSMMode`)
	headsUpDisplay -rem HUDCSMMode;
}

global proc asCorrectiveConnectBS ()
{
int $numLetters;
string $sel[]=`ls -sl`;
string $deltaShape=$sel[0];
string $deformObj=$sel[1];
string $tempString[];
tokenize `substituteAllString $deltaShape "__"  "|"` "|" $tempString;
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $posNeg="pos";
if (`getAttr ($deltaShape+".driverValue")`<0)
	$posNeg="neg";
float $iv=`getAttr ($deltaShape+".inbetweenValue")`;
int $existingTargetNr=-1;
if (`objExists ($deformObj+"Corrective")`) //BSnode Exists (Adding Target to BS node)
	{
	int $inputTargetGroups[]=`getAttr -mi ($deformObj+"Corrective.inputTarget[0].inputTargetGroup")`;
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	for ($i=0;$i<size($existingTargets);$i++)
		{
		if ($existingTargets[$i]==$deltaShape)
			$existingTargetNr=$i;
		}
	if ($existingTargetNr!=-1 && $iv==1) // BSnode and BStarget Exists (Replacing target)
		{
		print ("// Replacing BlendShape Target\n");
		connectAttr -f ($deltaShape+".worldMesh[0]") ($deformObj+"Corrective.inputTarget[0].inputTargetGroup["+$inputTargetGroups[$existingTargetNr]+"].inputTargetItem[6000].inputGeomTarget");
		}
	else if ($iv<1 || $iv>1) // BSnode and `similar` target Exists (This must be a inbetween target)
		{
		print ("// connecting inbeween shape at: "+$iv+" for targetNr: "+$existingTargetNr+"\n");
		blendShape -e -inBetween -t $deformObj $inputTargetGroups[$existingTargetNr] $deltaShape $iv ($deformObj+"Corrective");
		//add a key, so this inbeween can be extracted
		setDrivenKeyframe -v $iv -dv `getAttr ($deltaShape+".driverValue")` -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg);
		}
	else
		{
		print ("// Creating New BlendShape\n");
		blendShape -e -t $deformObj `size($existingTargets)` $deltaShape 1 ($deformObj+"Corrective");
		}
	}
else
	{
	blendShape -n ($deformObj+"Corrective") -frontOfChain;
//	$tempString=`listConnections ($deformObj+"Corrective.outputGeometry[0]")`;
//	rename $tempString[0] ($deformObj+"PB");
	}
}

global proc asPopulateCorrectivePopupMenu (string $action)
{
string $popupMenu="as"+$action+"CorrectiveShapesPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
string $correctiveBS[]=`ls -r 1 -type blendShape "*Corrective"`;
int $menuExisted,$en;
float $keyXValues[],$keyYValues[];
string $label;
string $weights[],$tempString[],$menu2s[],$menu3s[],$menu4s[];
for ($i=0;$i<size($correctiveBS);$i++)
	{
	string $deformObj=`substitute "Corrective" $correctiveBS[$i] ""`;
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph")
		$sm=0;
	$lev1Menu=`menuItem -sm $sm -l $deformObj`;
	if ($action=="Graph")
		{
		menuItem -e -c ("select "+$correctiveBS[$i]+";GraphEditor;") $lev1Menu;
		continue;
		}
	$weights=`listAttr -m ($correctiveBS[$i]+".w")`;
	$weights=`sort $weights`;
	for ($y=0;$y<size($weights);$y++)
		{
		tokenize `substituteAllString $weights[$y] "__"  "|"` "|" $tempString;
		string $driverObj=$tempString[0];
		string $driverAttr=$tempString[1];
		string $posNeg=$tempString[2];
		setParent -menu $lev1Menu;

		//$menu2s
		$menu="asCorrectiveMenu_"+$deformObj+$action+$driverObj;
		if(`stringArrayCount $menu $menu2s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $driverObj $menu;
			$menu2s[size($menu2s)]=$menu;
			}

		//$menu3s
		$menu="asCorrectiveMenu_"+$deformObj+$action+$driverObj+"_"+$driverAttr;
		if(`stringArrayCount $menu $menu3s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $driverAttr $menu;
			$menu3s[size($menu3s)]=$menu;
			}

		//$menu4s
		$menu="asCorrectiveMenu_"+$deformObj+$action+$driverObj+"_"+$driverAttr+"_"+$posNeg;
		if(`stringArrayCount $menu $menu4s`) {
			setParent -menu $menu;}
		else
			{
			menuItem -sm 1 -l $posNeg $menu;
			$menu4s[size($menu4s)]=$menu;
			}
		$sdk=`listConnections ($correctiveBS[$i]+"."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
		$keyXValues=`keyframe -q -fc $sdk`;
		$keyYValues=`keyframe -q -vc $sdk`;
		$haveKeyAtOne=0;
		for ($z=0;$z<size($keyYValues);$z++)
			if ($keyYValues[$z]==1)
				$haveKeyAtOne=1;
		if (!$haveKeyAtOne)
			warning "Found No keys at with \"Y\" value of 1, Unable to determine which shape is not a inbetween";
		float $smallestKeyXValue=99;
		for ($z=0;$z<size($keyXValues);$z++)
			if (abs($keyXValues[$z])<$smallestKeyXValue)
				$smallestKeyXValue=abs($keyXValues[$z]);
		for ($z=0;$z<size($keyXValues);$z++)
			{
			if (($keyXValues[$z]>=0 && $keyXValues[$z]==$smallestKeyXValue) || ($keyXValues[$z]<0 && $keyXValues[$z]==-1*$smallestKeyXValue))
				continue;
			setParent -menu $menu;
			float $roundFactor;
			if ($keyXValues[$z]>0) $roundFactor=0.5;
			else $roundFactor=-0.5;
			$keyXValues[$z]=(trunc($keyXValues[$z]*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
			$cmd="";
			if ($action=="Delete")
				$cmd="createNode -n DeleteCorrectiveShape transform;";
			if ($action=="Edit" || $action=="Delete")
				$cmd+="asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" \""+$keyXValues[$z]+"\" ";
			if ($action=="Delete")
				$cmd+=";asConnectCorrectiveShape;";
			$en=1;
			$label=$keyXValues[$z];
			if ($action=="Delete")
				if ($keyYValues[$z]==1 && size($keyXValues)>2)
//				if (($keyXValues[$z]>0 && size($keyXValues)>2 && $z==size($keyXValues)-1)
//				 || ($keyXValues[$z]<0 && size($keyXValues)>2 && $z==0))
					$en=0;
//			if (($keyXValues[$z]>0 && $z<size($keyXValues)-1) || ($keyXValues[$z]<0 && $z>0))
			if ($keyYValues[$z]!=1)
				$label+=" (inbtw)";
			menuItem -en $en -l $label -c $cmd;
			}
		}
	}
}

global proc float asSetRotationFromAngle (string $driverObj, string $driverAttr, float $dv)
{
//Dont set `mix` values
if (`gmatch $driverAttr "*_*"`)
	return 1;
string $XYZ=`substitute "angle" $driverAttr ""`;
float $a=1-`abs($dv)`;
float $c=0.707;
float $b=0.707;
float $rads = ((`pow $b 2`) + (`pow $c 2`) - (`pow $a 2`)) /( 2*$b*$c);
float $deg=90-`acosd($rads)`;
if ($dv<0)
	$deg*=-1;
setAttr ("FK"+$driverObj+".rotate"+$XYZ) $deg;
return $deg;
}

global proc asGoToCorrectivePose (string $driverObj, string $driverAttr, float $dv)
{
string $FKIK;
string $tempString[],$tempString2[],$tempString3[],$tempString4[];
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;

//inbetween changes the driverValue
int $numChar=size($driverObj);
string $fitJoint=`substring $driverObj 1 ($numChar-2)`;
if (`objExists $fitJoint`)
	if (`attributeExists inbetweenJoints $fitJoint`)
		$dv=$dv*(`getAttr ($fitJoint+".inbetweenJoints")`+1);

if (!`getAttr -settable ($FKDriverObj+"."+$driverAttr)`)//blended (including blended angles
	{
	asSetBlendedAttribute $driverObj $driverAttr $dv 0;
	if (`gmatch $driverAttr "angle*"`)//single angles (not blended angles)
		$idv=`asSetRotationFromAngle $driverObj $driverAttr $dv`;
	}
else
	setAttr ($FKDriverObj+"."+$driverAttr) $dv;

//Set FKIK to FK (if FK exists)
if (`objExists ("FK"+$driverObj)` && `objExists ("FKX"+$driverObj)` && `objExists ("IKX"+$driverObj)` && `objExists ("FKOffset"+$driverObj)`)
	{
	$tempString=`listConnections ($driverObj+".rx")`;
	if ($tempString[0]!="")
		$tempString2=`listAttr -ud $tempString[0]`;
	if ($tempString2[1]!="")
		$tempString3=`listConnections ($tempString[0]+"."+$tempString2[1])`;
	if (`objExists ($tempString3[0]+".input")`)
		$tempString4=`listConnections ($tempString3[0]+".input")`;
	if ($tempString4[0]!="")
		$FKIK=$tempString4[0];
	if (`objExists $FKIK`)
		setAttr ($FKIK+".FKIKBlend") 0;
	}
}

global proc asEditCorrectiveShape (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
//print ("asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" "+$dv+"\n");
float $idv;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
//string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

asGoToCorrectivePose $driverObj $driverAttr $dv;

string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr;
float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
		
if (`objExists $attrCode`)
	warning ("Object "+$attrCode+" already exists");
else
	{
	asCorrectiveDuplicate $attrCode $deformObj;
	addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
	addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;
	}
//asGoToBuildPose bodySetup;
//eval($restorePoseCmd);
autoKeyframe -state $autoKeyframe;
dgdirty -a;
}

global proc asBakeIntoCorrectiveShapes ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl`;
string $source=`textField -q -tx asBakeToCorrective1TextField`;
string $dest=`textField -q -tx asBakeToCorrective2TextField`;
if ($source=="" || !`objExists $source` || `gmatch $source "*[.]*"`)
	error "Source not valid";
if ($dest=="" || !`objExists $dest` || `gmatch $dest "*[.]*"`)
	error "Destination not valid";
string $tempString[]=`listRelatives -s -ni $source`;
string $sourceShape=$tempString[0];
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
asSetAllFK;
select -cl;
$asSkipConfirm=1;
string $xyz[]={"x","x","y","y","z","z"};
float $rots[]={90,-90,90,-90,90,-90};
for ($i=0;$i<size($sel);$i++)
	{
	print ("// Start checking:"+$sel[$i]+"\n");
	if (!`gmatch $sel[$i] "FK*"`)
		continue;
	if (!`sets -im ControlSet $sel[$i]`)
		continue;
	if (`gmatch $sel[$i] "FKExtra*"`)
		continue;
	if (`gmatch $sel[$i] "FKRoot*"`)
		continue;
	for ($y=0;$y<size($xyz);$y++)
		{
		if ($y==0 && !`checkBox -q -v asBakeX1CheckBox`) continue;
		if ($y==1 && !`checkBox -q -v asBakeX2CheckBox`) continue;
		if ($y==2 && !`checkBox -q -v asBakeY1CheckBox`) continue;
		if ($y==3 && !`checkBox -q -v asBakeY2CheckBox`) continue;
		if ($y==4 && !`checkBox -q -v asBakeZ1CheckBox`) continue;
		if ($y==5 && !`checkBox -q -v asBakeZ2CheckBox`) continue;
		print ("// Baking:"+$sel[$i]+".r"+$xyz[$y]+"="+$rots[$y]+"\n");
		setAttr ($sel[$i]+".r"+$xyz[$y]) $rots[$y];
		refresh;
		select $dest;
		$corrective=`asCreateCorrectiveShape`;
		$tempString=`listRelatives -s -ni $corrective`;
		$correctiveShape=$tempString[0];
		connectAttr -f ($sourceShape+".outMesh") ($correctiveShape+".inMesh");
		asConnectCorrectiveShape;
		setAttr ($sel[$i]+".r"+$xyz[$y]) 0;
		}
	}
$asSkipConfirm=0;
eval($restorePoseCmd);
select $sel;
}

global proc string asGetRestorePoseCmd ()
{
string $restorePoseCmd;
string $controlSetMembers[];
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	string $faceControlSetMembers[]=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $faceControlSetMembers`;
	}
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	string $attrs[]=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		if (`getAttr -l ($controlSetMembers[$i]+"."+$attrs[$y])`)
			continue;
		$restorePoseCmd+="setAttr "+$controlSetMembers[$i]+"."+$attrs[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$attrs[$y])`+";";
		}
	}

return $restorePoseCmd;
}

global proc asJointVis (int $onOff)
{
if (!`objExists Main`)
	return;
string $joints[]=`listRelatives -type joint -ad Main`;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asSkinCurvesToWidth ()
{
if (!`objExists SkinCurves2` || !`objExists SkinCurves1`)
	error "SkinCurves not found. Create SkinCage first";
float $pos[],$pos2[];
string $skinCruves1[]=`listConnections SkinCurves1.drawInfo`;
string $skinCruves2[]=`listConnections SkinCurves2.drawInfo`;
string $tempString[];
string $joint,$aboveBelowProfile,$belowProfile,$parentJoint,$parentTarget;
for ($i=0;$i<size($skinCruves1);$i++)
	{
	tokenize $skinCruves1[$i] "_" $tempString;
	$joint="";
	for ($y=0;$y<size($tempString)-1;$y++)
		{
		$joint+=$tempString[$y];
		if ($y<size($tempString)-2)
			$joint+="_";
		}
	if (!`objExists $joint`)
		continue;
	$tempString=`listRelatives -type joint -p $joint`;
	while (`gmatch $tempString[0] "*Part[0-9]*"`)
		$tempString=`listRelatives -type joint -p $tempString[0]`;
	$parentJoint=$tempString[0];
	if (!`objExists $parentJoint`)
		continue;
	$tempString=`listRelatives -type joint -c $joint`;
	$childJoint=$tempString[0];
	if (!`objExists $childJoint`)
		continue;

	for ($a=0;$a<2;$a++)
		{
		// find profile
		$aboveBelowProfile="";
		if ($a==0)
			{
			if (`objExists ($joint+"_startProfile")`)
				$aboveBelowProfile=$joint+"_startProfile";
			else
				{
				for ($y=20;$y>0;$y--)
					if (`objExists ($parentJoint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$parentJoint+"_twistProfile"+$y;
						break;
						}
				}
			if ($aboveBelowProfile=="")
				continue;
			}
		if ($a==1)
			{
			if (`objExists ($joint+"_endProfile")`)
				$aboveBelowProfile=$joint+"_endProfile";
			else
				{
				for ($y=1;$y<21;$y++)
					if (`objExists ($joint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$joint+"_twistProfile"+$y;
						break;
						}
				}
			}
		if ($aboveBelowProfile=="" || `gmatch $aboveBelowProfile "Neck*"`)//skip neck
			continue;
	
		// place profile
		int $targetIds[2]={0,1};
		$tempString=`listRelatives -p $aboveBelowProfile`;
		string $offsetNode=$tempString[0];
		string $parentConstraint=$offsetNode+"_pointConstraint1";
		string $scaleConstraint=$offsetNode+"_scaleConstraint1";
		string $targetAttrs[]=`listAttr -ud $parentConstraint`;
		setAttr -type float3 ($parentConstraint+".offset") 0 0 0;
		$tempString=`listConnections ($parentConstraint+".target[0].targetParentMatrix")`;
		if ($tempString[0]==`substitute "Profile" $skinCruves1[$i] "Curve"`)
			{
			$targetIds={1,0};
			$tempString=`listConnections ($parentConstraint+".target[1].targetParentMatrix")`;
			if ($tempString[0]=="")
				continue;
			}
		$parentTarget=$tempString[0];
		$pos=`xform -q -ws -t $skinCruves1[$i]`;
		$pos2=`xform -q -ws -t $parentTarget`;
		float $toParentDist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	
		$tempString=`listRelatives -c $skinCruves1[$i]`;
		$innerCurve=$tempString[0];
		$pos=`xform -q -ws -t ($innerCurve+".cv[0]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		float $curveHeight=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		$pos=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[2]")`;
		float $curveWidth=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		float $hwAverage=($curveHeight+$curveWidth)/2.0;
	
		if ($targetAttrs[1]!="")
			{
			float $weight=($hwAverage/2.0)/$toParentDist;
			if ($weight>1)
				$weight=1;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			}
		}
	}
}

global proc asCreateSkinCage ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
softSelect -e -softSelectEnabled 0;
string $tempString[];

if (`objExists MeshGeometry`)
	{
	asRebuildSkinCage;
	return;
	}

createNode -n Cages transform;
parent Cages Geometry;
createNode -n MeshGeometry transform;
parent MeshGeometry Geometry;
setAttr "MeshGeometry.overrideEnabled" 1;
createNode -n MeshCurves transform;
parent MeshCurves Geometry;
createNode -n NurbsGeometry transform;
setAttr NurbsGeometry.v 0;
parent NurbsGeometry Geometry;
sets -em -name SkinCageCurvesSet;
sets -add "Sets" SkinCageCurvesSet;

select -cl;
createDisplayLayer -e -name "SkinCage" -number 1 -nr;
createDisplayLayer -e -name "SkinCurves1" -number 2 -nr;
createDisplayLayer -e -name "SkinCurves2" -number 3 -nr;
setAttr SkinCurves2.visibility 0; setAttr SkinCurves2.displayType 0; setAttr SkinCurves2.color 13;
setAttr SkinCurves1.visibility 1; setAttr SkinCurves1.displayType 0; setAttr SkinCurves1.color 14;
setAttr SkinCage.displayType 2;


//Build tubes
string $topNodes[]=`listRelatives -type joint -c DeformationSystem`;
	asAnalyzeChainJoints $topNodes[0];

//pickup single brancers
string $children[];
$tempString=`asListAllDecents $topNodes[0]`;
for ($i=0;$i<size($tempString);$i++)
	{
	$children=`asListChildren $tempString[$i]`;
	if (size($children)>0)
		if (!`objExists ($tempString[$i]+"_middleCurve")`)
			asBuildChainCurves {$tempString[$i]};
	}

//Branch
asCreateBranchBoxes;

//merge copies.
select `ls -as "*_copy" "*_branch"`;
$tempString=`polyUnite -ch 0 -n skinCage`;
setAttr ($tempString[0]+".keepBorder") 0;
polyMergeVertex -d 0.0001 -am 1 -ch 1 skinCage;
select skinCage;
DeleteHistory;
polyNormal -normalMode 2 -userNormalMode 0 -ch 0 skinCage;
DeleteHistory;
parent skinCage Cages;
editDisplayLayerMembers -noRecurse SkinCage skinCage;
string $middleCurves[]=`ls -type transform "*_middleCurve"`;

//skinn
string $joint,$twistJoint;
select -cl;
for ($i=0;$i<size($middleCurves);$i++)
	{
	$joint=`substitute "_middleCurve" $middleCurves[$i] ""`;
	select -add $joint;
	//include twistJoints
	for ($y=1;$y<99;$y++)
		{
		tokenize $joint "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$y+"_"+$tempString[1];
		if (`objExists $twistJoint`)
			select -add ($twistJoint);
		else
			break;
		}
	//include nonListedParents
	$tempString=`listRelatives -type joint -p $joint`;
	if (size($tempString))
		if (!`objExists ($tempString[0]+"_middleCurve")`)
			if (!`gmatch $tempString[0] "*Part[0-9]*"`)
				select -add $tempString[0];
	//include 50`s
	if (`objExists ($joint+"_50")`)
		select -add ($joint+"_50");
	//deselect endJoints
	$tempString=`listRelatives -type joint -c $joint`;
	if (!`size($tempString)`)
		select -d $joint;
	}
select -add skinCage;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] skinClusterSkinCage;
select -r `listRelatives -c MeshGeometry`;
select `ls -sl -ni "*_poly"`;
select -add skinCage;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
string $cylinders[]=`ls -type transform "*_poly"`;
for ($i=0;$i<size($cylinders);$i++)
	{
	delete `listConnections ($cylinders[$i]+"Shape.inMesh")`;
	setAttr -l 1 ($cylinders[$i]+".v") 0;
	}

//wrap
$cylinders=`ls -type transform "*_poly"`;
select -cl;
deformer -type wrap skinCage;
for ($i=0;$i<size($cylinders);$i++)
	{
	select -r skinCage;
	select -add $cylinders[$i];
	AddWrapInfluence;
	}
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] wrapSkinCage;

reorderDeformers "skinClusterSkinCage" "wrapSkinCage" "skinCage";

//scale profileCurves to markers
float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;
$fitSkeletonJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitSkeletonJoints);$i++)
		{
		$fitSkeletonSide[$i]="_R";
		$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
		if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
			$fitSkeletonSide[$i]="_M";

		$side=$fitSkeletonSide[$i];
		if ($b==-1 && $fitSkeletonSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";

		string $profileCurve=$fitSkeletonJoints[$i]+$side+"_middleProfile";
		if (`objExists $profileCurve`)
			{
			if (!`attributeExists fat $fitSkeletonJoints[$i]`)
				continue;
			float $fat=`getAttr ($fitSkeletonJoints[$i]+$side+".fat")`;
			float $fatY=`getAttr ($fitSkeletonJoints[$i]+$side+".fatY")`;
			float $fatZ=`getAttr ($fitSkeletonJoints[$i]+$side+".fatZ")`;
//			float $sca[3]=`getAttr ($fitSkeletonJoints[$i]+".s")`;
//			setAttr -type float3 ($profileCurve+".s") $sca[0] $sca[1] $sca[2];
//			setAttr ($profileCurve+".sx") $scale;
			setAttr ($profileCurve+".sy") ($fat*$fatY*$scale);
			setAttr ($profileCurve+".sz") ($fat*$fatZ*$scale);
			refresh;
			}
		}

//Profiles tweaks
asProfileTweaks;
print "// SkinCage created\n";
select -cl;
}

global proc asDeleteSkinCage ()
{
string $deleteObjs[]={"skinCage","SkinSub","Cages","MeshGeometry","MeshCurves","NurbsGeometry","SkinCage","SkinCurves1","SkinCurves2","SkinCageCurvesSet"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asRebuildSkinCage ()
{
string $restoreShapesCmds[];
string $profileCurveShapes[]=`ls -type nurbsCurve "*ProfileShape*"`;
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($profileCurveShapes);$i++)
	{
	$form=`getAttr ($profileCurveShapes[$i]+".form")`;
	$spans=`getAttr ($profileCurveShapes[$i]+".spans")`;
	$degrees=`getAttr ($profileCurveShapes[$i]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($profileCurveShapes[$i]+".cv["+$y+"]")`;
		$restoreShapesCmds[size($restoreShapesCmds)]="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$profileCurveShapes[$i]+".cv["+$y+"];";
		}
	}

asDeleteSkinCage;
asCreateSkinCage;
for ($i=0;$i<size($restoreShapesCmds);$i++)
	print ($restoreShapesCmds[$i]+"\n");
for ($i=0;$i<size($restoreShapesCmds);$i++)
	catchQuiet (`eval $restoreShapesCmds[$i]`);
}

global proc asProfileTweaks ()
{
int $cvs[],$oppositeCvs[];
string $heelFitJoint;
string $tempString[];
string $ankleProfileEnds[]=`ls -type transform "*Ankle*_*endProfile"`;
for ($i=0;$i<size($ankleProfileEnds);$i++)
	{
	string $ankle=`substitute "_endProfile" $ankleProfileEnds[$i] ""`;
	int $numChar=size($ankle);
	string $fitAnkle=`substring $ankle 1 ($numChar-2)`;
	string $side=`substring $ankle ($numChar-1) 99`;
	int $b=1;
	if ($side=="_L") $b=-1;
	$heelFitJoint="";
	$tempString=`listRelatives -c -type joint $fitAnkle`;
	for ($y=0;$y<size($tempString);$y++)
		{
		string $label=`asLabel $tempString[$y]`;
		if (`gmatch $label "*Heel*"`)
			$heelFitJoint=$tempString[$y];
		}
	if ($heelFitJoint=="")
		continue;
	float $anklePos[]=`xform -q -ws -t $ankleProfileEnds[$i]`;
	float $heelPos[]=`xform -q -ws -t $heelFitJoint`;
	if (`gmatch $ankleProfileEnds[$i] "*_R_*"`)
		$cvs={0,1,4};
	else
		$cvs={2,3};
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -os -t ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t ($heelPos[0]*$b) $heelPos[1] $heelPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		move -r -os 0 0 $existingPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $anklePos[0] $anklePos[1] $anklePos[2] 1.2 1.2 1 ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		}
	}
string $toeProfileMiddle[]=`ls -type transform "*Toes*Profile"`;
for ($i=0;$i<size($toeProfileMiddle);$i++)
	{
	$transformPos=`xform -q -ws -t $toeProfileMiddle[$i]`;
	if (`gmatch $toeProfileMiddle[$i] "*_R_*"`)
		{$cvs={0,1,4};$oppositeCvs={2,3};}
	else
		{$cvs={2,3};$oppositeCvs={0,1,4};}
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t $existingPos[0] 0 $existingPos[2] ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 1.2 1.2 1 ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]"); 
		}
	for ($y=0;$y<size($oppositeCvs);$y++)
		{
		if (`gmatch $toeProfileMiddle[$i] "*_start*"`)
			scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 0.5 0.5 1 ($toeProfileMiddle[$i]+".cv["+$oppositeCvs[$y]+"]"); 
		}
	}
}

global proc asCreateSliders ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";

if (`objExists closestSampler`)
	delete closestSampler;
if (!`objExists SlideSystem`)
	createNode -n SlideSystem -p MotionSystem transform;

int $sideFactor=1;
int $vtxNr[];
int $bendAxis;
string $tempString[],$branchVtxs[],$branchVtxSliderNrs[];
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*_L_*"`)
		$sideFactor=-1;
	else
		$sideFactor=1;

	$bendAxis=0;//all directions
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];

	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -type joint -p $parent`;
		$parent=$tempString[0];
		}
	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $firstPa=$tempString[0];

	if ($skinCurveSliderInfo[1]=="")
		{
		print ("// Skipping "+$sel[$i]+", as it`s not defining start or end or middle of deformation\n");
		continue;
		}
	string $stEnMid=$skinCurveSliderInfo[1];
	if (`objExists ($deformJoint+"_"+$stEnMid+"Slider0")` || `objExists ($deformJoint+"_"+$stEnMid+"Slider1")`)
		continue;

	createNode -n messureTemp transform;
	pointConstraint $sel[$i] messureTemp;
	parent messureTemp $firstPa;
	if ($skinCurveSliderInfo[1]=="end")
		parent messureTemp $deformJoint;
	float $xOffset=`getAttr messureTemp.tx`;
	delete messureTemp;

	//create the 50joint
	int $baseStrucExists=0;
	if (`objExists ($deformJoint+"_Slide50")`)
		$baseStrucExists=1;
	if (!$baseStrucExists)
		{
		select $deformJoint;
		joint -n ($deformJoint+"_Slide50");
		setAttr ($deformJoint+"_Slide50.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide50") $firstPa;
		createNode -n ($deformJoint+"_Slide00") transform;
		parent ($deformJoint+"_Slide00") $deformJoint;
		setAttr -type float3 ($deformJoint+"_Slide00.t") 0 0 0;
		setAttr -type float3 ($deformJoint+"_Slide00.r") 0 0 0;
		setAttr ($deformJoint+"_Slide00.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide00") $firstPa;
		$tempString=`orientConstraint ($deformJoint+"_Slide00") $deformJoint ($deformJoint+"_Slide50")`;
//		setAttr ($tempString[0]+".interpType") 2; //`shortest` seem to be stable
//	shortest works best on elbow that has twists
		$tempString=`pointConstraint $deformJoint ($deformJoint+"_Slide50")`;
		setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
		}

	//only 2 for elbow/knee, determine $bendAxis
	if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
		{
		float $jo[]=`getAttr ($deformJoint+".jointOrient")`; // check jointOrient to find bend axis
		if (abs($jo[1])>abs($jo[2])) $bendAxis=1;// .joY greater than .joZ, so not a Zbender
		if (abs($jo[2])>abs($jo[1])) $bendAxis=2;// .joZ greater than .joY, so not a Ybender
		}

	for ($y=0;$y<4;$y++)
		{
		//only 2 for elbow/knee, determine $bendAxis
		if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
			{
			if ($bendAxis==1) if ($y==0 || $y==2) continue;
			if ($bendAxis==2) if ($y==1 || $y==3) continue;
			}
		if ($skinCurveSliderInfo[1]=="start") select $firstPa;
		if ($skinCurveSliderInfo[1]=="middle") select ($deformJoint+"_Slide50");
		if ($skinCurveSliderInfo[1]=="end") select $deformJoint;
		joint -n ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		sets -add ("DeformSet") ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		float $posA[3]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		float $posB[3]=`xform -q -ws -t ($sel[$i]+".cv["+($y+1)+"]")`;
		float $pos[3]={(($posA[0]+$posB[0])/2.0), (($posA[1]+$posB[1])/2.0), (($posA[2]+$posB[2])/2.0)};
		xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_"+$stEnMid+"Slider"+$y);

		if (!$baseStrucExists)
			{
			// recylcle these between starters, enders, and middlers
			createNode -n ($deformJoint+"_SlideDist"+$y) distanceBetween	;
			createNode -n ($deformJoint+"_SlideStart"+$y) transform;
			createNode -n ($deformJoint+"_SlideEnd"+$y) transform;
//			connectAttr -f ($deformJoint+"_SlideStart"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point1");
			connectAttr -f ($deformJoint+"_SlideEnd"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point2");
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideStart"+$y);
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideEnd"+$y);
//			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
//			setAttr -type float3 ($deformJoint+"_SlideEnd"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
			parent ($deformJoint+"_SlideStart"+$y) $firstPa;
			parent ($deformJoint+"_SlideEnd"+$y) $firstPa;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideStart"+$y);
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideEnd"+$y);		
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_Slide50");
			setAttr ($deformJoint+"_SlideEnd"+$y+".tx") 0;
			float $temp[3]=`getAttr ($deformJoint+"_SlideEnd"+$y+".t")`;
			float $mag=`mag <<$temp[0],$temp[1],$temp[2]>>`*$sideFactor;
			$temp[0]=`getAttr ($deformJoint+".tx")`;
			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".t") ($temp[0]-$mag) 0 0;
			parent ($deformJoint+"_SlideStart"+$y) SlideSystem;
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo $firstPa ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo ($deformJoint+"_Slide50") ($deformJoint+"_SlideEnd"+$y);
			//behaviour
			createNode -n ($deformJoint+"_SlideDistNormalize"+$y) multiplyDivide;
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDist"+$y+".distance") ($deformJoint+"_SlideDistNormalize"+$y+".input1X");
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".input2X") `getAttr ($deformJoint+"_SlideDistNormalize"+$y+".input1X")`;
			}

		//they all share `_SlideMultiply` & `SlideReducer` & `_SlidePlusOffset`
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
		setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") 0.3;
		if ($skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") -0.3;
		//on opposide side, the start and end must move opposite direction
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") (`getAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X")`*$sideFactor);
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y) multiplyDivide;
		addAttr -k 1 -ln slide -at double -dv 1 ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		connectAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".slide") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input2X");
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input1X");
		createNode -n ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y) plusMinusAverage;
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[0]");
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			{
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y) plusMinusAverage;
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[0]");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[1]") 1;

			connectAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") $xOffset;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".tx");
			}
		if ($skinCurveSliderInfo[1]=="middle")
			{
			string $slideAxis="z";
			if ($bendAxis==2)
				$slideAxis="y";
			if (($bendAxis==0) && ($y==0 || $y==2))
				$slideAxis="y";
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y) reverse;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".inputX");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y) condition;
			if (`getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`>0)
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 4;
			else
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 2;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".firstTerm");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfFalseR");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y) multiplyDivide;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input2X") -1;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfTrueR");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".outColorR") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");

			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") `getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis);

			}

		//skinning
		skinCluster -e -lw false -wt 0 -ai ($deformJoint+"_"+$stEnMid+"Slider"+$y) skinClusterSkinCage;
		float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$y) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
		if ($bendAxis==0) //all directions
			{
			if ($y>0) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+($y-1)) 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
			if ($y==3) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider3") 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[0]+"]");
			}
		if (($bendAxis==1 && $y==3) || ($bendAxis==2 && $y==2)) //last loop for Z or Ybender
			{
			int $pickupVtx=2;
			int $sliderNr=1;
			if ($bendAxis==2) {$pickupVtx=1;$sliderNr=0;}
			float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			$pickupVtx=4;
			$sliderNr=3;
			if ($bendAxis==2) {$pickupVtx=3;$sliderNr=2;}
			$temp=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			}
		}

	//branchVtx`s edgeloopCheck to see if there`s a extra vtx, if so.. this is a `brancher`
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	$branchVtxSliderNrs=`asGetBranchedVtx $tempString 1`;
	for ($y=0;$y<size($branchVtxs);$y++)
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$branchVtxSliderNrs[$y]) 1 skinClusterSkinCage $branchVtxs[$y];
	}

if (`objExists closestSampler`)
	delete closestSampler;
print "// Sliders created\n";
select $sel;
}

global proc string[] asGetBranchedVtx (string $inputVtxs[], int $vertsOrSliderNr)
{
string $return[],$branchVtxs[],$branchVtxSliderNrs[];
string $connectVtx0s[],$connectVtx1s[],$connectVtx2s[],$connectVtx3s[];
for ($y=0;$y<4;$y++)
	{
	select $inputVtxs[$y];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $inputVtxs[$y];
	$tempString=`ls -sl -fl`;
	if ($y==0) $connectVtx0s=$tempString;
	if ($y==1) $connectVtx1s=$tempString;
	if ($y==2) $connectVtx2s=$tempString;
	if ($y==3) $connectVtx3s=$tempString;
	}
for ($y=0;$y<size($connectVtx0s);$y++) {
	if (`stringArrayCount $connectVtx0s[$y] $connectVtx1s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=0;}
if (`stringArrayCount $connectVtx0s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=3;}}
for ($y=0;$y<size($connectVtx1s);$y++)
	if (`stringArrayCount $connectVtx1s[$y] $connectVtx2s`) {$branchVtxs[size($branchVtxs)]=$connectVtx1s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=1;}
for ($y=0;$y<size($connectVtx2s);$y++)
	if (`stringArrayCount $connectVtx2s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx2s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=2;}
if ($vertsOrSliderNr)
	$return=$branchVtxSliderNrs;
else
	$return=$branchVtxs;
return $return;
}

global proc asDeleteSliders ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
string $tempString[];
int $vtxNr[];
for ($i=0;$i<size($sel);$i++)
	{
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];
	int $haveSliderJoint[4];
	for ($y=0;$y<4;$y++)
		{
		//skinning
		float $pos[]=`xform -q -ws -t $sel[$i]`;
		createNode -n closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker1;
		$pos=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		createNode -n closestSamplerShrinker2 -p closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker2;
		$pos=`xform -q -ws -t closestSamplerShrinker2`;
		scale -r 0.832 0.832 0.832 closestSamplerShrinker1;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		delete closestSamplerShrinker1;
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		}
	//$branchVtxs
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	for ($y=0;$y<size($branchVtxs);$y++)
		{
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage $branchVtxs[$y];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage $branchVtxs[$y];
		}
	//delete the joint
	for ($y=0;$y<4;$y++)
		if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
			delete ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y);

	//remove 50 system, if no longer required
	int $remove50=0;
	if (!`objExists ($skinCurveSliderInfo[0]+"_SlideDistNormalize1")`)
		{
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide50")`)
			delete ($skinCurveSliderInfo[0]+"_Slide50");
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide00")`)
			delete ($skinCurveSliderInfo[0]+"_Slide00");
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y)`)
				delete ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y);
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
select -cl;
}

global proc string asListParent (string $obj)
{
string $tempString[]=`listRelatives -type joint -p $obj`;
if (`attributeExists Scapula $tempString[0]`)
	$tempString=`listRelatives -type joint -p $tempString[0]`;
return $tempString[0];
}

global proc string[] asListChildren (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -c $obj`;
string $tempString2[];
string $skips[]={"Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	if (`attributeExists Scapula $tempString[$i]`)
		$skip=1;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempString[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skipChildrenToo=1;
	if (`attributeExists noMiddleCurve $tempString[$i]`)
		{
		$skip=1;
		$skipChildrenToo=1;
		}
	if ($skip)
		{
		if (!$skipChildrenToo)
			{
			$tempString2=`listRelatives -type joint -c $tempString[$i]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$skip=0;
				for ($y=0;$y<size($skips);$y++)
					if (`gmatch $tempString2[$z] ("*"+$skips[$y]+"*")`)
						$skip=1;
				if (!$skip)
					$result[size($result)]=$tempString2[$z];
				}
			}
		}
	else
		if ($tempString[$i]!="")
			$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc string[] asListAllDecents (string $obj)
{
int $skip,$skipChildrenToo;
string $result[];
string $tempString[]=`listRelatives -type joint -ad $obj`;
string $tempStringFullPath[]=`listRelatives -type joint -ad -f $obj`;
string $skips[]={"Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_","Jaw_","Eye_","_50","Float","Part[0-9]_","Part[0-9][0-9]_"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	if (`attributeExists Scapula $tempString[$i]`)
		$skip=1;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempStringFullPath[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skip=1;
	if (!$skip)
		$result[size($result)]=$tempString[$i];
	}
return $result;
}

global proc asAnalyzeChainJoints (string $firstJoint)
{
string $kids[]=`asListChildren $firstJoint`;
string $chainJoints[],$tempString[];
clear $chainJoints;
float $pos[3];

//If $firstJoint is "*Part[0-9]*", then downscan until solid firstJoint
if (`gmatch $firstJoint "*Part[0-9]*"`)
	{
	string $child=$firstJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`asListChildren $child`;
		$child=$tempString[0];
		if (!`gmatch $child "*Part[0-9]*"`)
			break;
		}
	$firstJoint=$child;
	clear $kids;
	$kids=`asListChildren $firstJoint`;
	}


while(size($kids)==1)
	{
	if (size($chainJoints)==0)
		$chainJoints[size($chainJoints)]=$firstJoint;
	if (!`gmatch $kids[0] "*Part[0-9]*"`)
		$chainJoints[size($chainJoints)]=$kids[0];
	$tempString=`asListChildren $kids[0]`;
	clear $kids;
	for ($y=0;$y<size($tempString);$y++)
			$kids[size($kids)]=$tempString[$y];
	}

if (size($kids)>1)
	for ($y=0;$y<size($kids);$y++)
		asAnalyzeChainJoints $kids[$y];

if (size($chainJoints))
	if (!`objExists ($chainJoints[0]+"_middleCurve")`)
		asBuildChainCurves $chainJoints;
}

global proc asBuildChainCurves (string $chainJoints[])
{
int $childIsTwistJoint;
int $firstChildMinusX[],$spineJoint[],$terminator[],$topJoint[],$downTwist[],$upTwist[];
float $twistAmount;
float $charHeight=`asgetCharHeight`;
string $curve,$startCurve,$endCurve,$twistCurve,$surface,$poly,$parent,$parentChainJoint,$childChainJoint,$twistJoint,$skinToJoint;
string $tempString[],$tempString2[],$children[],$siblings[],$curves[],$startCurves[],$middleCurves[],$endCurves[],$twistCurves[];
float $scale;
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (`gmatch $chainJoints[$i] "Head_M"` || `gmatch $chainJoints[$i] "Hair_M"` || `gmatch $chainJoints[$i] "Root_M"` || `gmatch $chainJoints[$i] "Spine*_M"` || `gmatch $chainJoints[$i] "Chest_M"` || `gmatch $chainJoints[$i] "Tail*_M"`)
		$spineJoint[$i]=1;
	$tempString=`asListChildren $chainJoints[$i]`;
	if (size($tempString))
		if (`getAttr ($tempString[0]+".tx")`<0)
			$firstChildMinusX[$i]=1;
	if (size($tempString)==0)
		$terminator[$i]=1;
	if (`asListParent $chainJoints[$i]`=="")
		$topJoint[$i]=1;
	}

//Middlecurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$middleCurve=$chainJoints[$i]+"_middleCurve";
	$middleCurves[size($middleCurves)]=$middleCurve;
	asCreateMeshCurve $middleCurve;
	$profileCurve=`substitute "Curve" $middleCurve "Profile"`;
	$scale=$charHeight/40;
	if (`gmatch $chainJoints[$i] "Wrist_*"`)
		$scale=$charHeight/80;
	if (`gmatch $chainJoints[$i] "Elbow_*"`)
		$scale=$charHeight/60;
	if (`gmatch $chainJoints[$i] "*Finger*"`)
		$scale=$charHeight/140;
	if ($spineJoint[$i])
		$scale=$charHeight/15;
	xform -os -s $scale $scale $scale $profileCurve;

	asAlign $profileCurve $chainJoints[$i] 1 1 0 0;
	if ($terminator[$i])
		asAlign $profileCurve `asListParent $chainJoints[$i]` 0 1 0 0;
	parent $profileCurve MeshCurves;
	editDisplayLayerMembers -noRecurse SkinCurves1 $profileCurve;
	refresh;
	}

//Twistcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$childIsTwistJoint=1;
	$joint=$chainJoints[$i];
	while($childIsTwistJoint)
		{
		$childIsTwistJoint=0;
		$tempString=`asListChildren $joint`;
		$twistJoint=$tempString[0];
		$joint=$twistJoint;
		if (`gmatch $joint "*Part[0-9]*"`)
			$childIsTwistJoint=1;
		else
			break;
		if ($childIsTwistJoint)
			{
			$downTwist[$i]=$downTwist[$i]+1;
			$twistCurve=$chainJoints[$i]+"_twistCurve"+$downTwist[$i];
			$twistCurves[size($twistCurves)]=$twistCurve;
			asCreateMeshCurve $twistCurve;
			$profileCurve=`substitute "Curve" $twistCurve "Profile"`;
			createNode -n ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") transform;
			parent ($chainJoints[$i]+"_twistProfile"+$downTwist[$i]) ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			parent ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") MeshCurves;
			editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
			asAlign ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") $twistJoint 1 1 0 0;
			$twistAmount=0.5;
			if (`attributeExists twistAmount $twistJoint`)
				$twistAmount=`getAttr ($twistJoint+".twistAmount")`*0.8;
			pointConstraint -mo -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			pointConstraint -mo -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			}
		}
	if ($i>0 && $downTwist[$i-1])
		$upTwist[$i]=$downTwist[$i-1];
	}

//Startcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		$startCurve=$chainJoints[$i]+"_startCurve";
		$startCurves[size($startCurves)]=$startCurve;
		asCreateMeshCurve $startCurve;
		$profileCurve=`substitute "Curve" $startCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_startCurveOffset") transform;
		parent ($chainJoints[$i]+"_startProfile") ($chainJoints[$i]+"_startCurveOffset");
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_startCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		//first startCurve
		if ($i==0)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_startProfile.tx") 0.482;
			else
				setAttr ($chainJoints[$i]+"_startProfile.tx") -0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		if ($i>0)
			{
			pointConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			}
		}
	}

//Endcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		$endCurve=$chainJoints[$i]+"_endCurve";
		$endCurves[size($endCurves)]=$endCurve;
		asCreateMeshCurve $endCurve;
		$profileCurve=`substitute "Curve" $endCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_endCurveOffset") transform;
		parent ($chainJoints[$i]+"_endProfile") ($chainJoints[$i]+"_endCurveOffset");
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_endCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		//last endCurve
		if ($i==size($chainJoints)-1)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_endProfile.tx") -0.482;
			else
				setAttr ($chainJoints[$i]+"_endProfile.tx") 0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		if ($i<size($chainJoints)-1)
			{
			pointConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			}
		}
	}

for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_startCurve";
	$curves[size($curves)]=$chainJoints[$i]+"_middleCurve";
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_endCurve";
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		$curves[size($curves)]=$chainJoints[$i]+"_twistCurve"+$y;


	//branch
	$children=`asListChildren $chainJoints[$i]`;
	$tempString[0]=`asListParent $chainJoints[$i]`;
	$parent=$tempString[0];
	if ($parent!="")
		$siblings=`asListChildren $parent`;
	if (!(size($children)>1 || size($siblings)>1))
		continue;
	}

$surface=$chainJoints[0]+"_surface";
$poly=$chainJoints[0]+"_poly";
if (size($chainJoints)==1)
		extrude -n $surface -ch 1 -rn false -po 0 -et 0 -upn 1 -length ($charHeight/-250) -rotation 0 -scale 1 -dl 3 $curves;
else
	loft -n $surface -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true $curves;
parent $surface NurbsGeometry;
nurbsToPoly -n $poly -mnd 1 -ch 1 -f 3 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0 -es 0 -ntr 0 -mrt 0 -uss 1 $surface;
polySoftEdge -angle 0 -ch 1 $poly;
if (`gmatch $chainJoints[0] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $poly;
//polyMergeVertex -d 0.01 -am 1 -ch 1 $poly;
polyMergeVertex -d 0.0001 -am 1 -ch 1 $poly;
//displaySmoothness -polygonObject 3;
duplicate -n ($poly+"_copy") $poly;
parent $poly MeshGeometry;

//Create SkinCluster
select $chainJoints;
//include parentJoint
$tempString=`listRelatives -type joint -p $chainJoints[0]`;
if (size($tempString))
	select -add $tempString[0];
//deselect endJoints
for ($i=0;$i<size($chainJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
	if (!`size($tempString)`)
		select -d $chainJoints[$i];
	}
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -type joint -c $tempString[$i]`;
	if (size($tempString2))
		select -add $tempString[$i];
	}
//include twistJoints
for ($i=0;$i<size($chainJoints);$i++)
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		select -add ($tempString[0]+"Part"+$y+"_"+$tempString[1]);
		}
//include 50`s
for ($i=0;$i<size($chainJoints);$i++)
	if (`objExists ($chainJoints[$i]+"_50")`)
		select -add ($chainJoints[$i]+"_50");
select -add $poly;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

float $temp[3];
int $vertIndex;
if (`objExists closestSampler`)
	delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($poly+"Shape.outMesh") closestSampler.inMesh;
$tempString=`listConnections ($poly+"Shape.inMesh")`;
string $skinCluster=$tempString[0];

//Skinning cylinders
for ($i=0;$i<size($chainJoints);$i++)
	{
	//Middlecurves
	for ($y=0;$y<4;$y++)
		{
		$temp=`xform -q -ws -t ($chainJoints[$i]+"_middleCurve.cv["+$y+"]")`;
		setAttr closestSampler.inPositionX $temp[0];
		setAttr closestSampler.inPositionY $temp[1];
		setAttr closestSampler.inPositionZ $temp[2];
		$vertIndex=`getAttr closestSampler.closestVertexIndex`;
		$skinToJoint=$chainJoints[$i];
		$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
		if (!`size($tempString)`)
			{
			$tempString2=`listRelatives -type joint -p $chainJoints[$i]`;
			if (`size($tempString2)`)
				$skinToJoint=$tempString2[0];
			}

		skinPercent -tv $skinToJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		$tempString=`listRelatives -type joint -p $chainJoints[$i]`;
		if (!$spineJoint[$i])
			if (size($tempString))
				if ($skinToJoint==$chainJoints[$i])
					skinPercent -tv $tempString[0] 0.5 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		if (`objExists ($chainJoints[$i]+"_50")`)
			skinPercent -tv ($chainJoints[$i]+"_50") 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
		}

	//Twistcurves
	for ($z=1;$z<$downTwist[$i]+1;$z++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$z+"_"+$tempString[1];
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_twistCurve"+$z+".cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $twistJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}

		}

	//Startcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$topJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_startCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			if ($i>0)
				skinPercent -tv $chainJoints[$i-1] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			else
				{
				$tempString=`listRelatives -type joint -p $chainJoints[0]`;
				skinPercent -tv $tempString[0] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
				}
			}
		}
	//Endcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_endCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $chainJoints[$i] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}
		}
	}
if (size($children)==0)
	{
	$endJoint=$chainJoints[size($chainJoints)-1];
	polyPlane -n ($endJoint+"_cap_copy") -w 1 -h 1 -sx 1 -sy 1 -ax 1 0 0 -cuv 2 -ch 0;
	if (`gmatch $endJoint "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($endJoint+"_cap_copy");
	setAttr -type float3 ($endJoint+"_cap_copy.s") ($scale*2*(1/1.2)) ($scale*2*(1/1.2)) ($scale*2*(1/1.2));
	asAlign ($endJoint+"_cap_copy") $endJoint 1 1 0 0;
	asAlign ($endJoint+"_cap_copy") `asListParent $endJoint` 0 1 0 0;
	}
}

global proc asCreateMeshCurve (string $curve)
{
$tempString[0]=`curve -d 1 -p 0 -1 1 -p 0 1 1 -p 0 1 -1 -p 0 -1 -1 -p 0 -1 1`;
rename $tempString[0] $curve;
reverseCurve -ch 0 -rpo 1 $curve;
$profileCurve=`substitute "Curve" $curve "Profile"`;
duplicate -n $profileCurve $curve;
sets -add SkinCageCurvesSet $profileCurve;
scale -r 1.2 1.2 1.2 $profileCurve;
parent $curve $profileCurve;
connectAttr ($profileCurve+".worldSpace[0]") ($curve+".create");
setAttr ($curve+".v") 0;
}

global proc asCreateBranchBoxes ()
{
int $sortedNr[],$closestParentCvs[],$closestChildCvs[],$furthestParentCvs[],$furthestChildCvs[];
int $tempInt;
string $parentCurve,$firstChild,$nextChild,$polyCreateFacetCmd;
string $tempString[],$tempString2[],$children[],$childrenCurves[],$sortedChildren[];
float $minX,$maxX,$minY,$maxY,$minZ,$maxZ,$min,$dist;
float $pos[3],$pos2[3],$childPos[3],$deltaPos[3],$spreadMostVector[3],$cubePos[3],$temp[3],$temp2[3];
float $Xs[],$Ys[],$Zs[],$sortValues[];
string $joints[]=`asListAllDecents DeformationSystem`;

for ($i=0;$i<size($joints);$i++)
	{
	$tempString=`asListChildren $joints[$i]`;
	if (size($tempString)<2) // branching only with 2 or more children
		continue;

	//find $children
	clear $children;
	clear $sortedChildren;
	clear $childrenCurves;
	for ($y=0;$y<size($tempString);$y++) // child with no child of it`s own, is not a branch
		{
		$tempString2=`asListChildren $tempString[$y]`;
		if (size($tempString2))
			$children[size($children)]=$tempString[$y];
		}

	if (size($children)<2) // branching only with 2 or more children (check again, now that `false` children has been removed)
		continue;

	//For the Root, pick the first *_M child as parent, and drop it as child
	string $rootParent="";
	if ($joints[$i]=="Root_M")
		{
		for ($y=0;$y<size($children);$y++)
			if (`gmatch $children[$y] "*_M"`)
				$rootParent=$children[$y];
		if ($rootParent=="")
			$rootParent=$children[0];
		if (`gmatch $rootParent "*Part[0-9]_M"`)
			{
			//Find first non-*Part[0-9]
			string $child=$rootParent;
			for ($y=0;$y<99;$y++)
				{
				$tempString=`listRelatives -c -type joint $child`;
				$child=$tempString[0];
				if (!`gmatch $child "*Part[0-9]*"`)
					break;
				}
			$children=`stringArrayRemove {$rootParent} $children`;
			$rootParent=$child;
			$children[size($children)]=$child;
			}
		$children=`stringArrayRemove {$rootParent} $children`;
		}

	//find $spreadMostVector
	$minX=99;$minY=99;$minZ=99;
	$maxX=-99;$maxY=-99;$maxZ=-99;
	for ($y=0;$y<size($children);$y++)
		{
		$temp=`xform -q -ws -t $children[$y]`;
		if ($temp[0]<$minX) $minX=$temp[0];
		if ($temp[0]>$maxX) $maxX=$temp[0];
		if ($temp[1]<$minY) $minY=$temp[1];
		if ($temp[1]>$maxY) $maxY=$temp[1];
		if ($temp[2]<$minZ) $minZ=$temp[2];
		if ($temp[2]>$maxZ) $maxZ=$temp[2];
		}
	$xDif=$maxX-$minX;$yDif=$maxY-$minY;$zDif=$maxZ-$minZ;
	if ($xDif>$yDif && $xDif>$zDif) $spreadMostVector={1,0,0}; //e.g. chest/root
	if ($yDif>$xDif && $yDif>$zDif) $spreadMostVector={0,1,0}; //e.g. dinospikes (could be chest if neck.ty>shoulder.tx
	if ($zDif>$xDif && $zDif>$yDif) $spreadMostVector={0,0,1}; //e.g. wrist

	//sort children (by distance between themselves)
	for ($y=0;$y<size($children);$y++)
		{
		$temp=`xform -q -ws -t $children[$y]`;
		$Xs[$y]=$temp[0];$Ys[$y]=$temp[1];$Zs[$y]=$temp[2];
		}
	$min=999;
	if ($spreadMostVector[0]) $sortValues=$Xs;
	if ($spreadMostVector[1]) $sortValues=$Ys;
	if ($spreadMostVector[2]) $sortValues=$Zs;
	for ($y=0;$y<size($children);$y++)
		if ($sortValues[$y]<$min)
			{
			$firstChild=$children[$y];
			$min=$sortValues[$y];
			}
	$sortedChildren[0]=$firstChild;
	$nextChild=$firstChild;
	for ($a=0;$a<size($children);$a++)
		{
		$min=999;
		$checkChild=$nextChild;
		$pos=`xform -q -ws -t $checkChild`;
		for ($y=0;$y<size($children);$y++)
			{
			if ($children[$y]==$checkChild || `stringArrayCount $children[$y] $sortedChildren`)
				continue;
			$dist=`mag<<$Xs[$y]-$pos[0],$Ys[$y]-$pos[1],$Zs[$y]-$pos[2]>>`;
			if ($dist<$min)
				{
				$nextChild=$children[$y];
				$min=$dist;
				}
			}
		if(!`stringArrayCount $nextChild $sortedChildren`)
			$sortedChildren[size($sortedChildren)]=$nextChild;
		}

	//find $parentCurve
	$parentCurve=$joints[$i]+"_middleCurve";
	if (`objExists ($joints[$i]+"_endCurve")`)
		$parentCurve=($joints[$i]+"_endCurve");
//		$parentCurve=($joints[$i]+"_middleCurve");
	if ($joints[$i]=="Root_M")
		$parentCurve=$rootParent+"_middleCurve";

	//find $childrenCurves
	for ($y=0;$y<size($sortedChildren);$y++)
		{
		if (`objExists ($sortedChildren[$y]+"_startCurve")`)
			$childrenCurves[$y]=$sortedChildren[$y]+"_startCurve";
		else if (`objExists ($sortedChildren[$y]+"_middleCurve")`)
			$childrenCurves[$y]=$sortedChildren[$y]+"_middleCurve";
		}

	//aimed $childrenCurves
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		duplicate -n ($childrenCurves[$y]+"TempAimed") $childrenCurves[$y];
		parent -w ($childrenCurves[$y]+"TempAimed");
		float $aimVec[]={-1,0,0};
		if (`gmatch $sortedChildren[$y] "*_L"`)
			$aimVec={1,0,0};
		string $aimAt=$joints[$i];
		if ($joints[$i]=="Root_M")
			$aimAt=$parentCurve;
		$tempString=`aimConstraint -aimVector $aimVec[0] $aimVec[1] $aimVec[2] -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $childrenCurves[$y] $aimAt ($childrenCurves[$y]+"TempAimed")`;
		delete $tempString[0];
		}

	//Find $closestCVS
	$min=999;
	for ($a=0;$a<4;$a++)
		{
		$pos=`xform -q -ws -t ($parentCurve+".cv["+$a+"]")`;
		for ($b=0;$b<4;$b++)
			{
			$pos2=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$b+"]")`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			if ($dist<$min)
				{
				$closestParentCvs[0]=$a;
				$closestChildCvs[0]=$b;
				$min=$dist;
				}
			}
		}
	//Find second $closestCVS
	$min=999;
	for ($a=0;$a<4;$a++)
		{
		if($a==$closestParentCvs[0])
			continue;
		$pos=`xform -q -ws -t ($parentCurve+".cv["+$a+"]")`;
		for ($b=0;$b<4;$b++)
			{
			if ($b==$closestChildCvs[0])
				continue;
			$pos2=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$b+"]")`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			if ($dist<$min)
				{
				$closestParentCvs[1]=$a;
				$closestChildCvs[1]=$b;
				$min=$dist;
				}
			}
		}

	//sideFace1
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$pos2=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$pos3=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
	$pos4=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchStart -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $sortedChildren[0] "*_L"` && `gmatch $joints[$i] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchStart");

	//child2childFace`s
	int $childACv[]=`asCvFlip $closestChildCvs`;
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		$pos3=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos4=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		if (`gmatch $sortedChildren[$y+1] "*_L"` && !`gmatch $sortedChildren[$y] "*_L"`)//first `mirrored`
			{
			$pos3=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
			$pos4=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
			}
		$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branch"+$y+" -ch 0 -tx 1 -s 1";
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
		$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
		eval ($polyCreateFacetCmd);
		if (`gmatch $sortedChildren[$y] "*_L"` && `gmatch $joints[$i] "*_L"`)
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branch"+$y);
		}

	//sideFace2
	int $childACv2[]=`asCvFlip $closestParentCvs`;
	int $lastChildNr=size($childrenCurves)-1;
	$pos1=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[1]+"]")`;
	$pos2=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[0]+"]")`;
	if (`gmatch $sortedChildren[$lastChildNr] "*_L"` && !`gmatch $joints[$i] "*_L"`)//first `mirrored`
		{
		$pos1=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[0]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[1]+"]")`;
		}
	$pos3=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$pos4=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchEnd -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $sortedChildren[$lastChildNr] "*_L"` && `gmatch $joints[$i] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchEnd");

	//backFace n-sided
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchBack -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		if (`gmatch $sortedChildren[$y] "*_L"` && !`gmatch $joints[$i] "*_L"`)//first `mirrored`
			{
			$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
			$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
			}
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);

	//frontFace n-sided
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchFront -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		if (`gmatch $sortedChildren[$y] "*_L"` && !`gmatch $joints[$i] "*_L"`)//first `mirrored`
			{
			$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
			$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
			}
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);
	polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchFront");

	//polyUnite branch-bits
	select ($joints[$i]+"_branchStart") ($joints[$i]+"_branchEnd") ($joints[$i]+"_branchFront") ($joints[$i]+"_branchBack");
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		select -add ($joints[$i]+"_branch"+$y);
	polyUnite -n ($joints[$i]+"_branch") -ch 0 -mergeUVSets 1;

	//wireDeform into place
	wire -n ($joints[$i]+"_branchWire") -dds 0 0.001 -gw false -en 1.0 -ce 0.0 -li 0.0 ($joints[$i]+"_branch");
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		select ($childrenCurves[$y]+"TempAimed");
		select -add ($joints[$i]+"_branch");
		AddWire;
		setAttr ($joints[$i]+"_branchWire.dropoffDistance["+$y+"]") 0.001;
		}
	for ($y=0;$y<size($childrenCurves);$y++)
		orientConstraint $childrenCurves[$y] ($childrenCurves[$y]+"TempAimed");

	//cleanup
	select ($joints[$i]+"_branch");
	DeleteHistory;
	for ($y=0;$y<size($childrenCurves);$y++)
		delete ($childrenCurves[$y]+"TempAimed") ($childrenCurves[$y]+"TempAimedBaseWire");
	}
}

global proc int[] asCvFlip (int $vc[])
{
int $flipCv[]=$vc;
if ($vc[0]==0 && $vc[1]==1) $flipCv={3,2};
if ($vc[0]==1 && $vc[1]==0) $flipCv={2,3};

if ($vc[0]==2 && $vc[1]==3) $flipCv={1,0};
if ($vc[0]==3 && $vc[1]==2) $flipCv={0,1};

if ($vc[0]==1 && $vc[1]==2) $flipCv={0,3};
if ($vc[0]==2 && $vc[1]==1) $flipCv={3,0};

if ($vc[0]==0 && $vc[1]==3) $flipCv={1,2};
if ($vc[0]==3 && $vc[1]==0) $flipCv={2,1};
return $flipCv;
}

global proc asCopySkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinCage`)
	return;
string $sel[]=`ls -sl`;
int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 skinCage`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r skinCage ;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc asHardenWeights ()
{
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
int $hasSkinCluster;
string $maxTransform;
string $tempString[],$history[],$joints[],$transforms[];
float $values[];
string $skinCluster;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s -ni $sel[$i]`;
	if (size($tempString)<1)
		continue;

	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}
	if (!$hasSkinCluster)
		error ("Object:\""+$sel[$i]+"\" has not skinCluster");		
	$joints=`listConnections ($skinCluster+".matrix")`;
	for ($y=0;$y<size($joints);$y++)
		setAttr ($joints[$y]+".lockInfluenceWeights") 0;

	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Hardening Vtx weight" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
		progressBar -e -s 1 $gMainProgressBar;
		$transforms=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
		$values=`skinPercent -ignoreBelow 0.001 -q -v $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
		float $maxValue=0;
		for ($z=0;$z<size($transforms);$z++)
			{
			if ($values[$z]>$maxValue)
				{
				$maxValue=$values[$z];
				$maxTransform=$transforms[$z];
				}
			}
		skinPercent -tv $maxTransform 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
		}
	progressBar -e -ep $gMainProgressBar;
	}
}

global proc asApplyDeltaMush ()
{
string $tempString[];
string $confirmResult,$systemCmd;
string $pluginName="wbDeltaMushDeformer";

string $envVarString=`getenv MAYA_PLUG_IN_PATH`;
string $pluginPaths[];
tokenize $envVarString ";" $pluginPaths;
int $haveASPlugPath=0;
int $useWBDeltaMush=1;
if (`checkBox -q -ex wbDeltaMush`)
	$useWBDeltaMush=`checkBox -q -v wbDeltaMush`;

if (!$useWBDeltaMush)
	{
	deltaMush  -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1 -envelope 1;
	asConnectDeltaMushScale;
	print "// DeltaMush applied\n";
	return;
	}

for ($i=0;$i<size($pluginPaths);$i++)
	{
	if (`gmatch $pluginPaths[$i] "*AdvancedSkeleton5Files*"`) {
		$haveASPlugPath=1;
		break;
		}
	}
if (!$haveASPlugPath)
	asAddModulePath;

if (!`pluginInfo -q -l $pluginName`)
	{
	$confirmResult=`confirmDialog -t Confirm -m "Plugin not loaded" -b "Load now" -b "Cancel" -db "Ok"`;
	if ($confirmResult!="Load now")
		return;
	chdir (`asGetScriptLocation`+"/AdvancedSkeleton5Files/modules/wbDeltaMushDeformer/"
		   +`asMayaVersionAsFloat`+"/plug-ins/");

	loadPlugin $pluginName;
	if (!`pluginInfo -q -l $pluginName`)
		error "Unable to load plugin";
	}
eval ("wbDeltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1");
asConnectDeltaMushScale;

print "// DeltaMush applied\n";
}

global proc asAddModulePath ()
{
global string $gMainProgressBar;
string $tempString[];

string $confirmResult=`confirmDialog -t Confirm -m "wbDeltaMushDeformer not added to MAYA_MODULE_PATH" -b "Add now" -b "Cancel" -db "Ok"`;
if ($confirmResult!="Add now")
	return;
//putenv: for current session
putenv "MAYA_PLUG_IN_PATH"  (`getenv "MAYA_PLUG_IN_PATH"`+";"+`asGetScriptLocation`
							 +"/AdvancedSkeleton5Files/modules/wbDeltaMushDeformer/"
							 +`asMayaVersionAsFloat`+"/plug-ins/");

//setx: for future sessions
string $MPIPfromReg="";
if (`about -win`) // get from registry, as this does not have the auto-added paths from modules
	{
	progressBar -e -st "Adding environment variable" -bp -ii 1 -min 0 -max 3 $gMainProgressBar;
	evalDeferred -lp ("progressBar -e -ep "+$gMainProgressBar);
	
	// add AS_MODULES_PATH whatever it does exist or not
	string $asModulePath = `asGetScriptLocation`+"/AdvancedSkeleton5Files/modules";
	$systemCmd="setx AS_MODULE_PATH "+$asModulePath;
	system ($systemCmd);

	// then we add MAYA_MODULE_PATH
	$systemCmd="reg query HKEY_CURRENT_USER\\Environment /v MAYA_MODULE_PATH";
	$systemReturn=`system ($systemCmd)`;

	if (!`gmatch $systemReturn "*Error*"` && !`gmatch $systemReturn "*ERROR*"`)
		{
		tokenize $systemReturn $tempString;	
		$MPIPfromReg=$tempString[3];
		}
	//string $newMPIP=$MPIPfromReg+";"+`asGetScriptLocation`+"\\AdvancedSkeleton5Files\\modules";
	string $newMPIP=`asGetScriptLocation`+"/AdvancedSkeleton5Files/modules;"+$MPIPfromReg;
	if ($MPIPfromReg!="")
		{
		print "// Found existing paths in MAYA_MODULE_PATH\n";
		print ("// New MAYA_MODULE_PATH="+$newMPIP+"\n");
		}
	$systemCmd="setx MAYA_MODULE_PATH "+$newMPIP;
	print ("// system(\""+$systemCmd+"\")\n");
	system ($systemCmd);
	progressBar -e -ep $gMainProgressBar;
	}
}

global proc asConnectDeltaMushScale ()
{
if (!`objExists Main`)
	return;
string $deltaMushNodes[]=`ls -type deltaMush`;
string $wbDeltaMushNodes[]=`ls -type wbDeltaMush`;
$deltaMushNodes=`stringArrayCatenate $deltaMushNodes $wbDeltaMushNodes`;
for ($i=0;$i<size($deltaMushNodes);$i++)
	{
	if (`isConnected Main.sx ($deltaMushNodes[$i]+".sx")`)
		continue;
	connectAttr Main.sx ($deltaMushNodes[$i]+".sx");
	connectAttr Main.sy ($deltaMushNodes[$i]+".sy");
	connectAttr Main.sz ($deltaMushNodes[$i]+".sz");
	}
}

global proc asWrapExlude ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

string $sel[]=`ls -sl`;
if (!size($sel))
	error "No vertices selected ";
if (!`gmatch $sel[0] "*[.]vtx[[]*"`)
	error "Selection must be  vertices";
string $tempString[]=`listHistory -pdo 1 $sel[0]`;
string $wrapDeformer,$skinCluster;
int $hadSkinCluster=0;
for ($y=0;$y<size($tempString);$y++)
	{
	if (`nodeType $tempString[$y]` == "wrap")
		$wrapDeformer=$tempString[$y];
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
	}
if ($wrapDeformer=="")
	error "No wrap deformer on selected object";

if ($skinCluster=="")
	{
	asCopySkin;
	$tempString=`ls -sl -o`;
	$tempString=`listRelatives -p $tempString[0]`;
	select $tempString[0];
	asSmoothSkin;
	select $sel;
	}
else
	$hadSkinCluster=1;
$tempString=`listHistory -pdo 1 $sel[0]`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
$tempString=`listConnections ($wrapDeformer+".message")`;
string $wrapSet=$tempString[0];
$tempString=`listConnections ($skinCluster+".message")`;
string $skinClusterSet=$tempString[0];
sets -rm $wrapSet;
InvertSelection;
sets -rm $skinClusterSet;
if (!$hadSkinCluster)
	{
	$tempString=`ls -sl -o`;
	select $tempString[0];
	removeUnusedInfluences;
	}
select $sel;
print ("// Selected vertices are now deformed by "+$skinCluster+" instead of wrapDeformer\n");
}

global proc asCreateSkinSub ()
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "\"skinCage\" not found, You must create a skinCage (option2) first.";
if (`objExists skinSub`)
	error "\"skinSub\" already exists.";
if (!`objExists Cages`)
	{
	createNode -n Cages transform;
	parent Cages "Geometry";
	}

createNode -n subWrapPolySmoothProxy polySmoothProxy;
polyCube -n skinSub  -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
parent skinSub Cages;
connectAttr skinCageShape.outMesh subWrapPolySmoothProxy.inputPolymesh;
connectAttr subWrapPolySmoothProxy.output skinSub.inMesh;
select skinSub;
createDisplayLayer -name SkinSub -number 1 -nr;
//setAttr SkinSub.shading 0;
setAttr SkinSub.displayType 2;
setAttr SkinSub.color 30;
setAttr SkinCage.displayType 1;
select $sel;
}

global proc asDeleteSkinSub ()
{
if (`objExists skinSub`)
	delete skinSub;
if (`objExists SkinSub`)
	delete SkinSub;
}

global proc asWrapSkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
if (!`objExists skinSub`)
	error "\"skinSub\" not found, you must create SubWrap first";
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	{
	string $historyNodes[]=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]` == "wrap")
			error ($sel[$i]+" already have wrapDeformer");
	}

if (!`attributeExists wrapDeform Main`)
	{
	addAttr -k 1 -ln "wrapDeform" -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.wrapDeform;
	}
if (!`objExists wrapDeformReverse`)
	{
	createNode -n wrapDeformReverse reverse;
	connectAttr Main.wrapDeform wrapDeformReverse.inputX;
	}
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	select -add skinSub ;
	CreateWrap;
	}
string $wraps[]=`listConnections -type wrap skinSub.worldMesh`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
float $wrapValues[]={0,0,1,0,0};
string $wrap;

for ($i=0;$i<size($wraps);$i++)
	{
	$wrap=`rename $wraps[$i] ("subWrap"+($i+1))`;
	$tempString=`listConnections ($wrap+".outputGeometry")`;
	setAttr ($wrap+".nodeState") 1;
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (`attributeExists $wrapAttrs[$y] $tempString[0]`) //We could be reattaching, so reuse wrapInfo
			$wrapValues[$y]=`getAttr ($tempString[0]+"."+$wrapAttrs[$y])`;
		setAttr ($wrap+"."+$wrapAttrs[$y]) $wrapValues[$y];
		}
	setAttr skinSub.dropoff 4;
	setAttr skinSub.smoothness 0;
	setAttr skinSub.inflType 2;
	connectAttr wrapDeformReverse.output.outputX ($wrap+".nodeState");
	}
select -cl;
}

global proc asSkinSubAttach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinSub`) error "\"skinSub\" not found, you must create SubWrap first";
if (!`objExists skinCage`) error "\"skinCage\" not found, you must create SubWrap first";
if (!`attributeExists subWrapped skinCage`) error "No SubWraps have been detached";
int $numAttach;
string $msh;
string $tempString[];
$tempString[0]=`getAttr skinCage.subWrapped`;
tokenize $tempString[0] ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	$msh=$tempString[$i];
	if (!`objExists $msh`)
		continue;
	select $msh;
	asWrapSkin;
	$numAttach++;
	}
print ("//"+$numAttach+" SubWrap(s) attached");
}

global proc asSkinSubDetach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $subWraps[]=`ls -type wrap "subWrap*"`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
string $tempString[],$tempString2[];
string $msh,$subWrappedString;
for ($i=0;$i<size($subWraps);$i++)
	{
	//store wrapInfo on the meshes they deform.
	$tempString=`listHistory -f 1 ($subWraps[$i]+".outputGeometry")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="mesh")
			{
			$tempString2=`listRelatives -p $tempString[$y]`;
			$msh=$tempString2[0];
			}
	$subWrappedString+=$msh+";";
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (!`attributeExists $wrapAttrs[$y] $msh`) addAttr -ln $wrapAttrs[$y] -at double $msh;
		setAttr ($msh+"."+$wrapAttrs[$y]) `getAttr ($subWraps[$i]+"."+$wrapAttrs[$y])`;
		}
	delete $subWraps;
	print ("//"+`size($subWraps)`+" SubWrap(s) detached");
	}
if (!`attributeExists subWrapped skinCage`)
	addAttr -ln "subWrapped" -dt "string" skinCage;
setAttr -type "string" skinCage.subWrapped $subWrappedString;
}

global proc asSmoothSkin ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
float $pos[];
string $tempString[];
string $smoothJoints[];
if (`objExists Head_M`)
	{
	$tempString=`listRelatives -p Head_M`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$smoothJoints[size($smoothJoints)]=$parent;
		$tempString=`listRelatives -p $parent`;
		$parent=$tempString[0];
		}
	}
string $lookforJoints[]={"Root_M","Hip_R","Hip_L"};
for ($i=0;$i<size($lookforJoints);$i++)
if (`objExists $lookforJoints[$i]`)
	$smoothJoints[size($smoothJoints)]=$lookforJoints[$i];
string $skinCluster;
setToolTo $gSelect;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]` == "skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		error "Found no skinCluster on selected object";
	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Finding Vtx for smoothing" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		for ($z=0;$z<size($smoothJoints);$z++)
			{
			if (`progressBar -q -ic $gMainProgressBar`)
				{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
			if ($z==0)
				progressBar -e -s 1 $gMainProgressBar;
			$tempString=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
			if (`stringArrayCount $smoothJoints[$z] $tempString`)
				{
				select -add ($sel[$i]+".vtx["+$y+"]");
				//middleVtx to root
				if (`gmatch $smoothJoints[$z] "*Root_M*"` || `gmatch $smoothJoints[$z] "*Hip_*"`)
					{
					$pos=`xform -q -ws -t ($sel[$i]+".vtx["+$y+"]")`;
					if ($pos[0]>($charHeight/-5000.0) && $pos[0]<($charHeight/5000.0))
						skinPercent -tv $smoothJoints[$z] 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
					}
				}
			}
		if (size(`ls -sl`))
			weightHammerVerts;
	}
progressBar -e -ep $gMainProgressBar;
}

global proc asDeleteSkinCurves ()
{
if (!`objExists skinCageShape` || !`objExists skinClusterSkinCage`)
	return;
setAttr skinClusterSkinCage.envelope 0;
duplicate -n asTempMesh skinCageShape;
setAttr skinClusterSkinCage.envelope 1;
string $deleteObjs[]={"SkinCurves1","SkinCurves2","MeshGeometry","MeshCurves","NurbsGeometry"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
string $tempString[]=`listRelatives -s -type mesh skinCage`;
for ($mesh in $tempString)
	if ($mesh!="skinCageShape")
		{
		connectAttr asTempMesh.outMesh ($mesh+".inMesh");
		evalDeferred -lp ("delete asTempMesh");
		break;
		}
}

global proc string asNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";if ($nr==1) $letter="A";if ($nr==2) $letter="B";
if ($nr==3) $letter="C";if ($nr==4) $letter="D";if ($nr==5) $letter="E";
if ($nr==6) $letter="F";if ($nr==7) $letter="G";if ($nr==8) $letter="H";
if ($nr==9) $letter="I";if ($nr==10) $letter="J";if ($nr==11) $letter="K";
if ($nr==12) $letter="L";if ($nr==13) $letter="M";if ($nr==14) $letter="N";
if ($nr==15) $letter="O";if ($nr==16) $letter="P";if ($nr==17) $letter="Q";
if ($nr==18) $letter="R";if ($nr==19) $letter="S";if ($nr==20) $letter="T";
if ($nr==21) $letter="U";if ($nr==22) $letter="V";if ($nr==23) $letter="W";
if ($nr==24) $letter="X";if ($nr==25) $letter="Y";if ($nr==26) $letter="Z";
return $letter;
}

global proc asAlign (string $object, string $alignToObject, int $translate, int $rotate, int $jointOrient, int $rotateOrder)
{
string $parents[]=`listRelatives -p $object`;
string $orientConstraint[];
float $rotation[];
parent $object $alignToObject;
//Might have generated a Xform
string $generatedXform;
string $tempString[]=`listRelatives -p $object`;
if ($tempString[0]!=$alignToObject)
	$generatedXform=$tempString[0];
if ($translate)
	{
	xform -os -t 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -t 0 0 0 $generatedXform;
	}
if ($rotateOrder)
	setAttr ($object+".rotateOrder") `getAttr ($alignToObject+".rotateOrder")`;
if ($rotate)
	{
	xform -os -ro 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -ro 0 0 0 $generatedXform;
	}
if (`objExists $parents[0]`)
	parent $object $parents[0];
else
	parent -w $object;
if ($jointOrient)
	{
	$orientConstraint=`orientConstraint $alignToObject $object`;
	$rotation=`xform -q -os -ro $object`;
	delete $orientConstraint[0];
	setAttr -type float3 ($object+".jointOrient") $rotation[0] $rotation[1] $rotation[2];
	setAttr -type float3 ($object+".rotate") 0 0 0;
	}
}

global proc asImportIconsFile (string $iconsFile)
{
string $beforeObj[]=`ls -l -as`;
string $afterObj[];
int $fromBefore[];
int $readLine;
$fileId=`fopen $iconsFile "r"`;
string $nextLine = `fgetline $fileId`;
string $previousLine;
while ( size( $nextLine ) > 0 )
	{
	if (!$readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
	if (`gmatch $nextLine "createNode nurbsCurve*"`)
		{
		$readLine=1;
		eval ($previousLine);
		$previousLine = $nextLine;
		$nextLine = `fgetline $fileId`;
		continue;
		}
	if ($readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
		else
			{
			$readLine=0;
			eval ($previousLine);
			}
	$previousLine=$nextLine;
	$nextLine = `fgetline $fileId`;
	}
fclose $fileId;
$afterObj=`ls -l -as`;
for ($i=0;$i<size($afterObj);$i++)
	for ($y=0;$y<size($beforeObj);$y++)
		if ($afterObj[$i]==$beforeObj[$y])
			$fromBefore[$i]=1;
for ($i=0;$i<size($afterObj);$i++)
	if (!$fromBefore[$i])
		parent $afterObj[$i] "iconsGroup";
}

global proc asCreateController (string $type, string $name, string $side, string $fitJoint)
{
string $sel[]=`ls -sl`;
select -cl;
int $rotOrder=`getAttr ($fitJoint+".rotateOrder")`;
if ($type=="FK")
	joint -n ($type+"Offset"+$name+$side);
else
	{
	createNode -n ($type+"Offset"+$name+$side) transform;
	parent ($type+"Offset"+$name+$side) "IKHandle";
	}
setAttr ($type+"Offset"+$name+$side+".rotateOrder") $rotOrder;
createNode -n ($type+"Extra"+$name+$side) transform;
sets -add ControlSet ($type+"Extra"+$name+$side);
setAttr ($type+"Extra"+$name+$side+".rotateOrder") $rotOrder;
parent ($type+"Extra"+$name+$side) ($type+"Offset"+$name+$side);
asLockAttr ($type+"Extra"+$name+$side) 0 0 1 1;
if (`gmatch $name "*Scapula*"`)
	duplicate -n ($type+$name+$side) "Scapula_icon";
else
	duplicate -n ($type+$name+$side) ($type+"_icon");
xform -os -t 0 0 0 -ro 0 0 0 ($type+$name+$side);
setAttr ($type+$name+$side+".rotateOrder") $rotOrder;

if ($side=="_L")
	setAttr -type float3 ($type+$name+$side+".s") -1 -1 -1;

float $height=`getAttr "Main.height"`;
float $fitSkeletonScaleX=`getAttr FitSkeleton.sx`;
float $defaultCtrlScale=$height/30.0;
float $sca[3]={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
$tempString=`listRelatives -c -type joint $fitJoint`;
if ($tempString[0]!="")
	{
	float $pos1[]=`xform -q -ws -t $fitJoint`;
	float $pos2[]=`xform -q -ws -t $tempString[0]`;
	float $boneLenght=`mag<<$pos2[0]-$pos1[0],$pos2[1]-$pos1[1],$pos2[2]-$pos1[2]>>`;
	if ($boneLenght>1)
		$boneLenght=$boneLenght/2.0;
	else
		$boneLenght=$boneLenght+((1-$boneLenght)/2.0);
	$defaultCtrlScale=$defaultCtrlScale*$boneLenght;
	$sca={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
	}

if (`attributeExists fat $fitJoint` && `attributeExists fatY $fitJoint` && `attributeExists fatZ $fitJoint`)
	{
	float $fat=`getAttr ($fitJoint+$side+".fat")`;
	float $fatY=`getAttr ($fitJoint+$side+".fatY")`;
	float $fatZ=`getAttr ($fitJoint+$side+".fatZ")`;
	$sca={$defaultCtrlScale,$fat*$fatY*$fitSkeletonScaleX,$fat*$fatZ*$fitSkeletonScaleX};
	}

string $shapes[]=`listRelatives -s ($type+$name+$side)`;
for ($i=0;$i<size($shapes);$i++)
	{
	xform -s $sca[1] $sca[1] $sca[1] ($shapes[$i]+".cv[0:99]");
	xform -s 1.5 1.5 1.5 ($shapes[$i]+".cv[0:99]");
	}
makeIdentity -a 1 -t 1 -r 1 -s 1 ($type+$name+$side);

parent ($type+$name+$side) ($type+"Extra"+$name+$side);

float $pos[]=`xform -q -ws -t ($fitJoint+$side)`;
float $rot[]=`xform -q -ws -ro ($fitJoint+$side)`;
//float $b=1;
//if ($side=="_L")
//	$b=-1;
xform -ws -t $pos[0] $pos[1] $pos[2] ($type+"Offset"+$name+$side);
if ($type=="FK")
	xform -ws -ro $rot[0] $rot[1] $rot[2] ($type+"Offset"+$name+$side);
select $sel;
}

global proc asCreateUnTwister (string $fitJoint, string $side, string $twistParent, string $twistParentSide, string $fitJointIK, int $b, int $IkUnTwister, string $ikFollow)
{
float $scale=`getAttr FitSkeleton.sx`;
if (`objExists ("TwistFollow"+$fitJoint+$side)`)
	return;
string $tempString[];
string $parentIK;
//find $parentIK
if (`objExists ($twistParent+$twistParentSide)`)
	{
	string $iKInfo[]=`asFitJointIKInfo $twistParent`;
	$parentIK=$iKInfo[0];
	}

createNode -n ("TwistFollow"+$fitJoint+$side) -p TwistSystem transform;
createNode -n ("TwistFollowParent"+$fitJoint+$side) -p TwistSystem transform;
asAlign ("TwistFollow"+$fitJoint+$side) ($fitJoint+$side) 1 1 0 1;
setAttr -l 1 ("TwistFollow"+$fitJoint+$side+".v") 0;
setAttr -l 1 ("TwistFollowParent"+$fitJoint+$side+".v") 0;


if ($IkUnTwister)
	{
	parentConstraint ($ikFollow+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		parentConstraint ("IKX"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);;
	}
else
	{
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		asConstraintToFKIK "parent" $parentIK ("FKX"+$twistParent+$twistParentSide) ("IKX2"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
	}

if (!`objExists ($twistParent+$twistParentSide)`)
	parentConstraint RootX_M ("TwistFollowParent"+$fitJoint+$side);	
//Makes FKIK mixing less flippy, but `might` cause cycle
//		parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);
//setAttr ("TwistFollow"+$fitJoint+$side+"_parentConstraint1.interpType") 2;

//stabalize constraint by adding offsetNode
createNode -n ("TwistFollowOffset"+$fitJoint+$side) -p ("TwistFollow"+$fitJoint+$side) transform;
createNode -n ("TwistFollowParentOffset"+$fitJoint+$side) -p ("TwistFollowParent"+$fitJoint+$side) transform;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".r") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".r") 0 0 0;
parent ("TwistFollowOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollowParentOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowOffset"+$fitJoint+$side);
parent ("TwistFollowParent"+$fitJoint+$side) ("TwistFollowParentOffset"+$fitJoint+$side);

select ($fitJoint+$side);
joint -n ("UnTwist"+$fitJoint+$side);
joint -n ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwist"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);

if ($IkUnTwister)
	pointConstraint ($ikFollow+$side) ("UnTwist"+$fitJoint+$side);
else
	asConstraintToFKIK "point" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("UnTwist"+$fitJoint+$side);

setAttr ("UnTwistEnd"+$fitJoint+$side+".translateX") ($b*$scale);
ikHandle -n ("UnTwistIK"+$fitJoint+$side) -ns 2 -sol "ikRPsolver" -sj ("UnTwist"+$fitJoint+$side) -ee ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwistIK"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
poleVectorConstraint ("UnTwist"+$fitJoint+$side) ("UnTwistIK"+$fitJoint+$side);

select ("UnTwist"+$fitJoint+$side);
joint -n ("TwistBalancer"+$fitJoint+$side);
setAttr ("TwistBalancer"+$fitJoint+$side+".rotateOrder") 5;
if ($IkUnTwister)
	parentConstraint ($ikFollow+$side) ("TwistBalancer"+$fitJoint+$side);
else
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("TwistBalancer"+$fitJoint+$side);
//setAttr ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1.interpType") 2;
}

global proc asFollow (string $driver, string $driven, string $target)
{
if (!`objExists $target`)
	return;
string $setRange=$driver+"SetRangeFollow";
if (!`attributeExists "follow" $driver`)
	{
	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 0 $driver;
	createNode -n $setRange setRange;
	setAttr ($setRange+".maxX") 1;
	setAttr ($setRange+".minY") 1;
	setAttr ($setRange+".oldMaxX") 10;
	setAttr ($setRange+".oldMaxY") 10;
	connectAttr ($driver+".follow") ($setRange+".value.valueX");
	connectAttr ($driver+".follow") ($setRange+".value.valueY");
	}
float $temp[]=`xform -q -ws -t $driven`;
createNode -n ($driven+"Static") transform;
asAlign ($driven+"Static") $driven 1 1 0 0;
parent ($driven+"Static") ("IKStatic");
string $tempString[]=`parentConstraint -mo ($driven+"Static") $target $driven`;
string $constraint=$tempString[0];
select $constraint;
connectAttr ($setRange+".outValue.outValueY") ($constraint+"."+$driven+"Static"+"W0");
connectAttr($setRange+".outValue.outValueX") ($constraint+"."+$target+"W1");
}

global proc asConstraintToFKIK (string $type, string $fitJointIK, string $fk, string $ik, string $target)
{
string $contraintCmd="pointConstraint ";
if ($type=="orient")
	$contraintCmd="orientConstraint ";
if ($type=="parent")
	$contraintCmd="parentConstraint ";
if ($type=="scale")
	$contraintCmd="scaleConstraint ";
$contraintCmd+=$fk;
if (`objExists $ik`)
	$contraintCmd+=" "+$ik;
$contraintCmd+=" "+$target;
string $tempString[];
tokenize $target "_" $tempString;
string $side="_"+$tempString[size($tempString)-1];
tokenize $fk "_" $tempString;
string $contraintToSide="_"+$tempString[size($tempString)-1];
$tempString=`eval ($contraintCmd)`;
string $constraint=$tempString[0];
if (`objExists $ik` && `objExists ("FKIKBlend"+$fitJointIK+"Reverse"+$contraintToSide)`)
	{
	connectAttr ("FKIKBlend"+$fitJointIK+"Reverse"+$contraintToSide+".outputX") ($constraint+"."+$fk+"W0");
	connectAttr ("FKIKBlend"+$fitJointIK+"UnitConversion"+$contraintToSide+".output") ($constraint+"."+$ik+"W1");
	}
}

global proc asRemoveAllUnusedInfluences ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
	{
	$tempString=`listHistory -pdo 1 $meshes[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			select `listRelatives -p $meshes[$i]`;
			removeUnusedInfluences;
			}
	}
select $sel;
print "// Unused influences removed.\n";
}

global proc asPrunAllClusters ()
{
string $sel[]=`ls -sl`;
//clusters at zero position does not prune well, they loose all weight; workaround temp move ClusterSetup group
if (`objExists ClusterSetup`) setAttr ClusterSetup.tx 1;
if (`objExists LipSetup`) setAttr LipSetup.tx 1;
if (`objExists squashBase_M`) setAttr squashBase_M.tx 1;

string $clusters[]=`ls -type cluster`;
for ($i=0;$i<size($clusters);$i++)
	{
	select $clusters[$i];
	PruneCluster;
	}

if (`objExists ClusterSetup`) setAttr ClusterSetup.tx 0;
if (`objExists LipSetup`) setAttr LipSetup.tx 0;
if (`objExists squashBase_M`) setAttr squashBase_M.tx 0;

select $sel;
print "// Clusters pruned.\n";
}

global proc freezeSkinCluster (string $skinCluster)
{
if (!`objExists $skinCluster`)
	return;
int $numMatrix;
float $jointMatrix[];
string $tempString[]=`ls -showType $skinCluster`;

$numMatrix=`getAttr -s ($skinCluster+".bindPreMatrix")`;
for ($i=0;$i<$numMatrix;$i++)
	{
	$tempString=`listConnections -s 1 -d 1 ($skinCluster+".matrix["+$i+"]")`;
	if (!`objExists $tempString[0]`)
		continue;
	$jointMatrix=`getAttr ($tempString[0]+".worldInverseMatrix")`;
	setAttr ($skinCluster+".bindPreMatrix["+$i+"]") -type "matrix" $jointMatrix[0] $jointMatrix[1] $jointMatrix[2] $jointMatrix[3] $jointMatrix[4] $jointMatrix[5] $jointMatrix[6] $jointMatrix[7] $jointMatrix[8] $jointMatrix[9] $jointMatrix[10] $jointMatrix[11] $jointMatrix[12] $jointMatrix[13] $jointMatrix[14] $jointMatrix[15];
	}
}

global proc asSetDisplayLayersToR ()
{
string $displayLayers[]=`listConnections layerManager.displayLayerId`;
for ($i=$y=0;$i<size($displayLayers);$i++)
	{
	if ($displayLayers[$i]=="defaultLayer")
		continue;
	setAttr ($displayLayers[$i]+".displayType") 2;
	}
}

global proc asPublish ()
{
string $sceneName=`file -q -sn`;
if ($sceneName=="")
	error "File not saved, can not publish";
string $tempString[];
string $filePath,$publishFile;
string $basename=`basenameEx $sceneName`;
tokenize $sceneName "/" $tempString;
for ($i=0;$i<size($tempString)-1;$i++)
	$filePath+=$tempString[$i]+"/";
if (`gmatch $sceneName "*[.]mb"`)
	{
	print "// Your working file is already MB format, appending \"_Published\" to the name.\n";
	$publishFile=$filePath+$basename+"_Published.mb";
	}
else
	$publishFile=$filePath+$basename+".mb";
if (`file -q -ex $publishFile`)
	{
	print ("// Publish file already exits, performing incrementalSave for backup.\n");
	file -rename $publishFile;
	incrementalSaveScene;
	file -rename $sceneName;
	}

//string $references[]=`file -q -r`;
//for ($i=0;$i<size($references);$i++)
//	file -importReference $references[$i];
file -f -op "v=0" -typ "mayaBinary" -ea $publishFile;

print ("// Published: \""+$publishFile+"\".\n");
}

global proc asReBuildAdvancedSkeleton ()
{
global int $asBuilding;
global int $asRebuilding;
global string $gMainProgressBar;

if (!`asConfirmIfNotInBuildPose`)
	return;

if (!`objExists "Group"`)
	{
	$asBuilding=1;
	asBuildAdvancedSkeleton;//First build
	if (`checkBox -q -ex asRebuildConnections`)
		checkBox -e -m 1 asRebuildConnections;
	if (`button -q -ex asToggleFitSkeletonButton`)
		button -e -m 1 asToggleFitSkeletonButton;
	if (`button -q -ex asBuildAdvancedSkeletonButton`)
		button -e -l "ReBuild AdvancedSkeleton" asBuildAdvancedSkeletonButton;
	$asBuilding=0;
	return;
	}
if (`objExists "prefix_Group"`)
	error "Object \"prefix_Group\" found, which means a previous build failed. Try to Undo previous build, to restore functional AdvancedSkeleton";

if (`objExists "Group"` && `objExists FitSkeleton`)
	if (!`getAttr FitSkeleton.visibility`)
		asToggleFitAdvancedSkeleton;

string $allSet="AllSet";
string $controlSet="ControlSet";
string $allSetMembers[]=`sets -q $allSet`;

int $rebuildConnections=`checkBox -q -v asRebuildConnections`;
string $tempString[],$tempString2[],$sources[],$destinations[],$sourcesNoPlug[],$destinationsNoPlug[];
string $roots[];

if (!`objExists FitSkeleton`)
	error "No skeleton to rebuild\n";
parent -w FitSkeleton;

progressBar -e -st "Analyzing AdvancedSkeleton" -bp -ii 0 -min 0 -max (size($allSetMembers)*2) $gMainProgressBar;

//Pre Rebuild
float $mx[];
string $userAttrs[],$children[],$connections[],$connectionsObj[],$connectCmdsSource[],$connectCmdsDest[];
string $addAttrCmds[],$cmds[],$connectCmds[],$skinClusters[],$jointClusters[];
string $sn,$ln,$at,$k,$cb,$dv,$minMax,$skinCluster;
string $charSet,$objectType,$tr,$xyz,$target;
int $childIsMember,$alreadyConnected;
int $locked;
int $e[2];
float $range[2];
float $vals[2];

if (`objExists FaceAllSet`)
	if (`sets -im "Sets" FaceAllSet`)
		sets -rm "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	if (`sets -im "Sets" FaceControlSet`)
		sets -rm "Sets" FaceControlSet;


//Pre Rebuild parentConstraints
string $constraintParent,$constraintChild;
string $parentConstraints[]=`ls -type parentConstraint`;
string $parentConstraintParents[],$parentConstraintChildren[];
for ($i=$y=0;$i<size($parentConstraints);$i++)
	{
	if (`sets -im $allSet $parentConstraints[$i]` || `gmatch $parentConstraints[$i] "*Box_*"`)
			continue;

	$tempString=`listConnections ($parentConstraints[$i]+".target[0].targetJointOrient")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintParent=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	$tempString=`listConnections ($parentConstraints[$i]+".constraintTranslate.constraintTranslateX")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintChild=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	if (!`objExists $constraintParent` || !`objExists $constraintChild`)
		continue;
	if (!`sets -im $allSet $constraintParent` && !`sets -im $allSet $constraintChild`)
		continue;

	$parentConstraintParents[$y]=$constraintParent;
	$parentConstraintChildren[$y]=$constraintChild;
	delete $parentConstraints[$i];
	$y++;
	}

//Pre Rebuild userDefinedAttr
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	$userAttrs=`listAttr -ud $allSetMembers[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		$tempString=`listAttr -sn ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		if (`gmatch $at "*Array"` || $at=="message")
			continue;
		$dv=`getAttr ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$k=`getAttr -k ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$cb=`getAttr -cb ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="string")
			continue;
		if (`gmatch $ln "*W[0-9]"`)
			continue;
		$minMax="";
		if (`attributeQuery -re -n $allSetMembers[$i] $ln`)
			{
			$range=`attributeQuery -r -n $allSetMembers[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	addAttr -k "+$k+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$allSetMembers[$i]+";";
		//Non-keyable
		if ($k=="0" && $cb)
			$addAttrCmds[size($addAttrCmds)]="if (`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	setAttr -cb 1 "+$allSetMembers[$i]+"."+$userAttrs[$y]+";";
		}
	}


//Pre Rebuild Parenting
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	if (`objectType $allSetMembers[$i]`=="objectSet")
		continue;
	$children=`listRelatives -c $allSetMembers[$i]`;
	for ($y=0;$y<size($children);$y++)
		{
		$tempString=`ls $children[$y]`;
		if (size($tempString)>1)
			error ("ObjectName not unique "+$children[$y]+"\n");
		$childIsMember=0;
		for ($z=0;$z<size($allSetMembers);$z++)
			if ($children[$y]==$allSetMembers[$z])
				$childIsMember=1;
		if (!$childIsMember)
			{
			$tempString=`ls -s $children[$y]`;
			if ($tempString[0]!="")
				$cmds[size($cmds)]="parent -r -s "+$children[$y]+" "+$allSetMembers[$i]+";";
			else if (`getAttr ($children[$y]+".inheritsTransform")` && !`gmatch $children[$y] "*_?_[0-9][0-9]"`)
				$cmds[size($cmds)]="parent "+$children[$y]+" "+$allSetMembers[$i]+";";
			else
				$cmds[size($cmds)]="parent -r "+$children[$y]+" "+$allSetMembers[$i]+";";
			}
		}
	if (!$rebuildConnections)
		continue;

	//Incoming connections
	$connections=`listConnections -p 1 -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		if ($connections[$y+1]=="Group.message")
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver" || $objectType== "displayLayerManager")
			continue;
		if ($connections[$y+1]=="time1.outTime")
			continue;
		$connectCmds[size($connectCmds)]="if (`getAttr -l "+$connections[$y]+"`)  setAttr -l 0 "+$connections[$y]+";connectAttr -f "+$connections[$y+1]+" "+$connections[$y]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y+1];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y];
		}

	//Outgoing connections
	$connections=`listConnections -p 1 -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="materialInfo" || $objectType=="partition")
			continue;
		//changed to allow user-defined selection-set to persist
//		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
		if ($objectType=="objectSet")
			if ($connectionsObj[$y+1]=="AllSet" || $connectionsObj[$y+1]=="ControlSet" || $connectionsObj[$y+1]=="DeformSet")
				continue;
		if ($objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
			continue;
		if (`gmatch $connections[$y] "*instObjGroups*"` || `gmatch $connections[$y+1] "*instObjGroups*"`)
			if ($objectType!="objectSet")
				continue;
		if ($objectType=="skinCluster")
			$skinClusters[size($skinClusters)]=$connectionsObj[$y+1];
		if ($objectType=="jointCluster")
			$jointClusters[size($jointClusters)]=$connectionsObj[$y+1];
		$connectCmds[size($connectCmds)]="connectAttr -f "+$connections[$y]+" "+$connections[$y+1]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y+1];
		}

	//transformLimits
	if (`objectType $allSetMembers[$i]`=="joint")
		{
		$tr="r";
		for ($y=0;$y<2;$y++)
			{
			if ($y==1)
				continue;
			$xyz="x";
			for ($z=0;$z<3;$z++)
				{
				if ($z==1)
					$xyz="y";
				if ($z==2)
					$xyz="z";
				$e=`eval ("transformLimits -q -e"+$tr+$xyz+" "+$allSetMembers[$i])`;
				if ($e[0] || $e[1])
					{
					$vals=`eval ("transformLimits -q -"+$tr+$xyz+" "+$allSetMembers[$i])`;
					$cmds[size($cmds)]="transformLimits -"+$tr+$xyz+" "+$vals[0]+" "+$vals[1]+" -e"+$tr+$xyz+" "+$e[0]+" "+$e[1]+" "+$allSetMembers[$i]+";";
					}
				}
			}
		}
	}

//Pre Rebuild CurveShapes
string $controlSetMembers[]=`sets -q $controlSet`;
//add HipSwingerOffset_M, so placement of this is maintained in ReBuild
if (`objExists "HipSwingerOffset_M"`)
	$controlSetMembers[size($controlSetMembers)]="HipSwingerOffset_M";
string $curveShape;
int $spans,$degree,$numCVs;
float $cvPos[3];
if ($rebuildConnections)
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		$tempString=`listRelatives -s $controlSetMembers[$i]`;
		$curveShape=$tempString[0];
		if (!`objExists $curveShape`)
			continue;
		if (`objectType $curveShape`!="nurbsCurve")
			continue;
		$spans=`getAttr ($curveShape+".spans")`;
		$degree=`getAttr ($curveShape+".degree")`;
		$numCVs=$spans+$degree;
		for ($y=0;$y<$numCVs;$y++)
			{
			$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
			$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
			}
		}

//Pre Rebuild Disable expressions to avoid warnings
$tempString=`ls -type expression`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im $allSet $tempString[$i]`)
		setAttr ($tempString[$i]+".nodeState") 1;

//Rebuild
$allSetMembers[size($allSetMembers)]="Group";
$allSetMembers[size($allSetMembers)]="Sets";
$allSetMembers[size($allSetMembers)]="AllSet";
$allSetMembers[size($allSetMembers)]="ControlSet";
$allSetMembers[size($allSetMembers)]="DeformSet";

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
	else
		$allSetMembers[$i]="";

//unprefix CylShapes inorde to preserve these
$tempString=`ls -type nurbsSurface "*_CylShape*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		rename $tempString[$i] `substitute "prefix_" $tempString[$i] ""`;


progressBar -e -ep $gMainProgressBar;


$asRebuilding=1;
asBuildAdvancedSkeleton;
$asRebuilding=0;


//redo parentConstraints
for ($i=0;$i<size($parentConstraintParents);$i++)
	if (`objExists $parentConstraintParents[$i]` && `objExists $parentConstraintChildren[$i]`)
		parentConstraint -mo $parentConstraintParents[$i] $parentConstraintChildren[$i];


//Post Rebuild
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
for ($i=0;$i<size($connectCmds);$i++)
	{
	$alreadyConnected=0;
	if (`objExists $connectCmdsSource[$i]` && `objExists $connectCmdsDest[$i]`)
		if (`isConnected -iuc $connectCmdsSource[$i] $connectCmdsDest[$i]`)
			$alreadyConnected=1;
	if (!$alreadyConnected)
		if (catchQuiet (`eval ($connectCmds[$i])`)) warning ("Failed: "+$connectCmds[$i]+"\n");
	}
for ($cmd in $cmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

//reset bindPose
string $bindPose;
string $newSetMembers[]=`sets -q $allSet`;
for ($i=0;$i<size($newSetMembers);$i++)
	{
	if (`objectType $newSetMembers[$i]`=="joint")
		{
		select $newSetMembers[$i];
		$tempString=`dagPose -q -bp`;
		$bindPose=$tempString[0];
		if (`objExists $bindPose`)
			{
			$tempString=`listConnections ($newSetMembers[$i]+".bindPose")`;
			if ($tempString[0]==$bindPose)
				{
				select -add $bindPose;
				dagPose -rs;
				}
			}
		}
	}


for ($i=0;$i<size($allSetMembers);$i++)
	if (`gmatch $allSetMembers[$i] "*CurveInfo*"`)
		if (`objExists $allSetMembers[$i]`)
			delete $allSetMembers[$i];
for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		catchQuiet (`delete $allSetMembers[$i]`);

$skinClusters=`stringArrayRemoveDuplicates $skinClusters`;
$jointClusters=`stringArrayRemoveDuplicates $jointClusters`;
for ($i=0;$i<size($skinClusters);$i++)
	freezeSkinCluster $skinClusters[$i];
for ($i=0;$i<size($jointClusters);$i++)
	freezeJointCluster $jointClusters[$i];

if (`objExists FaceAllSet`)
	sets -add "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	sets -add "Sets" FaceControlSet;

//if ($runCmd!="")
//	evalEcho $runCmd;

eval ("dgdirty -a");

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		delete $allSetMembers[$i];

select -cl;
}

global proc asBuildAdvancedSkeleton ()
{
global int $asRebuilding;
global string $asDSAltPivot;
global string $gSelect;
string $iconsFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asIcons.ma";

//FitSkeleton from basic joints
string $selJoints[]=`ls -sl -type joint`;
if (!`objExists FitSkeleton` && size($selJoints))
	{
	asCreateFitSkeleton;
	parent $selJoints[0] FitSkeleton;
	}

float $scale=`getAttr FitSkeleton.sx`;
float $sideTreshold=0.0001*$scale;

//preBuild check
if (!`objExists FitSkeleton`)
	error "FitSkeleton not found. You must import a FitSkeleton, or select a joint-chain.\n";
if (!`file -q -ex $iconsFile`)
	error ("File not found:"+$iconsFile);
if (!$asRebuilding)
	if (`objExists "Group"`)
		error "AdvancedSkeleton already exists, use ReBuild instead";
string $tempString[]=`listRelatives -c -type joint FitSkeleton`;
if ($tempString[0]=="")
	error "FitSkeleton has no joints parented to it";
float $firstJointPos[3]=`xform -q -ws -t $tempString[0]`;
if ($tempString[0]=="Root" && ($firstJointPos[0]>$sideTreshold || $firstJointPos[0]<(-1*$sideTreshold)))
	{//Existing Root but not centered, gets renamed, so new centered root gets generated
	rename Root RootSide;
	$tempString=`listRelatives -c -type joint FitSkeleton`;
	}
if ($tempString[0]!="Root")
	{
	if (`objExists "Root"`)
		error "The top-level joint must be named \"Root\", but another object in this scene is already called Root";
	if ($firstJointPos[0]<$sideTreshold && $firstJointPos[0]>(-1*$sideTreshold))
		rename $tempString[0] Root;
	else
		{
		select FitSkeleton;
		joint -n Root;
		xform -ws -t 0 $firstJointPos[1] $firstJointPos[2] Root;
		parent $tempString[0];
		}
	}

string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
asFitModeManualUpdate; //Ensure joint rotations & jointOrientations
asOffFitMode;
for ($i=0;$i<size($fitJoints);$i++)
	asEnsureFitJointAttrs $fitJoints[$i];

string $rootIKInfo[]=`asFitJointIKInfo Root`;
string $nonCenteredSpineJoints="";
if ($rootIKInfo[0]=="Spine")
	{
	string $rootIKJoints[]=`asGetIKJoints $rootIKInfo[1] $rootIKInfo[3]`;
	for ($i=0;$i<size($rootIKJoints);$i++)
		{
		float $rootIKJointPos[]=`xform -q -ws -t $rootIKJoints[$i]`;
		if ($rootIKJointPos[0]>$sideTreshold || $rootIKJointPos[0]<($sideTreshold*-1))
			$nonCenteredSpineJoints+="\""+$rootIKJoints[$i]+"\" ";
		}
	if ($nonCenteredSpineJoints!="")
		error ("These Spine joints are not in the center: "+$nonCenteredSpineJoints);
	}


setToolTo $gSelect;
asSetFixedWrapOptions;
int $numLetters,$centerBtwFeet,$inbetweenJoints;
int $fitJointTwistJoints[],$fitJointUpTwistJoints[],$fitJointBendyJoints[],$fitJointUpBendyJoints[],$fitJointBend[],$fitJointInbetweenJoints[],$fitJointUnTwister[],$fitJointRotOrder[];
int $fitJointIsEndJoint[],$ikLocal[],$isScapula[],$fitJointGlobal[],$fitJointsWheel[],$fitJointFirstAfterIK[],$fitJointNonDef[];
int $fitJointsAim[],$fitJointNoMirror[],$fitJointNoFlip[],$fitJointNoControl[];
int $isIKStart[],$isIKEnd[],$fitJointIKNumCtrls[];
float $pos[3],$pos2[3],$rot[3],$sca[3],$parentPos[3],$parentRot[3],$temp[3],$temp2[3],$temp3[3];
float $footRotX[],$ikLenght[],$fitJointGlobalValue[];
float $fitSkeletonScaleX=`getAttr FitSkeleton.sx`;
string $side,$childSide,$parent,$joint,$multipleDivide,$childLabel,$ankle,$heel,$toes,$toesEnd,$bigToe,$pinkyToe,$scapula,$label;
string $fitJointLabel[],$fitJointSide[],$fitJointParent[],$fitJointParentSide[],$fitJointChild[],$fitJointChildSide[],$fitJointsAttachTo[],$tempString2[];
string $asFitJointIKInfo[],$fitJointIK[],$fitJointIKStartJoint[],$fitJointIKMiddleJoint[],$fitJointIKEndJoint[],$fitJointIKSolver[],$IKJoints[],$userAttrs[];
string $allBefore[]=`ls`;

if (`objExists FitSkeletonVisualizers`)
	{
	delete FitSkeletonVisualizers;
	asUpdateButtonEnables;
	}

createNode -n "iconsGroup" transform;
setAttr "iconsGroup.visibility" 0;
asImportIconsFile $iconsFile;

//--Sets--//
select -cl;
sets -name ControlSet;
sets -name DeformSet;
sets -name AllSet;
sets -name "Sets";
sets -add "Sets" AllSet ControlSet DeformSet;
sets -add ControlSet `listRelatives -c iconsGroup`;

createNode -n "Group" transform;
asLockAttr "Group" 1 1 1 0;
duplicate -n Main Main_icon;
parent Main "Group";
xform -s (0.285*$scale) (0.285*$scale) (0.285*$scale) Main.cv[0:7];
connectAttr -f FitSkeletonShape.worldSpace[0] MainShape.create;
refresh;
disconnectAttr FitSkeletonShape.worldSpace[0] MainShape.create;


//--3rd level transforms--//
parent FitSkeleton Main;
createNode -n MotionSystem transform;
createNode -n DeformationSystem transform;
if (!$asRebuilding || !`objExists Geometry`)
	{
	createNode -n Geometry transform;
	setAttr -l 1 Geometry.inheritsTransform 0;
	parent Geometry "Group";
	}
parent MotionSystem DeformationSystem Main;
setAttr -l 0 FitSkeleton.v;
setAttr -l 1 FitSkeleton.v 0;
connectAttr -f MotionSystem.visibility MainShape.visibility;

//--4th level transforms--//
createNode -n FKSystem -p MotionSystem transform;
createNode -n IKSystem -p MotionSystem transform;
createNode -n FKIKSystem -p MotionSystem transform;
createNode -n BendSystem -p MotionSystem transform;
createNode -n AimSystem -p MotionSystem transform;
createNode -n RootSystem -p MotionSystem transform;
createNode -n TwistSystem -p MotionSystem transform;
createNode -n GlobalSystem -p MotionSystem transform;
createNode -n ConstraintSystem -p MotionSystem transform;
createNode -n DynamicSystem -p MotionSystem transform;	
setAttr BendSystem.inheritsTransform 0;

//--5th level transforms--//
createNode -n IKJoints -p IKSystem transform;
createNode -n IKHandle -p IKSystem transform;
createNode -n IKStatic -p IKSystem transform;
createNode -n IKCurve -p IKSystem transform;
setAttr IKCurve.inheritsTransform 0;
createNode -n IKMessure -p IKSystem transform;

//--6th level transforms--//
createNode -n IKRootConstraint -p IKHandle transform;

addAttr -k 1 -ln fkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkVis;
connectAttr -f Main.fkVis FKSystem.v;
addAttr -k 1 -ln ikVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.ikVis;
connectAttr -f Main.ikVis "IKSystem.v";
addAttr -k 1 -ln fkIkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkIkVis;
connectAttr -f Main.fkIkVis FKIKSystem.v;
addAttr -k 1 -ln aimVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimVis;
connectAttr -f Main.aimVis AimSystem.v;
addAttr -k 1 -ln aimFKVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimFKVis;
addAttr -k 1 -ln aimLRVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimLRVis;
addAttr -k 1 -ln fingerVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fingerVis;
addAttr -k 1 -ln bendVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.bendVis;
addAttr -k 1 -ln arrowVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.arrowVis;
addAttr -k 1 -ln drvSysVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.drvSysVis;

connectAttr -f Main.bendVis BendSystem.v;

if (`objExists jointLayer`)
	delete jointLayer;
createNode -n jointLayer displayLayer;
//setAttr jointLayer.displayType 2;


//Zero out endJoints
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`listRelatives -c -type joint $tempString[$y]`;
		if (size($tempString2)==0)
			{
			if (!`getAttr -l ($tempString[$y]+".rx")` && `getAttr -l ($tempString[$y]+".ry")` && `getAttr -l ($tempString[$y]+".rz")`)
				setAttr -type float3 ($tempString[$y]+".rotate") 0 0 0;
			setAttr -type float3 ($tempString[$y]+".jointOrient") 0 0 0;
			}
		}
	}

//Adding inbetweenJoints to FitSkeleton
for ($i=0;$i<size($fitJoints);$i++)
	{
	if (!`attributeExists inbetweenJoints $fitJoints[$i]`)
		continue;
	$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	if ($inbetweenJoints<1)
		continue;
	$rlaChild=`asRlaChild $fitJoints[$i]`;
	if ($rlaChild=="")
		continue;
	select $fitJoints[$i];
	string $inbetweenJoint;
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		$inbetweenJoint=$fitJoints[$i]+"Part"+$y;
		joint -n $inbetweenJoint;
		setAttr ($inbetweenJoint+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
		float $weight=(1.0/($inbetweenJoints+1))*$y;
		$tempString=`pointConstraint -w $weight $rlaChild $inbetweenJoint`;
		pointConstraint -w (1-$weight) $fitJoints[$i] $inbetweenJoint;
		delete $tempString[0];
		addAttr -k 1 -ln tempInbetweener -at bool -dv 1 $inbetweenJoint;
		addAttr -k 1 -ln noControl -at bool -dv 1 $inbetweenJoint;
		float $fat=(`getAttr ($fitJoints[$i]+".fat")`*(1-$weight)) + (`getAttr ($rlaChild+".fat")`*$weight);
		float $fatY=(`getAttr ($fitJoints[$i]+".fatY")`*(1-$weight)) + (`getAttr ($rlaChild+".fatY")`*$weight);
		float $fatZ=(`getAttr ($fitJoints[$i]+".fatZ")`*(1-$weight)) + (`getAttr ($rlaChild+".fatZ")`*$weight);
		addAttr -k 0 -ln fat -at double -dv $fat $inbetweenJoint;
		addAttr -k 0 -ln fatY -at double -dv $fatY $inbetweenJoint;
		addAttr -k 0 -ln fatZ -at double -dv $fatZ $inbetweenJoint;
		}
	parent $rlaChild $inbetweenJoint;
	}

//Analyze
$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	//Analyze $fitJointLabel
	$fitJointLabel[$i]=`asLabel $fitJoints[$i]`;

	//Analyze $fitJointSide
	$fitJointSide[$i]="_R";
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
		$fitJointSide[$i]="_M";

	//Analyze $fitJointNoMirror & $fitJointNoFlip
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`attributeExists noMirror $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noMirror")`)
				$fitJointNoMirror[$i]=1;
		if (`attributeExists noFlip $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noFlip")`)
				$fitJointNoFlip[$i]=1;
		}


	//Analyze $fitJointNoControl
	if (`attributeExists noControl $fitJoints[$i]`)
		$fitJointNoControl[$i]=`getAttr ($fitJoints[$i]+".noControl")`;

	//Analyze $fitJointIsEndJoint
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($tempString[0]=="")
		$fitJointIsEndJoint[$i]=1;
	else
		$fitJointIsEndJoint[$i]=0;

	//Analyze rotateOrder
	$fitJointRotOrder[$i]=`getAttr ($fitJoints[$i]+".rotateOrder")`;

	//Analyze Parent
	$tempString=`listRelatives -p -type joint $fitJoints[$i]`;
	$fitJointParent[$i]=$tempString[0];

	//Analyze ParentSide
	if ($fitJointParent[$i]!="")
		{
		$fitJointParentSide[$i]="_R";
		$temp=`xform -q -ws -t $fitJointParent[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$fitJointParentSide[$i]="_M";
		}

	//Analyze Child
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	$fitJointChild[$i]=$tempString[0];
	//Prefer X-down child
	if (size($tempString)>1)
		for ($y=0;$y<size($tempString);$y++)
			{
			$temp=`getAttr ($tempString[$y]+".t")`;
			if ($temp[1]>-0.01 && $temp[1]<0.01 && $temp[2]>-0.01 && $temp[2]<0.01)
				{
				$fitJointChild[$i]=$tempString[$y];
				break;
				}
			}

	//Analyze ChildSide
	if ($fitJointChild[$i]!="")
		{
		$fitJointChildSide[$i]="_R";
		$temp=`xform -q -ws -t $fitJointChild[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$fitJointChildSide[$i]="_M";
		}

	//Analyze TwistJoints
	if (`attributeExists twistJoints $fitJoints[$i]`)
		$fitJointTwistJoints[$i]=`getAttr ($fitJoints[$i]+".twistJoints")`;
	
	//Analyze UpTwistJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists twistJoints $fitJointParent[$i]`)
			if ($fitJoints[$i]==`asRlaChild $fitJointParent[$i]`)
				$fitJointUpTwistJoints[$i]=`getAttr ($fitJointParent[$i]+".twistJoints")`;

	//Analyze BendyJoints
	if (`attributeExists bendyJoints $fitJoints[$i]`)
		$fitJointBendyJoints[$i]=`getAttr ($fitJoints[$i]+".bendyJoints")`;

	//Analyze UpBendyJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists bendyJoints $fitJointParent[$i]`)
			if ($fitJoints[$i]==`asRlaChild $fitJointParent[$i]`)
				$fitJointUpBendyJoints[$i]=`getAttr ($fitJointParent[$i]+".bendyJoints")`;

	//Analyze inbetweenJoints
	if (`attributeExists inbetweenJoints $fitJoints[$i]`)
		$fitJointInbetweenJoints[$i]=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	if (`attributeExists unTwister $fitJoints[$i]`)
		if ($fitJointInbetweenJoints[$i]>0)
			$fitJointUnTwister[$i]=`getAttr ($fitJoints[$i]+".unTwister")`;

	//Analyze global
	if (`attributeExists "global" $fitJoints[$i]`)
		{
		$fitJointGlobal[$i]=1;
		$fitJointGlobalValue[$i]=`getAttr ($fitJoints[$i]+".global")`;
		}

	//Analyze Aim
	if (`attributeExists aim $fitJoints[$i]`)
		$fitJointsAim[$i]=1;

	//Analyze Wheel
	if (`attributeExists geoAttach $fitJoints[$i]`)
		{
		$fitJointsAttachTo[$i]=`getAttr -asString ($fitJoints[$i]+".geoAttach")`;
		if (`gmatch $fitJointsAttachTo[$i] "*__*"` && !`objExists $fitJointsAttachTo[$i]`)
			{
			$tempString[0]=`substitute "__" $fitJointsAttachTo[$i] ":"`;
			if (`objExists $tempString[0]`)
				$fitJointsAttachTo[$i]=$tempString[0];
			}
		}

	//Analyze Wheel
	if (`attributeExists wheel $fitJoints[$i]`)
		$fitJointsWheel[$i]=1;

	//Analyze IK
	$asFitJointIKInfo=`asFitJointIKInfo $fitJoints[$i]`;
	$fitJointIK[$i]=$asFitJointIKInfo[0];
	$fitJointIKStartJoint[$i]=$asFitJointIKInfo[1];
	$fitJointIKMiddleJoint[$i]=$asFitJointIKInfo[2];
	$fitJointIKEndJoint[$i]=$asFitJointIKInfo[3];
	$fitJointIKSolver[$i]=$asFitJointIKInfo[4];
	if ($asFitJointIKInfo[5]!="")
		$fitJointIKNumCtrls[$i]=$asFitJointIKInfo[5];
	if ($fitJointIKStartJoint[$i]==$fitJoints[$i])
		$isIKStart[$i]=1;
	if ($fitJointIKEndJoint[$i]==$fitJoints[$i])
		$isIKEnd[$i]=1;

	//Analyze Non-deform joints
	if (`gmatch $fitJointLabel[$i] "*Heel*"` || `gmatch $fitJointLabel[$i] "*BigToe*"` || `gmatch $fitJointLabel[$i] "*PinkyToe*"`)
		$fitJointNonDef[$i]=1;	

	//Analyze $footRotX
	if (`gmatch $fitJointLabel[$i] "*Foot*"`)
		{
		createNode -n rotationSampler1 transform;
		createNode -n rotationSampler2 -p rotationSampler1 transform;
		setAttr -type float3 rotationSampler1.r 90 0 -90;
		setAttr rotationSampler2.rotateOrder `getAttr ($fitJoints[$i]+".rotateOrder")`;
		orientConstraint $fitJoints[$i] rotationSampler2;
		$footRotX[$i]=`getAttr rotationSampler2.rx`*-1;
		delete rotationSampler1;
		}

	//Analyze $ikLocal
	if (`attributeExists ikLocal $fitJoints[$i]`)
		$ikLocal[$i]=`getAttr ($fitJoints[$i]+".ikLocal")`;

	//Analyze FirstAfterIK
	if ($fitJointParent[$i]!="")
		{
		$asFitJointIKInfo=`asFitJointIKInfo $fitJointParent[$i]`;
		if ($fitJointIK[$i]!=$asFitJointIKInfo[0])
			$fitJointFirstAfterIK[$i]=1;
		}
	}

//Analyze $centerBtwFeet
if (`attributeExists centerBtwFeet Root`)
	$centerBtwFeet=`getAttr Root.centerBtwFeet`;

//Analyze $ikLenght
for ($i=0;$i<size($fitJoints);$i++)
	{
	$ikLenght[$i]=0;
	if ($fitJointIK[$i]=="")
		continue;
	$tempString[0]=$fitJointIKEndJoint[$i];
	for ($a=0;$a<99;$a++)
		{
		if ($tempString[0]==$fitJointIKStartJoint[$i])
			break;
		$ikLenght[$i]+=`getAttr ($tempString[0]+".tx")`;
		$tempString=`listRelatives -p $tempString[0]`;
		}
	$ikLenght[$i]=abs($ikLenght[$i]);
	}

//height
float $height,$lenght,$width,$maxFitJoint,$minFitJoint;
for ($a=0;$a<3;$a++)
	{
	$maxFitJoint=0;
	$minFitJoint=99;
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		if ($pos[$a]>$maxFitJoint)
			$maxFitJoint=$pos[$a];
		if ($pos[$a]<$minFitJoint)
			$minFitJoint=$pos[$a];
		}
	if ($a==0) $width=$maxFitJoint-$minFitJoint;
	if ($a==1) $height=$maxFitJoint-$minFitJoint;
	if ($a==2) $lenght=$maxFitJoint-$minFitJoint;
	}
addAttr -ln height -at double Main;
setAttr -l 1 Main.height $height;
//$iconScaleFactor
float $iconScaleFactor=$height;
if ($lenght>$height && $lenght>$width) $iconScaleFactor=$lenght;
if ($width>$height && $width>$lenght) $iconScaleFactor=$width;
$iconScaleFactor=$iconScaleFactor/80.0;

//--Creation--//
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		$pos=`xform -q -ws -t $fitJoints[$i]`;
		$rot=`xform -q -ws -ro $fitJoints[$i]`;
		$joint=$fitJoints[$i]+$side;

		//Creation Deform
		select -cl;
		joint -n $joint;
		sets -add DeformSet $joint;
		setAttr ($joint+".rotateOrder") $fitJointRotOrder[$i];
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $joint;
		xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fat")` -ln fat -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatY")` -ln fatY -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatZ")` -ln fatZ -at double $joint;

		if ($side=="_L")
			{
			$tempString=`mirrorJoint -mirrorYZ -mirrorBehavior $joint`;
			if (`asMayaVersionAsFloat`<2012)
				$tempString[0]=$joint+"1";
			if ($fitJointNoFlip[$i])
				rotate -r -os 0 0 180 $tempString[0];
			$rot=`xform -q -ws -ro $tempString[0]`;
			xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
			delete $tempString[0];
			}

		//Creation TwistJoints
		select $joint;
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			joint -n ($fitJoints[$i]+"Part"+$y+$side);
			sets -add DeformSet ($fitJoints[$i]+"Part"+$y+$side);
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
			}			

		if ($isScapula[$i])
			addAttr -k 0 -ln Scapula -at bool -dv 1 $joint;

		if($fitJoints[$i]=="Root")
			connectAttr -f jointLayer.drawInfo Root_M.drawOverride;
		}

//Parent Deform
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		$parentJoint=$fitJointParent[$i]+$parentSide;
		if ($fitJointParent[$i]=="")
			parent $joint DeformationSystem;
		else
			parent $joint $parentJoint;
		}

//Parent TwistJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointTwistJoints[$i]<1)
			continue;refresh;

		float $twistDistance=`getAttr ($fitJointChild[$i]+$childSide+".tx")`/($fitJointTwistJoints[$i]+1.0);
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".tx") $twistDistance;
			//connect scale
			connectAttr ($fitJoints[$i]+$side+".sx") ($fitJoints[$i]+"Part"+$y+$side+".sx");
			connectAttr ($fitJoints[$i]+$side+".sy") ($fitJoints[$i]+"Part"+$y+$side+".sy");
			connectAttr ($fitJoints[$i]+$side+".sz") ($fitJoints[$i]+"Part"+$y+$side+".sz");
			}

		//reParent child to last twist
		if ($fitJointTwistJoints[$i]>0)
			parent ($fitJointChild[$i]+$childSide) ($fitJoints[$i]+"Part"+($fitJointTwistJoints[$i])+$side);
		}

//Freeze rotation(move to jointOrient)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		makeIdentity -a 1 -r 1 $joint;
		}

//Advanced Root
asCreateController "Root" "X" "_M" "Root";
xform -s 0.23 0.23 0.23 RootX_M;
setAttr RootX_M.rotateOrder 3;
makeIdentity -a 1 -s 1 RootX_M;
parent RootOffsetX_M RootSystem;
createNode -n RootZeroXform transform;
parent RootZeroXform RootX_M;
parentConstraint RootZeroXform FKSystem;
parentConstraint RootZeroXform IKRootConstraint;

//LegLock
createNode -n LegLockConstrained -p RootSystem transform;
pointConstraint Root_M LegLockConstrained;
createNode -n RootSpineAligned -p RootX_M transform;
orientConstraint -mo Root_M RootSpineAligned;
orientConstraint RootX_M RootSpineAligned LegLockConstrained;
addAttr -k 1 -ln legLock -at double -min 0 -max 10 -dv 0 RootX_M;
createNode -n LegLockUnitConversion unitConversion;
setAttr LegLockUnitConversion.conversionFactor 0.1;
connectAttr RootX_M.legLock LegLockUnitConversion.input;
connectAttr LegLockUnitConversion.output LegLockConstrained_orientConstraint1.RootX_MW0;
createNode -n LegLockReverse reverse;
connectAttr LegLockUnitConversion.output LegLockReverse.inputX;
connectAttr LegLockReverse.outputX LegLockConstrained_orientConstraint1.RootSpineAlignedW1;


//Creation FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;


		asCreateController "FK" $fitJoints[$i] $side $fitJoints[$i];
//		setAttr ("FKExtra"+$fitJoints[$i]+$side+".overrideEnabled") 1;

		select ("FK"+$fitJoints[$i]+$side);
		joint -n ("FKX"+$fitJoints[$i]+$side);
		connectAttr -f jointLayer.drawInfo ("FKX"+$fitJoints[$i]+$side+".drawOverride");
		setAttr ("FKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
//		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKX"+$fitJoints[$i]+$side);

		if ($fitJointInbetweenJoints[$i])
			{
			parent ("FKX"+$fitJoints[$i]+$side) ("FKExtra"+$fitJoints[$i]+$side);
			for ($y=0;$y<$fitJointInbetweenJoints[$i]+1;$y++)
				{
				$joint="FKX"+$fitJoints[$i]+"Part"+$y+$side;
				if ($y==0)
					{
					$joint="FKX"+$fitJoints[$i]+$side;
					connectAttr ("FK"+$fitJoints[$i]+$side+".t") ($joint+".t");
					}
				orientConstraint ("FK"+$fitJoints[$i]+$side) ("FKExtra"+$fitJoints[$i]+$side) $joint;
				setAttr ($joint+"_orientConstraint1.interpType") 2;//gives more accurate division by 3rds
				float $w=(1.0/($fitJointInbetweenJoints[$i]+1))*($y+1);
				setAttr ($joint+"_orientConstraint1.FK"+$fitJoints[$i]+$side+"W0") $w;
				setAttr ($joint+"_orientConstraint1.FKExtra"+$fitJoints[$i]+$side+"W1") (1-$w);
				}
			}

		if($fitJointGlobal[$i])
			{
			createNode -n ("FKGlobalStatic"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
			setAttr ("FKGlobalStatic"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			duplicate -n ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			duplicate -n ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			duplicate -n ("GlobalOffset"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);

			parent ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			parent ("FKExtra"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
			parent ("Global"+$fitJoints[$i]+$side) ("GlobalOffset"+$fitJoints[$i]+$side);
			parent ("GlobalOffset"+$fitJoints[$i]+$side) GlobalSystem;

			orientConstraint ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
			addAttr -k 1 -ln "Global"-at double -min 0 -max 10 -dv $fitJointGlobalValue[$i] ("FK"+$fitJoints[$i]+$side);
			createNode -n ("globalReverse"+$fitJoints[$i]+$side) reverse;
			createNode -n ("globalUnitConversion"+$fitJoints[$i]+$side) unitConversion;
			setAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".conversionFactor") 0.1;
			connectAttr ("FK"+$fitJoints[$i]+$side+".Global") ("globalUnitConversion"+$fitJoints[$i]+$side+".input");
			connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("globalReverse"+$fitJoints[$i]+$side+".inputX");
			connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.Global"+$fitJoints[$i]+$side+"W0");
			connectAttr ("globalReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");
			}

		if ($isIKEnd[$i])
			{
			createNode -n ("AlignIKTo"+$fitJoints[$i]+$side) transform;
			setAttr ("AlignIKTo"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			parent ("AlignIKTo"+$fitJoints[$i]+$side) ("FKX"+$fitJoints[$i]+$side);
			setAttr -type float3 ("AlignIKTo"+$fitJoints[$i]+$side+".t") 0 0 0;
			}

		if ($fitJointNoControl[$i])
			{
			setAttr -l 1 ("FK"+$fitJoints[$i]+$side+"Shape.v") 0;
			sets -rm ControlSet {("FK"+$fitJoints[$i]+$side),("FKExtra"+$fitJoints[$i]+$side)};
			}
		}

//Parenting FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		if ($fitJointParent[$i]=="")
			parent ("FKOffset"+$fitJoints[$i]+$side) FKSystem;

		else if ($fitJointFirstAfterIK[$i])
			{
			$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
			if (!`objExists $parentContraintToXform`)
				{
				createNode -n $parentContraintToXform -p FKSystem transform;
				//-mo as this prevents Ankle from flipping. nut this make scaleConstraint wrong
				asAlign $parentContraintToXform ($fitJointParent[$i]+$parentSide) 1 0 0 0;
//				parentConstraint -mo ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
				if ($fitJointParent[$i]=="Root")
					parentConstraint LegLockConstrained $parentContraintToXform;
				else
					parentConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;

				if ($fitJointParent[$i]=="Wrist")
					connectAttr Main.fingerVis ($parentContraintToXform+".v");
				}
			parent ("FKOffset"+$fitJoints[$i]+$side) $parentContraintToXform;
			connectAttr -f jointLayer.drawInfo ("FKOffset"+$fitJoints[$i]+$side+".drawOverride");
	
			}
		else
			parent ("FKOffset"+$fitJoints[$i]+$side) ("FKX"+$fitJointParent[$i]+$parentSide);
		}

//FK segmentScaleCompensate
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		//fingers/toes to scale up with hand/foot, and anything below head
		if (`gmatch $fitJoints[$i] "*Finger*"` || `gmatch $fitJoints[$i] "*Cup*"` || `gmatch $fitJoints[$i] "*Toes*"` || $fitJointParent[$i]=="Head")
			{
			setAttr ($fitJoints[$i]+$side+".segmentScaleCompensate") 0;
			$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
			if (`objExists $parentContraintToXform`)
				scaleConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
			}
		}

//Creation IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;

		select -cl;
		joint -n ("IKX"+$fitJoints[$i]+$side);
		setAttr ("IKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
		//Extra child under IKX (IKX2), for the FKIK to constrain to, as this avoids constrain flip.
		createNode -n ("IKX2"+$fitJoints[$i]+$side) -p ("IKX"+$fitJoints[$i]+$side) transform;
		if ($isIKStart[$i])
			{
			createNode -n ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			setAttr ("IKParentConstraint"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			createNode -n ("IKXOffset"+$fitJoints[$i]+$side) transform;
			setAttr ("IKXOffset"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			parent ("IKX"+$fitJoints[$i]+$side) ("IKXOffset"+$fitJoints[$i]+$side);
			if (`objExists ($fitJointParent[$i]+$parentSide)`)
				{
				$parentPos=`xform -q -ws -t ($fitJointParent[$i]+$parentSide)`;
				$parentRot=`xform -q -ws -ro ($fitJointParent[$i]+$parentSide)`;
				xform -ws -t $parentPos[0] $parentPos[1] $parentPos[2] -ro $parentRot[0] $parentRot[1] $parentRot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
				if ($fitJointIKSolver[$i]!="ikSplineSolver")
					{
					if ($fitJointParent[$i]=="Root")
						parentConstraint LegLockConstrained ("IKParentConstraint"+$fitJoints[$i]+$side);
					else
						parentConstraint ($fitJointParent[$i]+$parentSide) ("IKParentConstraint"+$fitJoints[$i]+$side);
					}
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKXOffset"+$fitJoints[$i]+$side);
				makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
				}
			else
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
			asAlign ("IKXOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 1 0 0;
			parent ("IKXOffset"+$fitJoints[$i]+$side) ("IKParentConstraint"+$fitJoints[$i]+$side);
			}
		else
			xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKX"+$fitJoints[$i]+$side);
		if ($isIKStart[$i] && $fitJointIKSolver[$i]=="ikRPsolver")
			{
			createNode -n ("IKMessureFrom"+$fitJoints[$i]+$side) -p ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			asAlign ("IKMessureFrom"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) 1 1 0 1;
			}
		if ($isIKStart[$i])
			connectAttr -f jointLayer.drawInfo ("IKX"+$fitJoints[$i]+$side+".drawOverride");
		}

//Parenting IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		if ($isIKStart[$i])
			parent ("IKParentConstraint"+$fitJoints[$i]+$side) IKJoints;
		else
			{
			parent ("IKX"+$fitJoints[$i]+$side) ("IKX"+$fitJointParent[$i]+$parentSide);
			makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
			}
		}

//Constraint to FK (&IK)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		parentConstraint ("FKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
		if ($fitJointIK[$i]!="")
//			parentConstraint -w 0 ("IKX2"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
			parentConstraint -w 0 ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
//		setAttr ($fitJoints[$i]+$side+"_parentConstraint1.interpType") 2;
		parent ($fitJoints[$i]+$side+"_parentConstraint1") ConstraintSystem;
		}


//UnTwister (inbetweener option)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointUnTwister[$i])
			{
			$tempString=`listRelatives -c -type joint ($fitJoints[$i]+"Part"+$fitJointInbetweenJoints[$i])`;
			string $unTwisterChild=$tempString[0];
			asCreateUnTwister $unTwisterChild $side $fitJoints[$i] $side "" 1 0 "";
			for ($y=1;$y<$fitJointInbetweenJoints[$i]+1;$y++)
				{
				createNode -n ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side) multiplyDivide;
				connectAttr ("TwistBalancer"+$unTwisterChild+$side+".rx") ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".input1X");
				setAttr ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".input2X") ((1.0/($fitJointInbetweenJoints[$i]+1))*$y);
				connectAttr ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".outputX") ($fitJoints[$i]+"Part"+$y+$side+"_parentConstraint1.target[0].targetOffsetRotateX");
				}
			}
		}

//Advanced Aim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointsAim[$i])
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;

		if (!`objExists ("Aim"+$fitJoints[$i])`)
			{
			createNode -n ("Aim"+$fitJoints[$i]) -p AimSystem transform;
			createNode -n ("AimOffset"+$fitJoints[$i]) -p ("Aim"+$fitJoints[$i]) transform;
			createNode -n ("AimFollow"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			createNode -n ("AimFollowOn"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			createNode -n ("AimFollowOff"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
			rename $tempString[0] ("Aim"+$fitJoints[$i]+"_M");
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideEnabled") 1;
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideColor") 17;
			sets -add ControlSet ("Aim"+$fitJoints[$i]+"_M");
			scale -r -p 0 0 0 ($scale/3.0) ($scale/3.0) ($scale/3.0) ("Aim"+$fitJoints[$i]+"_M.cv[0:4]");
			parent ("Aim"+$fitJoints[$i]+"_M") ("AimFollow"+$fitJoints[$i]);
			$pos=`xform -q -ws -t $fitJoints[$i]`;
			xform -ws -t 0 $pos[1] ($pos[2]+$scale*2) ("AimOffset"+$fitJoints[$i]);

			//.follow setup
			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 ("Aim"+$fitJoints[$i]+"_M");
			createNode -n ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M") unitConversion;
			setAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.conversionFactor") 0.1;
			connectAttr ("Aim"+$fitJoints[$i]+"_M.follow") ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.input");
			createNode -n ("Aim"+$fitJoints[$i]+"FollowReverse_M") reverse;
			connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("Aim"+$fitJoints[$i]+"FollowReverse_M.inputX");

			parentConstraint ("AimFollowOn"+$fitJoints[$i]) ("AimFollowOff"+$fitJoints[$i]) ("AimFollow"+$fitJoints[$i]);
			parentConstraint -mo ($fitJointParent[$i]+$fitJointParentSide[$i]) ("AimFollowOn"+$fitJoints[$i]);

			connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOn"+$fitJoints[$i]+"W0");
			connectAttr ("Aim"+$fitJoints[$i]+"FollowReverse_M.outputX") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOff"+$fitJoints[$i]+"W1");
			}
		
		if ($side!="_M")
			{
			createNode -n ("AimOffset"+$fitJoints[$i]+$side) -p ("Aim"+$fitJoints[$i]+"_M") transform;
			duplicate -n ("Aim"+$fitJoints[$i]+$side) ("Aim"+$fitJoints[$i]+"_M");
			$tempString=`listRelatives -c -f -type transform ("Aim"+$fitJoints[$i]+$side)`;
			if (`size ($tempString)`) delete $tempString;
			parent ("Aim"+$fitJoints[$i]+$side) ("AimOffset"+$fitJoints[$i]+$side);
			asLockAttr ("Aim"+$fitJoints[$i]+$side) 0 1 1 1;
			deleteAttr ("Aim"+$fitJoints[$i]+$side+".follow");
			setAttr -type float3 ("AimOffset"+$fitJoints[$i]+$side+".s") 0.2 0.2 0.2;
			asAlign ("AimOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 0 0 0;
			setAttr ("AimOffset"+$fitJoints[$i]+$side+".tz") 0;
			connectAttr Main.aimLRVis ("Aim"+$fitJoints[$i]+$side+"Shape.v");
			}
		createNode -n ("FKAim"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAim"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side) 1 1 0 1;
		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		parent ("FKAim"+$fitJoints[$i]+$side) $tempString[0];
		aimConstraint -aim 1 0 0 -upVector 0 0 -1 -worldUpVector 0 0 -1 -worldUpType "objectrotation" 
			-worldUpObject ($fitJointParent[$i]+$fitJointParentSide[$i]) ("Aim"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
		connectAttr Main.aimFKVis ("FK"+$fitJoints[$i]+$side+"Shape.v");
		}


//Advanced IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;

		//IKSp jointChain
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			createNode -n ("IKSp"+$fitJointIK[$i]+"Offset"+$side) -p IKJoints transform;
			asAlign ("IKSp"+$fitJointIK[$i]+"Offset"+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side) 1 0 0 1;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("FKX"+$fitJointIKStartJoint[$i]+$side) ($fitJointIKEndJoint[$i]+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side)`;
			select ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
			for ($y=0;$y<size($IKJoints);$y++)
				{
				joint -n ("IKSp"+$IKJoints[$y]+$side);
//				connectAttr ("IKSp"+$IKJoints[$y]+$side+".r") ("IKX"+$IKJoints[$y]+$side+".r");
//				parent ("IKSp"+$fitJointIK[$i]+$IKJoints[$y]+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
				}
			//distribute IKSp joints straight and evenly
			for ($y=0;$y<size($IKJoints);$y++)
				{
				float $posFactor=0;
				$posFactor=(1.0/(`size($IKJoints)`-1)*$y);
				pointConstraint -w (1-$posFactor) ($fitJointIKStartJoint[$i]+$side) ("IKSp"+$IKJoints[$y]+$side);
				pointConstraint -w $posFactor ($fitJointIKEndJoint[$i]+$side) ("IKSp"+$IKJoints[$y]+$side);
				delete ("IKSp"+$IKJoints[$y]+$side+"_pointConstraint1");
				}
			//parent IKSp joints
//			for ($y=1;$y<size($IKJoints)-1;$y++)
//				parent ("IKSp"+$IKJoints[$y+1]+$side) ("IKSp"+$IKJoints[$y]+$side);
			}

		//IKfake, first & last 2 joints in splineIK chain are `fake`, so that`real` can blend btw fake and ..AlignTo (for fixed end.rot in stretchy mode)
		//Also IKfake3 ensures correct twist distribution, as splikeIK twist assumes `end bone`
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			select ("IKSp"+$fitJointIKStartJoint[$i]+$side);
			joint -n ("IKfake0"+$fitJointIK[$i]+$side);
			setAttr -l 1 ("IKfake0"+$fitJointIK[$i]+$side+".v") 0;
			parent ("IKfake0"+$fitJointIK[$i]+$side) ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side);
			$tempString=`listRelatives -c ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
			parent $tempString[0] ("IKfake0"+$fitJointIK[$i]+$side);
			$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
			select $tempString[0];
//			select ("IKfake0"+$fitJointIK[$i]+$side);
			joint -n ("IKfake1"+$fitJointIK[$i]+$side);
			joint -n ("IKfake2"+$fitJointIK[$i]+$side);
			joint -n ("IKfake3"+$fitJointIK[$i]+$side);
			asAlign ("IKfake2"+$fitJointIK[$i]+$side) ("IKSp"+$fitJointIKEndJoint[$i]+$side) 1 1 1 0;
			$tempString=`listRelatives -p $tempString[0]`;
			parent ("IKfake1"+$fitJointIK[$i]+$side) $tempString[0];
			setAttr -l 1 ("IKfake1"+$fitJointIK[$i]+$side+".visibility") 0;
			setAttr ("IKfake3"+$fitJointIK[$i]+$side+".tx") `getAttr ("IKfake2"+$fitJointIK[$i]+$side+".tx")`;			
			}

		string $startJoint="IKX"+$fitJointIKStartJoint[$i]+$side;
		string $endJoint="IKX"+$fitJointIKEndJoint[$i]+$side;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			$startJoint="IKfake0"+$fitJointIK[$i]+$side;
			$endJoint="IKfake2"+$fitJointIK[$i]+$side;
			if (`objExists ("IKfake2"+$fitJointIK[$i]+$side)`)
				$endJoint="IKfake3"+$fitJointIK[$i]+$side;
			}
		joint -e -setPreferredAngles -children $startJoint;
		if (`objExists ("IKfake1"+$fitJointIK[$i]+$side)` && size($IKJoints)==2)
			{
			$tempString=`listRelatives -p ("IKfake1"+$fitJointIK[$i]+$side)`;
			if ($tempString[0]!="IKfake0"+$fitJointIK[$i]+$side)
				parent ("IKfake1"+$fitJointIK[$i]+$side) ("IKfake0"+$fitJointIK[$i]+$side);
			}
		$tempString=`ikHandle -n ("IK"+$fitJointIK[$i]+"Handle"+$side) -ccv 0 -ns 2 -sol $fitJointIKSolver[$i] -sj $startJoint -ee $endJoint`;
		rename $tempString[1] ("IK"+$fitJointIK[$i]+"Effector"+$side);
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Handle"+$side+".v") 0;
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Effector"+$side+".v") 0;
		setAttr ("IK"+$fitJointIK[$i]+"Effector"+$side+".rotateOrder") $fitJointRotOrder[$i];
		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//controller
			asCreateController "IK" $fitJointIK[$i] $side $fitJoints[$i];		
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+$side);
			//pole
			asCreateController "Pole" $fitJointIK[$i] $side $fitJoints[$i];	
			asLockAttr ("Pole"+$fitJointIK[$i]+$side) 0 1 1 1;
			//place poleVector
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
//			$startJointChildJoint=$tempString[0];
			createNode -n tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer2 -p tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer3 -p tempPoleVecPlacer2 transform;
			$tempString=`pointConstraint $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i] tempPoleVecPlacer1`;
			setAttr ($tempString[0]+"."+$fitJointIKStartJoint[$i]+"W0") `getAttr ($fitJointIKEndJoint[$i]+".tx")`;
			setAttr ($tempString[0]+"."+$fitJointIKEndJoint[$i]+"W1") `getAttr ($fitJointIKMiddleJoint[$i]+".tx")`;
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $fitJointIKStartJoint[$i] $fitJointIKMiddleJoint[$i] tempPoleVecPlacer2;
			setAttr tempPoleVecPlacer3.tx $ikLenght[$i];
			$temp=`xform -q -ws -t tempPoleVecPlacer3`;
			delete tempPoleVecPlacer1;
			xform -ws -t ($temp[0]*$b) $temp[1] $temp[2] ("PoleOffset"+$fitJointIK[$i]+$side);
			poleVectorConstraint ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side);
			$tempString[0]=`createNode annotationShape`;
			$tempString=`listRelatives -p $tempString[0]`;
			string $direction=`rename $tempString[0] ("PoleAnnotation"+$fitJointIK[$i]+$side)`;
			setAttr ($direction+"Shape.overrideEnabled") 1;
			setAttr ($direction+"Shape.overrideDisplayType") 2;
			connectAttr Main.arrowVis ($direction+".v");
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
			parent $direction ("IKX"+$fitJointIKMiddleJoint[$i]+$side);
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $direction;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+"Shape.worldMatrix[0]") ($direction+"Shape.dagObjectMatrix[0]");
			//orientCnstraint last segment to controller
			createNode -n ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			createNode -n ("IKFKAligned"+$fitJointIK[$i]+$side) -p ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) transform;
			asAlign ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
			orientConstraint ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKEndJoint[$i]+$side);
			//$ikLocal
			if ($ikLocal[$i])
				{
				asCreateController "IKLocal" $fitJointIK[$i] $side $fitJoints[$i];
				asAlign ("IKLocalOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				asLockAttr ("IKLocal"+$fitJointIK[$i]+$side) 1 0 1 1;
				parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKLocal"+$fitJointIK[$i]+$side);
				}
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) IKHandle;
			string $crvCmd="curve -n IK"+$fitJointIK[$i]+"Curve"+$side+" -d 3";
			for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
				 $crvCmd+=" -p 0 0 0";
			eval ($crvCmd);
			$tempString=`listRelatives -s ("IK"+$fitJointIK[$i]+"Curve"+$side)`;
			rename $tempString[0] ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
			parent ("IK"+$fitJointIK[$i]+"Curve"+$side) IKCurve;

			$ikControlNr=1;
			for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
				{
				spaceLocator -n ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
				setAttr -l 1 ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+".v") 0;
				connectAttr ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

				float $posFactor=0;
				if ($z>1)
					$posFactor=($z-1)/($fitJointIKNumCtrls[$i]-1.0);
				if ($z>$fitJointIKNumCtrls[$i]-1)
				    $posFactor=1;
				float $invPosFactor=1-$posFactor;
				$tempString=`pointConstraint -w $invPosFactor ("IKSp"+$fitJointIKStartJoint[$i]+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side)`;
				pointConstraint -w $posFactor ("IKSp"+$fitJointIKEndJoint[$i]+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
				delete $tempString[0];

				if ($z!=1 && $z!=$fitJointIKNumCtrls[$i])//Controller for each loc except second and seconLast (they are for stiffness)
					{
					asCreateController "IK" ($fitJointIK[$i]+$ikControlNr) $side $fitJointIKStartJoint[$i];
					parent ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) IKRootConstraint;
					asAlign ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) 1 1 0 1;
					parent ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
					$rot=`xform -q -ws -ro ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
					xform -s 0.1 1 1 ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
					$ikControlNr++;
					}
				}
			//inbetween Ik Controllers to follow start & end (Spine only)
			if (`gmatch $fitJointIK[$i] "*Spine*"`)
				for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
					{
					float $weight=(1.0/($fitJointIKNumCtrls[$i]-1))*($z-1);
					parentConstraint -mo -w (1-$weight) ("IK"+$fitJointIK[$i]+"1"+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
					parentConstraint -mo -w $weight ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
					}
			//inbetween Ik Controllers: lock rotate
			for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
				{
				asLockAttr ("IK"+$fitJointIK[$i]+$z+$side) 0 1 0 1;
				asLockAttr ("IKExtra"+$fitJointIK[$i]+$z+$side) 0 1 0 1;
				}

			parent ("IK"+$fitJointIK[$i]+"Locator1"+$side) ("IK"+$fitJointIK[$i]+"1"+$side);
			parent ("IK"+$fitJointIK[$i]+"Locator"+$fitJointIKNumCtrls[$i]+$side) ("IK"+$fitJointIK[$i]+($ikControlNr-1)+$side);
			connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") ("IK"+$fitJointIK[$i]+"Handle"+$side+".inCurve");

			createNode -n ("IKCurveInfo"+$fitJointIK[$i]+$side) curveInfo;
			connectAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.worldSpace[0]") ("IKCurveInfo"+$fitJointIK[$i]+$side+".inputCurve");

			//if 1 Ik control, build 2, but expose 1
			if (`attributeExists ikCtrls $fitJointIKStartJoint[$i]`)
				if(`getAttr ($fitJointIKStartJoint[$i]+".ikCtrls")`==1)
					{
					sets -rm ControlSet ("IK"+$fitJointIK[$i]+"1"+$side) ("IKExtra"+$fitJointIK[$i]+"1"+$side);
					setAttr -l 1 ("IK"+$fitJointIK[$i]+"1"+$side+".v") 0;
					}

			//IK spline stretchy
			addAttr -k 1 -ln stretchy -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			createNode -n ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".operation") 2;
			createNode -n ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".operation") 2;
			connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".outputX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input1X");
			connectAttr ("Main.scaleX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input2X");
			connectAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength") ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input1X");
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input2X") `getAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength")`;
			createNode -n ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
			setAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stretchy") ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
			createNode -n ("stretchy"+$fitJointIK[$i]+"Reverse"+$side) reverse;
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".inputX");
			select `listRelatives -ad -type joint $startJoint`;
			select -d ("IKSp"+$fitJointIKEndJoint[$i]+$side);
			$tempString=`ls -sl`;
			for ($x=0;$x<size($tempString);$x++)
				{
				createNode -n ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side) multiplyDivide;
				setAttr ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".input1X") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".input2X");

				createNode -n ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side) blendTwoAttr;
				connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".attributesBlender");
				setAttr ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".input[0]") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".outputX") ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".input[1]");
				connectAttr ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".output") ($tempString[$x]+".translateX");
				}

			//IKFake (ChestOrientationLock)
			$tempString=`spaceLocator -n ("IKFake1UpLoc"+$fitJointIK[$i]+$side)`;
			$loc1=$tempString[0];
			asAlign $loc1 ("IKfake1"+$fitJointIK[$i]+$side) 1 1 0 0;
			parent $loc1 ("IKfake1"+$fitJointIK[$i]+$side);
			setAttr ($loc1+".translateY") 1;
			$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
			$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $loc1 ("IKfake2"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) $tempString[0]`;
			$constraint=$tempString[0];
			$attrs=`listAttr -k -ud $constraint`;
			connectAttr ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".outputX") ($tempString[0]+"."+$attrs[0]);
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($tempString[0]+"."+$attrs[1]);


			createNode -n ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+$side) 1 1 0 0;
			parent ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IK"+$fitJointIK[$i]+"1"+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IKfake2"+$fitJointIK[$i]+$side) 1 1 0 0;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) ("IKfake2"+$fitJointIK[$i]+$side) 1 0 0 0;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+$side) 0 1 0 0;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistTo"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side) 1 1 0 0;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignUnIKTwistToOffset"+$side);

			parentConstraint ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+$side);

			//IK spline FixedEnd
			addAttr -k 1 -ln fixedEnd -at bool -dv 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side) -p ("IKSp"+$fitJointIKEndJoint[$i]+$side) transform;
			$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side) $tempString[0];
			parentConstraint ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side);

			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side) blendColors;
			createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side) blendColors;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side+".t") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side+".color1");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"ConstraintHolder"+$side+".r") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side+".color1");
			connectAttr ($tempString[0]+".t") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side+".color2");
			connectAttr ($tempString[0]+".r") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side+".color2");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side+".output") ("IKSp"+$fitJointIKEndJoint[$i]+$side+".t");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side+".output") ("IKSp"+$fitJointIKEndJoint[$i]+$side+".r");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".fixedEnd") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendT"+$side+".blender");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".fixedEnd") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"FixedEndBlendR"+$side+".blender");
			


			//IK spline Stiff
			$ikControlNr=1;
			for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
				{
				if ($z!=1 && $z!=$fitJointIKNumCtrls[$i])
					continue;
				if ($z==$fitJointIKNumCtrls[$i])
					$ikControlNr=$fitJointIKNumCtrls[$i];
				addAttr -k 1 -ln stiff -at double -min 0 -max 10 -dv 5 ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
				createNode -n ("IKStiff"+$fitJointIK[$i]+$z+$side) setRange;
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".minX") 0.01;
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".oldMinX") 0;
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".oldMaxX") 10;
				connectAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".stiff") ("IKStiff"+$fitJointIK[$i]+$z+$side+".valueX");
				createNode -n ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) transform;
				if ($z==1)
					asAlign ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) ($fitJointIKStartJoint[$i]+$side) 1 0 0 0;
				else
					asAlign ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) ($fitJointIKEndJoint[$i]+$side) 1 0 0 0;
				string $aimAt=$fitJointIKEndJoint[$i]+$side;
				float $aimV[3]={1,0,0};
				if ($z==$fitJointIKNumCtrls[$i])
					$aimAt=$fitJointIKStartJoint[$i]+$side;
				$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($fitJointIKStartJoint[$i]+$side) $aimAt ("IKStiffOrient"+$fitJointIK[$i]+$z+$side)`;
				delete $tempString[0];
				parent ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) ("IKStiffOrient"+$fitJointIK[$i]+$z+$side);
				parent ("IKStiffOrient"+$fitJointIK[$i]+$z+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
				setAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".maxX") ($ikLenght[$i]/2.0);
				connectAttr ("IKStiff"+$fitJointIK[$i]+$z+$side+".outValueX") ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+".translateX");

//				if ($fitJointIKNumCtrls[$i]<3)
//					setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".stiff") 10;
				}

			parentConstraint -mo ("IK"+$fitJointIK[$i]+"0"+"AlignTo"+$side) ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side);
			asCreateUnTwister $fitJoints[$i] $side $fitJointIKStartJoint[$i] $side $fitJointIK[$i] $b 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"AlignTo");
			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("IK"+$fitJointIK[$i]+"Handle"+$side+".twist");

			//IK spline Follow
			if ($fitJointIKSolver[$i]=="ikSplineSolver")
				{
				$ikControlNr=1;
				for ($z=0;$z<$fitJointIKNumCtrls[$i]+2;$z++)
					if ($z!=1 && $z!=$fitJointIKNumCtrls[$i])//Controller for each loc except second and seconLast (they are for stiffness)
						{
						$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
						string $ikParent=$tempString[0];
						if ($ikParent!="DeformationSystem")
							asFollow ("IK"+$fitJointIK[$i]+$ikControlNr+$side) ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) $ikParent;
						$ikControlNr++;
						}
				}

			//Constraint to IKSp jointChain
			for ($y=0;$y<size($IKJoints);$y++)
				{
				createNode -n ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) -p ("IKSp"+$IKJoints[$y]+$side) transform;
				asAlign ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ($IKJoints[$y]+$side) 1 1 0 0;
				parentConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);
				}
			}

		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//PoleAim (PoleLeg avoid flipping in the forward plane)
			if (`gmatch $fitJointIK[$i] "*Leg*"`)
				{
				createNode -n ("PoleAim"+$fitJointIK[$i]+$side) transform;
				asAlign ("PoleAim"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side) 1 0 0 0;
//				if ($msLegAim[$i]!="")
//					asAlign ("PoleAim"+$fitJointIK[$i]+$side) ($msLegAim[$i]+$side) 1 0 0 0;
				$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side)`;
				$constraint=$tempString[0];
				parent ("PoleAim"+$fitJointIK[$i]+$side) ("IKHandle");
				pointConstraint Root_M ("PoleAim"+$fitJointIK[$i]+$side);
				}

			//Follow
			if (!`gmatch $fitJointIK[$i] "*Leg*"`)
				{
				$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
				string $ikParent=$tempString[0];
				asFollow ("IK"+$fitJointIK[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$side) $ikParent;
				}
			if (`gmatch $fitJointIK[$i] "*Leg*"`)
				asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side);
			else
				asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
			}
		}


//Advanced FKIK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKStart[$i])
			continue;

		duplicate -n ("FKIK"+$fitJointIK[$i]+$side) "FKIK_icon";
		xform -ws -t 0 0 0 -ro 0 0 0 ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".scale") $iconScaleFactor $iconScaleFactor $iconScaleFactor;
		setAttr ("FKIK"+$fitJointIK[$i]+$side+".rotateY") 90;
		makeIdentity -a 1 -t 1 -r 1 -s 1 ("FKIK"+$fitJointIK[$i]+$side);

		createNode -n ("FKIKParentConstraint"+$fitJointIK[$i]+$side) transform;
		$tempString=`listRelatives -p -type joint ($fitJointIKStartJoint[$i]+$side)`;
		string $parent=$tempString[0];
		if(`objExists $parent`)
			parentConstraint $parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		else
			parentConstraint ($fitJointIKStartJoint[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side) ("FKIKSystem");

		$sca=`xform -q -r -s $fitJointIKStartJoint[$i]`;
		$sca[0]*=$fitSkeletonScaleX;$sca[1]*=$fitSkeletonScaleX;$sca[2]*=$fitSkeletonScaleX;
		parent ("FKIK"+$fitJointIK[$i]+$side) ($fitJointIKStartJoint[$i]+$side);
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".t") ($iconScaleFactor*$b*5) 0 ($iconScaleFactor*$b*5);
		//`fat` based side-distance
		if (`attributeExists fatZ $fitJoints[$i]`)
			{
			$pos=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[0]")`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[5]")`;
			$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`*$b;
			setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") ((`getAttr ($fitJoints[$i]+".fat")`*`getAttr ($fitJoints[$i]+".fatZ")`*$b)+($dist/2.0));
			}

		//ensure its moved to `outside` direction
		if ($side!="_M")
			{
			$pos=`xform -q -ws -t ($fitJointIKStartJoint[$i]+$side)`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side)`;
			if ($side=="_R" && $pos2[0]>$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			if ($side=="_L" && $pos2[0]<$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			}

		parent ("FKIK"+$fitJointIK[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		asLockAttr ("FKIK"+$fitJointIK[$i]+$side) 1 1 1 1;

		addAttr -k 1 -ln FKIKBlend -at double -min 0 -max 10 -dv 0 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln autoVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -k 0 -cb 1 ("FKIK"+$fitJointIK[$i]+$side+".autoVis");
		addAttr -k 1 -ln FKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln IKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -ln startJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".startJoint") $fitJointIKStartJoint[$i];
		addAttr -ln middleJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".middleJoint") $fitJointIKMiddleJoint[$i];
		addAttr -ln endJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".endJoint") $fitJointIKEndJoint[$i];

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side) reverse;
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".inputX");

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side) condition;
		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side) setRange;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".minX") 10;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".oldMaxX") 10;

		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".autoVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".firstTerm");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".IKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueR");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueG");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".valueX");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseR");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".outValueX") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseG");


		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("PoleOffset"+$fitJointIK[$i]+$side+".visibility");
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			for ($z=1;$z<$fitJointIKNumCtrls[$i]+1;$z++)
				connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$z+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IK"+$fitJointIK[$i]+"Curve"+$side+".visibility");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideDisplayType") 1;
			}
		connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR")  ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side+".visibility");
		connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorG")  ("FKOffset"+$fitJointIKStartJoint[$i]+$side+".visibility");
		}


//FKIK connect to constraints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointIK[$i]!="")
			{
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX")       ($fitJoints[$i]+$side+"_parentConstraint1.FKX"+$fitJoints[$i]+$side+"W0");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($fitJoints[$i]+$side+"_parentConstraint1.IKX"+$fitJoints[$i]+$side+"W1");
			}
	}


//Advanced FootRoll
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!`gmatch $fitJointLabel[$i] "*Foot*"`)
			continue;

		//find $ankle,$heel,$toes,$toesEnd
		$ankle=$fitJoints[$i];
		$heel="";$toes="";$toesEnd="";$bigToe="";$pinkyToe="";
		$tempString=`listRelatives -ad -type joint $ankle`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*Heel*"`)
				$heel=$tempString[$y];
			if (`gmatch $childLabel "*Toes*"` && !`gmatch $childLabel "*ToesEnd*"`)
				$toes=$tempString[$y];
			if (`gmatch $childLabel "*BigToe*"`)
				$bigToe=$tempString[$y];
			if (`gmatch $childLabel "*PinkyToe*"`)
				$pinkyToe=$tempString[$y];
			if (`gmatch $childLabel "*ToesEnd*"`)
				$toesEnd=$tempString[$y];
			}
		if ($heel=="" || $toes=="" || $toesEnd=="")
			continue;

		//create FootRoll IkJoints
		select ("IKX"+$ankle+$side);
		joint -n ("IKX"+$toes+$side);
		asAlign ("IKX"+$toes+$side) ($toes+$side) 1 1 1 1; 
		joint -n ("IKX"+$toesEnd+$side);
		asAlign ("IKX"+$toesEnd+$side) ($toesEnd+$side) 1 1 1 1;
//		createNode -n ("FKIKBlend"+$toesEnd+$side) blendColors;
//		connectAttr ("FKX"+$fitJoints[$i]+$side+".r") ("FKIKBlend"+$toesEnd+$side+".color2");
//		connectAttr ("IKX"+$fitJoints[$i]+$side+".r") ("FKIKBlend"+$toesEnd+$side+".color1");
//		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("FKIKBlend"+$toesEnd+$side+".blender");

//		parentConstraint ("IKX"+$toes+$side) ($toes+$side);
//		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX")       ($toes+$side+"_parentConstraint1.FKX"+$toes+$side+"W0");
//		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($toes+$side+"_parentConstraint1.IKX"+$toes+$side+"W1");
		$tempString=`listRelatives -p ("FKExtra"+$toes+$side)`;
		createNode -n ("FKFootRollIK"+$toes+$side) -p $tempString[0] transform;
		asAlign ("FKFootRollIK"+$toes+$side) ("FKExtra"+$toes+$side) 1 1 0 1;
		duplicate -n ("FKFootRollIKStatic"+$toes+$side) ("FKFootRollIK"+$toes+$side);
		duplicate -n ("IKFootRoll"+$toes+$side) ("FKFootRollIK"+$toes+$side);
		parent ("IKFootRoll"+$toes+$side) ("IKX"+$toes+$side);
		parent ("FKExtra"+$toes+$side) ("FKFootRollIK"+$toes+$side);
		orientConstraint ("IKFootRoll"+$toes+$side) ("FKFootRollIKStatic"+$toes+$side) ("FKFootRollIK"+$toes+$side);
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("FKFootRollIK"+$toes+$side+"_orientConstraint1.IKFootRoll"+$toes+$side+"W0");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX") ("FKFootRollIK"+$toes+$side+"_orientConstraint1.FKFootRollIKStatic"+$toes+$side+"W1");

		addAttr -k 1 -ln swivel -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln toe -at double ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln roll -at double -min -5 -max 10 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln rollAngle -at double -dv 25 ("IK"+$fitJointIK[$i]+$side);

		connectAttr ("IK"+$fitJointIK[$i]+$side+".swivel") ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX");
		$tempString=`listConnections ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX")`;
		setAttr ($tempString[0]+".conversionFactor") 0.1;

		createNode -n ("IK"+$fitJointIK[$i]+"FootRoll"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
		$temp=`xform -q -ws -t ($fitJointIKEndJoint[$i]+$side)`;
		xform -ws -t $temp[0] $temp[1] $temp[2] ("IK"+$fitJointIK[$i]+"FootRoll"+$side);
		setAttr ("IK"+$fitJointIK[$i]+"FootRoll"+$side+".ry") ($footRotX[$i]*$b);

		asCreateController "Roll" $toes $side $toes;
		asCreateController "Roll" $toesEnd $side $toesEnd;
		asCreateController "Roll" $heel $side $heel;

		setAttr ("RollOffset"+$heel+$side+".ry") ($footRotX[$i]*$b);
		setAttr ("RollOffset"+$toes+$side+".ry") ($footRotX[$i]*$b);
		setAttr ("RollOffset"+$toesEnd+$side+".ry") ($footRotX[$i]*$b);

		parent ("RollOffset"+$toes+$side) ("Roll"+$toesEnd+$side);
		parent ("RollOffset"+$toesEnd+$side) ("Roll"+$heel+$side);
		parent ("RollOffset"+$heel+$side) ("IK"+$fitJointIK[$i]+$side);

		//Pinky/index toe side2side rocking
		if (`objExists $toes`)
			{
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
//			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rotateOrder") 5;
			asAlign ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side) 1 1 0 0;
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $bigToe`)
				$pos=`xform -q -ws -t $bigToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side);
			duplicate -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $pinkyToe`)
				$pos=`xform -q -ws -t $pinkyToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side) clamp;
			if ($side=="_R")
				setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".minR") -200;
			else
				setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".maxR") 200;
			connectAttr ("Roll"+$toes+$side+".rz") ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rz");
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side) clamp;
			if ($side=="_R")
				setAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".maxR") 200;
			else
				setAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".minR") -200;
			connectAttr ("Roll"+$toes+$side+".rz") ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side+".rz");
			parent ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("RollOffset"+$heel+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			if (`objExists ("IKLocalOffset"+$fitJointIK[$i]+$side)`)
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);

			createNode -n ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side) -p ("Roll"+$toes+$side) transform;
			xform -os -t 0 0 0 -ro 0 0 0 ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockReverseMultiplyDivide"+$side) multiplyDivide;
			connectAttr ("Roll"+$toes+$side+".rz") ("IK"+$fitJointIK[$i]+"FootRockReverseMultiplyDivide"+$side+".input1Z");
			setAttr ("IK"+$fitJointIK[$i]+"FootRockReverseMultiplyDivide"+$side+".input2Z") -1;
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockReverseMultiplyDivide"+$side+".outputZ") ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side+".rz");
			}

		if ($ikLocal[$i])
			{
			createNode -n ("RollOffsetOffset"+$heel+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			asAlign ("RollOffsetOffset"+$heel+$side) ("RollOffset"+$heel+$side) 1 1 0 0;
			parent ("RollOffset"+$heel+$side) ("RollOffsetOffset"+$heel+$side);
			parent ("RollOffsetOffset"+$heel+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			}

		$tempString=`ikHandle -n ("IK"+$toes+"Handle"+$side) -s "sticky" -sol ikSCsolver -sj ("IKX"+$fitJointIKEndJoint[$i]+$side) -ee ("IKX"+$toes+$side)`;
		rename $tempString[1] ("IK"+$toes+"Effector"+$side);
		parent ("IK"+$toes+"Handle"+$side) ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side);
		setAttr -l 1 ("IK"+$toes+"Handle"+$side+".v") 0;

		$tempString=`ikHandle -n ("IK"+$toesEnd+"Handle"+$side) -s "sticky" -sol ikSCsolver -sj ("IKX"+$toes+$side) -ee ("IKX"+$toesEnd+$side)`;
		rename $tempString[1] ("IK"+$toesEnd+"Effector"+$side);
		createNode -n ("IK"+$fitJointIK[$i]+"LiftToe"+$side) -p ("Roll"+$toesEnd+$side) transform;
		asAlign ("IK"+$fitJointIK[$i]+"LiftToe"+$side) ($toes+$side) 1 0 0 0;
		parent ("IK"+$toesEnd+"Handle"+$side) ("IK"+$fitJointIK[$i]+"LiftToe"+$side);
		setAttr -l 1 ("IK"+$toesEnd+"Handle"+$side+".v") 0;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".toe") ("IK"+$fitJointIK[$i]+"LiftToe"+$side+".rx");

		//move LegIKHandel to end of RollHierarchy
		parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side);

		createNode -n ($fitJointIK[$i]+$side+"AngleReverse") multiplyDivide;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ($fitJointIK[$i]+$side+"AngleReverse.input1X");
		setAttr ($fitJointIK[$i]+$side+"AngleReverse.input2X") -1;

		createNode -n ("IKRollAngle"+$fitJointIK[$i]+$side) setRange;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueY");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueZ");
		connectAttr ($fitJointIK[$i]+$side+"AngleReverse.output.outputX") ("IKRollAngle"+$fitJointIK[$i]+$side+".minX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ("IKRollAngle"+$fitJointIK[$i]+$side+".maxY");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ("IKRollAngle"+$fitJointIK[$i]+$side+".maxZ");
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMinX") -5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMaxY") 5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMinZ") 5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMaxZ") 10;

		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueX") ("RollOffset"+$heel+$side+".rotateX");
		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueY") ("RollOffset"+$toes+$side+".rotateX");
		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueZ") ("RollOffset"+$toesEnd+$side+".rotateX");
		}
	if (`objExists deleteMe`)
		delete deleteMe;


//Advanced LegAim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKStart[$i])
			continue;
		$tempString=`listRelatives -p $fitJoints[$i]`;
		$scapula=$tempString[0];
		if ($scapula!="")
			{
			$tempString[0]=`asLabel $scapula`;
			if (!`gmatch $tempString[0] "*LegAim*"`)
				continue;
			}

		addAttr -k 1 -ln legAim -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln legAimSDK -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$side);
		$tempString=`listRelatives -p ("FKOffset"+$scapula+$side)`;
		$parent=$tempString[0];
		createNode -n ("LegAim"+$scapula+$side) -p $parent transform;
		asAlign ("LegAim"+$scapula+$side) ("FKOffset"+$scapula+$side) 1 1 0 0;
		duplicate -n ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
		duplicate -n ("LegAimOff"+$scapula+$side) ("LegAim"+$scapula+$side);

//		aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "object" -worldUpObject ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
		aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
//		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
//		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "object" -worldUpObject ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
		asAlign ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) 1 1 0 0;
		orientConstraint ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
		parent ("FKOffset"+$scapula+$side) ("LegAim"+$scapula+$side);

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side) unitConversion;
		setAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".legAim") ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".input");

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side) multiplyDivide;
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input1X");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input2X");

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side) reverse;
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".inputX");
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOn"+$scapula+$side+"W1");
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOff"+$scapula+$side+"W0");

		//LegAimSDK
		createNode -n ("IK"+$fitJointIK[$i]+"LegAimSDKUnitConversion"+$side) unitConversion;
		setAttr ("IK"+$fitJointIK[$i]+"LegAimSDKUnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".legAimSDK") ("IK"+$fitJointIK[$i]+"LegAimSDKUnitConversion"+$side+".input");
		createNode -n ("IK"+$fitJointIK[$i]+"LegAimSDKReverse"+$side) reverse;
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimSDKUnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimSDKReverse"+$side+".inputX");

		createNode -n ("LegAimBlender"+$scapula+$side) -p ("LegAim"+$scapula+$side) transform;
		createNode -n ("LegAimSDK"+$scapula+$side) -p ("LegAim"+$scapula+$side) transform;
		createNode -n ("LegAimNONSDK"+$scapula+$side) -p ("LegAim"+$scapula+$side) transform;
		parent ("FKOffset"+$scapula+$side) ("LegAimBlender"+$scapula+$side);
		parentConstraint ("LegAimSDK"+$scapula+$side) ("LegAimNONSDK"+$scapula+$side) ("LegAimBlender"+$scapula+$side);
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimSDKUnitConversion"+$side+".output") ("LegAimBlender"+$scapula+$side+"_parentConstraint1.LegAimSDK"+$scapula+$side+"W0");
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimSDKReverse"+$side+".outputX") ("LegAimBlender"+$scapula+$side+"_parentConstraint1.LegAimNONSDK"+$scapula+$side+"W1");

		createNode -n ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
		$tempString=`listRelatives -p ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"_Shape")`;
		rename $tempString[0] ("IKdistanceForLegAim"+$fitJointIK[$i]+$side);
		parent ("IKdistanceForLegAim"+$fitJointIK[$i]+$side) ("IKMessure");
		setAttr -l 1 ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".visibility") 0;

		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side+".v") 0;
		parent ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side) IKMessure;
		duplicate -n ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side) ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);
		connectAttr ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side+".translate") ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".startPoint");
		connectAttr ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side+".translate") ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".endPoint");
		pointConstraint ("LegAim"+$scapula+$side) ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side);
		pointConstraint ("IK"+$fitJointIK[$i]+$side) ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);

		float $defaultDistance=`getAttr ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"Shape.distance")`;
		float $defaultAngleDirection=`getAttr ($fitJoints[$i]+$side+".jointOrientZ")`;
		float $defaultAngle=90;
		if ($defaultAngleDirection>0)
			$defaultAngle=-90;
		float $defaultUnstretchedLenght=0;
		$parent=$fitJointIKEndJoint[$i];
		while ($parent!=$fitJointIKStartJoint[$i])
			{
			$defaultUnstretchedLenght+=`getAttr ($parent+".tx")`;
			$tempString=`listRelatives -p $parent`;
			$parent=$tempString[0];
			}
		$defaultUnstretchedLenght+=`getAttr ($parent+".tx")`;

		createNode -n tempSampler -p ("FK"+$scapula+$side) transform;
		parent tempSampler ("LegAim"+$scapula+$side);
		float $defaultOffsetAngle=`getAttr tempSampler.rz`;
		delete tempSampler;
		if ($side=="_L")
			$defaultOffsetAngle=`getAttr ("LegAimSDK"+$scapula+"_R.defaultOffsetAngle")`;
		addAttr -k 0 -ln defaultOffsetAngle -at double -dv $defaultOffsetAngle ("LegAimSDK"+$scapula+$side);

		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv $defaultDistance -cd ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"Shape.distance") ("LegAimSDK"+$scapula+$side+".rz");
		setDrivenKeyframe -itt "linear" -ott "linear" -v $defaultAngle -dv 0 -cd ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"Shape.distance") ("LegAimSDK"+$scapula+$side+".rz");
		setDrivenKeyframe -itt "linear" -ott "linear" -v ($defaultOffsetAngle*-1) -dv $defaultUnstretchedLenght -cd ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"Shape.distance") ("LegAimSDK"+$scapula+$side+".rz");

		}

//Advanced Scaling
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

//		if ($fitJointIsEndJoint[$i])
//			continue;

		if ($fitJointIK[$i]!="")
			{
			createNode -n ("ScaleBlend"+$fitJoints[$i]+$side) blendColors;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color1") 1 1 1;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color2") 1 1 1;
			if (`objExists ("FK"+$fitJoints[$i]+$side)`)
				connectAttr ("FK"+$fitJoints[$i]+$side+".scale") ("ScaleBlend"+$fitJoints[$i]+$side+".color2");
			connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".output") ($fitJoints[$i]+$side+".scale");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("ScaleBlend"+$fitJoints[$i]+$side+".blender");
			}
		else if (`objExists ("FK"+$fitJoints[$i]+$side)`)
			connectAttr ("FK"+$fitJoints[$i]+$side+".scale") ($fitJoints[$i]+$side+".scale");
		}

for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

//		if ($fitJointIsEndJoint[$i])
//			continue;

		if ($fitJoints[$i]==$fitJointIKEndJoint[$i])
			{
			if ($fitJointIKSolver[$i]=="ikRPsolver")
				{
				connectAttr ("IK"+$fitJointIK[$i]+$side+".scale") ("ScaleBlend"+$fitJoints[$i]+$side+".color1");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".scale") ("IKX"+$fitJoints[$i]+$side+".scale");
				}
			if ($fitJointIKSolver[$i]=="ikSplineSolver")
				{
				$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;
				for ($y=0;$y<size($IKJoints);$y++)
					{
					createNode -n ("IKScaler"+$IKJoints[$y]+$side) -p IKHandle transform;
					createNode -n ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side) multiplyDivide;
					connectAttr ("IKScaler"+$IKJoints[$y]+$side+".scale") ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".input1");
					connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".output") ("ScaleBlend"+$IKJoints[$y]+$side+".color1");		
					for ($z=0;$z<$fitJointIKNumCtrls[$i];$z++)
						{
		        float $yy=(1.0/(size($IKJoints)-1))*$y;
		        float $zz=(1.0/($fitJointIKNumCtrls[$i]-1))*$z;
		        $weight=1-(abs($yy-$zz));
		        $weight=` smoothstep 0.5 1 $weight`;
						scaleConstraint -w $weight ("IK"+$fitJointIK[$i]+($z+1)+$side) ("IKScaler"+$IKJoints[$y]+$side);
						}
					float $scalerWeight=((1.0 / (`size($IKJoints)`+1))*($y+1))*2;
					if ($scalerWeight>1)
						$scalerWeight=1-($scalerWeight-1);
					addAttr -k 1 -ln scalerWeight -at double -dv $scalerWeight ("IKScaler"+$IKJoints[$y]+$side);
					}
				}
			}
		}

//Advanced Stretchy (arms/legs)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if ($fitJointIKSolver[$i]!="ikRPsolver")
			continue;
		if (`asIsMayaLT`)
			continue;

		addAttr -k 1 -ln stretchy -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln antiPop -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);

		createNode -n ("IKSetRangeStretch"+$fitJointIK[$i]+$side) setRange;
		createNode -n ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side) setRange;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".stretchy") ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".valueX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".antiPop") ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".valueX");

		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc1"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLoc1"+$fitJointIK[$i]+$side+".visibility") 0;
		pointConstraint ("IKX"+$fitJointIKStartJoint[$i]+$side)  ("IKmessureLoc1"+$fitJointIK[$i]+$side);
		parent ("IKmessureLoc1"+$fitJointIK[$i]+$side) ("IKMessure");
		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc2"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLoc2"+$fitJointIK[$i]+$side+".visibility") 0;
		asAlign ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 0 0 0;
		parent ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IKmessureLoc1"+$fitJointIK[$i]+$side);

		createNode -n ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) transform;
		asAlign ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 1 0 0;
		$tempString=`listRelatives -p ("IK"+$fitJointIK[$i]+"Handle"+$side)`;
		parent ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) $tempString[0];
		pointConstraint ("IKmessureConstrainTo"+$fitJointIK[$i]+$side)  ("IKmessureLoc2"+$fitJointIK[$i]+$side);

		createNode -n ("IKdistance"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
		$tempString=`listRelatives -p ("IKdistance"+$fitJointIK[$i]+$side+"_Shape")`;
		rename $tempString[0] ("IKdistance"+$fitJointIK[$i]+$side);
		parent ("IKdistance"+$fitJointIK[$i]+$side) ("IKMessure");
		setAttr -l 1 ("IKdistance"+$fitJointIK[$i]+$side+".visibility") 0;
		connectAttr ("IKmessureLoc2"+$fitJointIK[$i]+$side+".translate") ("IKdistance"+$fitJointIK[$i]+$side+".endPoint");
		createNode -n ("IKmessureDiv"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".operation") 2;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".input2X") $ikLenght[$i];

		$distance=`getAttr ("IKdistance"+$fitJointIK[$i]+$side+".distance")`;
		createNode -n ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".attributesBlender");
		addAttr -ln antiPop -at double ("IKdistance"+$fitJointIK[$i]+$side+"Shape");
		setDrivenKeyframe -itt "spline" -ott "linear" -v $ikLenght[$i] -dv $ikLenght[$i] -cd ("IKdistance"+$fitJointIK[$i]+$side+".distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape.antiPop");
		setKeyframe -itt "spline" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.1) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*1.2) -f ($ikLenght[$i]*1.2) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "linear" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.70) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*0.9) -f ($ikLenght[$i]*0.85) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		selectKey ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setInfinity -poi linear;
		duplicate -n ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		cutKey -in 0 -in 1 -in 2 ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+".distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.input");

		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[1]");

		createNode -n ("IKdistanceClamp"+$fitJointIK[$i]+$side) clamp;
		setAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".maxR") $ikLenght[$i];
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKdistanceClamp"+$fitJointIK[$i]+$side+".inputR");
		createNode -n ("IKmessureBlendStretch"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".attributesBlender");
		connectAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".outputR") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[1]");
		connectAttr ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".output") ("IKmessureDiv"+$fitJointIK[$i]+$side+".input1X");

		addAttr -k 1 -ln lock -at double -min 0 -max 10 ("Pole"+$fitJointIK[$i]+$side);
		createNode -n ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("Pole"+$fitJointIK[$i]+$side+".lock") ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".input");

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			$temp[0]=`getAttr ($tempString[0]+".translateX")`;
			createNode -n ($tempString[0]+"_IKmessureDiv"+$side) multiplyDivide;
			setAttr ($tempString[0]+"_IKmessureDiv"+$side+".input2X") $temp[0];
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input1X");
//			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ($tempString[0]+".translateX");
			//IkLengtControl
			addAttr -k 1 -ln ("Lenght"+($a+1)) -at double -dv 1 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ($tempString[0]+"_IKLenght"+$side) multiplyDivide;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".Lenght"+($a+1)) ($tempString[0]+"_IKLenght"+$side+".input1X");
			setAttr ($tempString[0]+"_IKLenght"+$side+".input2X") $temp[0];
			connectAttr ($tempString[0]+"_IKLenght"+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input2X");

			//pole.lock
			createNode -n ("PoleLockBlender"+$tempString[0]) blendTwoAttr;
			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ("PoleLockBlender"+$tempString[0]+".input[0]");
			connectAttr ("PoleLockBlender"+$tempString[0]+".output") ($tempString[0]+".translateX");
			connectAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".output")  ("PoleLockBlender"+$tempString[0]+".attributesBlender");
			createNode -n ($tempString[0]+"Distance") distanceBetween;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix1");
			if ($a==0)
				connectAttr ("IKMessureFrom"+$fitJointIKStartJoint[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			else
				connectAttr ("IK"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			createNode -n ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side) unitConversion;
			setAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".conversionFactor") $b;
//			connectAttr ($tempString[0]+"Distance.distance") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");
			//divide by Main.sy scale
			createNode -n ("PoleLockMainScaler"+$tempString[0]) multiplyDivide;
			setAttr ("PoleLockMainScaler"+$tempString[0]+".operation") 2;
			connectAttr ($tempString[0]+"Distance.distance") ("PoleLockMainScaler"+$tempString[0]+".input1X");
			connectAttr Main.sy ("PoleLockMainScaler"+$tempString[0]+".input2X");
			connectAttr ("PoleLockMainScaler"+$tempString[0]+".outputX") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");

			connectAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".output") ("PoleLockBlender"+$tempString[0]+".input[1]");;

			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}
		}


//HipSwinger
int $buildHipSwinger=`objExists Spine1_M`;
if ($buildHipSwinger)
	{
	asCreateController "HipSwinger" "" "_M" "Spine1";
	if (`objExists FKIKBlendSpineCondition_M`)
		connectAttr FKIKBlendSpineCondition_M.outColorG HipSwingerOffset_M.v;
	asAlign HipSwingerOffset_M Root_M 0 1 0 0;
	parent HipSwinger_M HipSwingerOffset_M;
	delete HipSwingerExtra_M;
	parent HipSwingerOffset_M FKSystem;
	$pos=`xform -q -ws -t Root`;
	delete `pointConstraint Root Spine1 HipSwingerOffset_M`;
	setAttr HipSwingerOffset_M.tx (`getAttr Root.fat`*`getAttr Root.fatZ`*-1.4);
	asLockAttr HipSwinger_M 1 0 1 0;

	createNode -n HipSwingerStabilizerTarget -p HipSwingerOffset_M transform;
	if (`attributeExists inbetweenJoints Root`)
		asAlign HipSwingerStabilizerTarget HipSwinger_M 1 1 0 0;
	else
		asAlign HipSwingerStabilizerTarget FKOffsetSpine1_M 1 1 0 0;
	if ($inbetweenJoints==0)
		asAlign HipSwingerStabilizerTarget Spine1 0 1 0 0;
	createNode -n HipSwingReverseNeg -p FKSystem transform;
	asAlign HipSwingReverseNeg Root_M 1 1 0 0;

	$parent="HipSwingReverseNeg";
	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints Root`)
		$inbetweenJoints=`getAttr Root.inbetweenJoints`;
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		createNode -n ("HipSwingReversePart"+$y) -p $parent transform;
		asAlign ("HipSwingReversePart"+$y) ("RootPart"+$y+"_M") 1 1 0 0;
		$parent="HipSwingReversePart"+$y;
		}
	createNode -n HipSwingReverseSpine1 -p $parent transform;
	asAlign HipSwingReverseSpine1 Spine1_M 1 1 0 0;

	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		orientConstraint HipSwingerStabilizerTarget HipSwinger_M ("HipSwingReversePart"+$y);
		setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.HipSwingerStabilizerTargetW0") (1-((1.0/($inbetweenJoints+1))*$y));
		setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.HipSwinger_MW1") ((1.0/($inbetweenJoints+1))*$y);
		}

	asAlign HipSwingReverseNeg Spine1_M 1 0 0 0;
	setAttr HipSwingReverseNeg.sx -1;
	orientConstraint HipSwinger_M HipSwingReverseSpine1;

	createNode -n HipSwingerStabilizer transform;
	if ($inbetweenJoints==0)
		{
		createNode -n HipSwingReverse -p HipSwingReverseNeg transform;
		orientConstraint HipSwinger_M HipSwingReverse;
		parent HipSwingReverseSpine1 HipSwingReverse;
		parent HipSwingerStabilizer FKOffsetSpine1_M;
		xform -os -t 0 0 0 -ro 0 0 0 HipSwingerStabilizer;
		parent FKExtraSpine1_M HipSwingerStabilizer;
		}
	else
		{
		parent HipSwingerStabilizer FKExtraRoot_M;
		xform -os -t 0 0 0 -ro 0 0 0 HipSwingerStabilizer;
		parent FKRoot_M HipSwingerStabilizer;
		}
	orientConstraint HipSwingerStabilizerTarget HipSwingerStabilizer;
	parentConstraint HipSwingReverseSpine1 FKOffsetRoot_M;

	//Added for MoCap to rotate Root joint
	duplicate -n HipSwingerStabilizerTarget2 HipSwingerStabilizerTarget;
	parent HipSwingerStabilizerTarget2 FKExtraRoot_M;
	orientConstraint HipSwingerStabilizerTarget2 HipSwingerStabilizer;
	addAttr -k 1 -ln stabilize -at double -min 0 -max 10 -dv 10 HipSwinger_M;
	createNode -n HipSwingerStabilizerUnitConversion unitConversion;
	setAttr HipSwingerStabilizerUnitConversion.conversionFactor 0.1;
	connectAttr HipSwinger_M.stabilize HipSwingerStabilizerUnitConversion.input;
	connectAttr HipSwingerStabilizerUnitConversion.output HipSwingerStabilizer_orientConstraint1.HipSwingerStabilizerTargetW0;
	createNode -n HipSwingerStabilizerReverse reverse;
	connectAttr HipSwingerStabilizerUnitConversion.output HipSwingerStabilizerReverse.inputX;
	connectAttr HipSwingerStabilizerReverse.outputX HipSwingerStabilizer_orientConstraint1.HipSwingerStabilizerTarget2W1;
	}
/*
if (`attributeExists inbetweenJoints Root`)
	$buildHipSwinger=0;
if ($buildHipSwinger)
	{
	createNode -n HipSwingerGroupRoot_M transform;
	string $spine1="Spine1";
	asAlign HipSwingerGroupRoot_M ($spine1+"_M") 1 1 0 1;
	duplicate -n HipSwingerStabalizeRoot_M HipSwingerGroupRoot_M;
	duplicate -n HipSwingerGroupOffsetRoot_M HipSwingerGroupRoot_M;
	parent HipSwingerGroupRoot_M HipSwingerGroupOffsetRoot_M;
	parent HipSwingerGroupOffsetRoot_M FKRoot_M;
	parent HipSwingerStabalizeRoot_M FKXRoot_M;
	orientConstraint FKRoot_M HipSwingerStabalizeRoot_M;
	parent FKXRoot_M HipSwingerGroupRoot_M;

	asCreateController "HipSwinger" "" "_M" $spine1;
	asAlign HipSwingerOffset_M HipSwingerGroupOffsetRoot_M 0 1 0 0;
	parent HipSwinger_M HipSwingerOffset_M;
	delete HipSwingerExtra_M;

	parent HipSwingerOffset_M FKRoot_M;
	parent ("FKOffset"+$spine1+"_M") HipSwingerStabalizeRoot_M;

	connectAttr HipSwinger_M.r HipSwingerGroupRoot_M.r;

	$pos=`xform -q -ws -t HipSwinger_M.cv[3]`;
	$pos2=`xform -q -ws -t HipSwinger_M.cv[7]`;
	$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
	$temp=`xform -q -ws -t HipSwinger_M`;
	float $hipSwingerHeight=$temp[1]/3.0;
	float $hipSwingerScale=$hipSwingerHeight/$dist;
	xform -ws -s $hipSwingerScale $hipSwingerScale $hipSwingerScale HipSwinger_M.cv[0:99];

	$pos=`xform -q -ws -t Root`;
//	xform -ws -t ($pos[0]+(`getAttr Root.sz`*$scale*-2)) ($pos[1]+(`getAttr Root.sz`*$scale)) $pos[2] HipSwingerOffset_M;
	delete `pointConstraint $spine1 Root_M HipSwingerOffset_M`;
	setAttr HipSwingerOffset_M.tz ($iconScaleFactor*-7.5);
	if (`attributeExists fatZ Root`)
		{
		$pos=`xform -q -ws -t HipSwinger_M.cv[3]`;
		$pos2=`xform -q -ws -t HipSwinger_M.cv[7]`;
		$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		setAttr HipSwingerOffset_M.translateZ ((`getAttr Root.fat`*`getAttr Root.fatZ`*-1)-$dist/4.0);
		}

	asLockAttr HipSwinger_M 1 0 1 0;
	}
*/

//CenterBetweenFeet
string $ikLegs[];
$tempString=`ls "IKLeg*_*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im ControlSet $tempString[$i]`)
		$ikLegs[size($ikLegs)]=$tempString[$i];
if (size($ikLegs) && $centerBtwFeet)
	{
	createNode -n RootCenterBtwLegsBlended_M transform;
	asAlign RootCenterBtwLegsBlended_M Root_M 1 0 0 1;
	parent RootCenterBtwLegsBlended_M RootSystem;
	parent RootOffsetX_M RootCenterBtwLegsBlended_M;
	createNode -n RootCenterBtwLegsOffset_M -p RootSystem transform;
	asAlign RootCenterBtwLegsOffset_M Root_M 1 0 0 1;
	duplicate -n RootCenter_M RootCenterBtwLegsOffset_M;
	duplicate -n RootCenterBtwLegs_M RootCenterBtwLegsOffset_M;
	for ($i=0;$i<size($ikLegs);$i++)
		{
		pointConstraint -skip y $ikLegs[$i] RootCenterBtwLegs_M;
		orientConstraint -skip x -skip z $ikLegs[$i] RootCenterBtwLegs_M;
		}
	parent RootCenterBtwLegsOffset_M RootCenterBtwLegs_M;
	parentConstraint RootCenter_M RootCenterBtwLegsOffset_M RootCenterBtwLegsBlended_M;
	createNode -n CenterBtwLegsUnitConversion unitConversion;
	setAttr CenterBtwLegsUnitConversion.conversionFactor 0.1;
	addAttr -k 1 -ln CenterBtwFeet -at double -min 0 -max 10 RootX_M;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsUnitConversion.input;
	createNode -n CenterBtwLegsUnitReverse reverse;
	connectAttr CenterBtwLegsUnitConversion.output CenterBtwLegsUnitReverse.inputX;
	connectAttr CenterBtwLegsUnitConversion.output RootCenterBtwLegsBlended_M_parentConstraint1.RootCenterBtwLegsOffset_MW1;
	connectAttr CenterBtwLegsUnitReverse.outputX RootCenterBtwLegsBlended_M_parentConstraint1.RootCenter_MW0;
	createNode -n CenterBtwLegsNodeStateSetRange setRange;
	setAttr CenterBtwLegsNodeStateSetRange.minX 1;
	setAttr CenterBtwLegsNodeStateSetRange.oldMaxX 0.1;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsNodeStateSetRange.valueX;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_pointConstraint1.nodeState;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_orientConstraint1.nodeState;
	}
//Locking
asLockAttr FKRoot_M 1 0 0 0;
asLockAttr FKExtraRoot_M 1 0 0 0;
asLockAttr RootX_M 0 0 1 0;

//Advanced Twist
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointTwistJoints[$i])
			catchQuiet (`delete ($fitJoints[$i]+$side+"_parentConstraint1")`);
		else if (!$fitJointUpTwistJoints[$i])
			continue;refresh;

		asCreateUnTwister $fitJoints[$i] $side $fitJointParent[$i] $parentSide $fitJointIK[$i] $b 0 "";

		if ($fitJointTwistJoints[$i])
			{
			asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
			parent ($fitJoints[$i]+$side+"_pointConstraint1") ConstraintSystem;	
			}

		int $numTwisters=$fitJointTwistJoints[$i]+1;
		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			$numTwisters=$fitJointUpTwistJoints[$i]+1;
		for ($y=0;$y<$numTwisters;$y++)
			{
			createNode -n ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side) multiplyDivide;
			createNode -n ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side) plusMinusAverage;
			createNode -n ("Twister"+$fitJoints[$i]+$y+$side) -p ("UnTwist"+$fitJoints[$i]+$side) transform;

			if ($fitJointTwistJoints[$i])
				{
				if ($y==0)
					$joint=$fitJoints[$i]+$side;
				else
					$joint=$fitJoints[$i]+"Part"+$y+$side;
				addAttr -k 1 -ln twistAmount -at double -min 0 -max 1 $joint;
				addAttr -k 1 -ln twistAddition -at double $joint;
				setAttr ($joint+".twistAmount") ($y/($fitJointTwistJoints[$i]+1.0));
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input2X");
				connectAttr ($joint+".twistAddition") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[1]");
				orientConstraint ("Twister"+$fitJoints[$i]+$y+$side) $joint;
				parent ($joint+"_orientConstraint1") ConstraintSystem;
				}

			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input1X");
			connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[0]");
			connectAttr ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".output1D") ("Twister"+$fitJoints[$i]+$y+$side+".rotateX");
			}
		}

//Advanced Twist ($fitJointUpTwistJoints)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			for ($y=0;$y<$fitJointUpTwistJoints[$i]+1;$y++)
				{
				if ($y==0)
					$joint=$fitJointParent[$i]+$parentSide;
				else
					$joint=$fitJointParent[$i]+"Part"+$y+$parentSide;
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input2X");
				connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$fitJointParent[$i]+"Part"+$y+$parentSide+".input1D[2]");
//				connectAttr -f ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("twistAmountDivide"+$fitJointParent[$i]+"Part"+$y+$parentSide+".input1X");
				}
		}

//Advanced BendyJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if (!$fitJointBendyJoints[$i])
			continue;

		string $crvCmd="curve -n Bend"+$fitJoints[$i]+"Curve"+$side+" -d 3";
		for ($z=0;$z<5;$z++)
			 $crvCmd+=" -p 0 0 0";
		eval ($crvCmd);
		$tempString=`listRelatives -s ("Bend"+$fitJoints[$i]+"Curve"+$side)`;
		rename $tempString[0] ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape");
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
		parent ("Bend"+$fitJoints[$i]+"Curve"+$side) BendSystem;

		createNode -n ("BendParentConstraint"+$fitJoints[$i]+$side) -p BendSystem transform;
		asConstraintToFKIK "parent" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
		asConstraintToFKIK "scale" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);

		createNode -n ("BendParentConstraintOffset"+$fitJoints[$i]+$side) -p BendSystem transform;
		asAlign ("BendParentConstraintOffset"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side) 1 1 0 0;
		parent ("BendParentConstraint"+$fitJoints[$i]+$side) ("BendParentConstraintOffset"+$fitJoints[$i]+$side);

		$bendControlNr=1;
		for ($z=0;$z<5;$z++)
			{
			spaceLocator -n ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);
			setAttr -l 1 ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+".v") 0;
			connectAttr ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

			float $posFactor=(1.0/4.0)*$z;

			float $invPosFactor=1-$posFactor;
			$tempString=`pointConstraint -w $invPosFactor ($fitJoints[$i]+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side)`;
			pointConstraint -w $posFactor ($fitJointChild[$i]+$childSide) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);
			delete $tempString[0];

			if ($z==0)//Start
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
			if ($z==2 || $z==0)//Controllers
				{
				asCreateController "Bend" ($fitJoints[$i]+$bendControlNr) $side $fitJoints[$i];
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) BendSystem;
				asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) 1 0 0 0;
				asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("FK"+$fitJoints[$i]+$side) 0 1 0 0;
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("Bend"+$fitJoints[$i]+$bendControlNr+$side);
				$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
				xform -s 0.1 1 1 ("Bend"+$fitJoints[$i]+$bendControlNr+$side+".cv[0:99]");
				$bendControlNr++;
				}
			if ($z==0)//Create BendStiff node
				{
				createNode -n ("BendStiff"+$fitJoints[$i]+$side) setRange;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".minX") 0;setAttr ("BendStiff"+$fitJoints[$i]+$side+".minY") 1;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".maxX") 1;setAttr ("BendStiff"+$fitJoints[$i]+$side+".maxY") 0;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMinX") -10;setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMinY") -10;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMaxX") 10;setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMaxY") 10;
				}
			if ($z==2)//`Bezier handles`(stiffness)
				{
				addAttr -k 1 -ln stiff -at double -min -10 -max 10 -dv 0 ("Bend"+$fitJoints[$i]+"2"+$side);
				connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".stiff") ("BendStiff"+$fitJoints[$i]+$side+".valueX");
				connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".stiff") ("BendStiff"+$fitJoints[$i]+$side+".valueY");
/*
select -r BendShoulderBezOff3_R ;
select -tgl BendElbow1_R ;
parent;
*/
				}

			if ($z==1 || $z==3)//`Bezier handles`(stiffness)
				{
				createNode -n ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) -p ("BendParentConstraint"+$fitJoints[$i]+$side) transform;
				if ($z==1)
					parent ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"1"+$side);
print ($fitJoints[$i]+" : "+"Bend"+$fitJointChild[$i]+"1"+$side+" "+`objExists ("Bend"+$fitJointChild[$i]+"1"+$side)`+"\n");
				if ($z==3 && `objExists ("Bend"+$fitJointChild[$i]+"1"+$side)`)
					parent ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJointChild[$i]+"1"+$side);
	/*
				if ($z==3 && `objExists ("Bend"+$fitJointParent[$i]+"BezOff"+$z+$side)` && `objExists ("Bend"+$fitJoints[$i]+"1"+$side)`)
					{
					createNode -n ("Bend"+$fitJointParent[$i]+"BezOffOffset"+$z+$side) -p ("BendParentConstraint"+$fitJoints[$i]+$side) transform;
					pointConstraint ("Bend"+$fitJoints[$i]+"1"+$side) ("Bend"+$fitJointParent[$i]+"2"+$parentSide) ("Bend"+$fitJointParent[$i]+"BezOffOffset"+$z+$side);
					parent ("Bend"+$fitJointParent[$i]+"BezOff"+$z+$side) ("Bend"+$fitJointParent[$i]+"BezOffOffset"+$z+$side);
					}
*/
				asAlign ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) 1 1 0 0;
				duplicate -n ("Bend"+$fitJoints[$i]+"BezOn"+$z+$side) ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side);
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
				pointConstraint ("Bend"+$fitJoints[$i]+"BezOn"+$z+$side) ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);

				connectAttr ("BendStiff"+$fitJoints[$i]+$side+".outValueX") ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$fitJoints[$i]+"BezOn"+$z+$side+"W0");
				connectAttr ("BendStiff"+$fitJoints[$i]+$side+".outValueY") ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$fitJoints[$i]+"BezOff"+$z+$side+"W1");

				}
			if ($z==4)
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
			if ($z==3)
				{
				parent ("Bend"+$fitJoints[$i]+"BezOn"+"1"+$side) ("Bend"+$fitJoints[$i]+"2"+$side);
				parent ("Bend"+$fitJoints[$i]+"BezOn"+"3"+$side) ("Bend"+$fitJoints[$i]+"2"+$side);
				}
			}

		//connect to twistJoints
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{

			if ($y==0)
				$joint=$fitJoints[$i]+$side;
			else
				{
				$joint=$fitJoints[$i]+"Part"+$y+$side;
				delete ($joint+"_orientConstraint1");
				}
			if ($y==0)
				delete (`listConnections -s 1 -d 0 ($fitJoints[$i]+$side+".tx")`);//could be point or parent constraint

			//bend hookup
			if ($y==0)
				{
				pointConstraint ("Bend"+$fitJoints[$i]+"1"+$side) $joint;				
				parent ($joint+"_pointConstraint1") ConstraintSystem;			
				}
			else
				{
				createNode -n ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side) pointOnCurveInfo;
				connectAttr -f ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.worldSpace[0]") ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".inputCurve");
				createNode -p BendSystem -n ($fitJoints[$i]+"PointOnCurveXform"+$y+$side) transform;
				connectAttr -f ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".position") ($fitJoints[$i]+"PointOnCurveXform"+$y+$side+".t");
//				setAttr ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".turnOnPercentage") 1;
				//make tempSurface, so a closestPointOnSurface node can find $parameter
				extrude -n tempSurface -ch true -rn false -po 0 -et 0 -upn 1 -length 1 -rotation 0 -scale 1 -dl 3 ("Bend"+$fitJoints[$i]+"Curve"+$side);
				createNode -n tempClosestPointOnSurface closestPointOnSurface;
				spaceLocator -n tempClosestPointOnSurfaceLoc;
				connectAttr tempSurface.worldSpace[0] tempClosestPointOnSurface.inputSurface;
				connectAttr tempClosestPointOnSurfaceLoc.worldPosition[0] tempClosestPointOnSurface.inPosition;
				pointConstraint ($fitJoints[$i]+$side) ($fitJointChild[$i]+$childSide) tempClosestPointOnSurfaceLoc;
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$fitJoints[$i]+$side+"W0") (1-((1.0/($fitJointTwistJoints[$i]+1.0))*$y));
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$fitJointChild[$i]+$childSide+"W1")((1.0/($fitJointTwistJoints[$i]+1.0))*$y);
				float $parameter=`getAttr tempClosestPointOnSurface.parameterU`;
				delete tempClosestPointOnSurface tempSurface tempClosestPointOnSurfaceLoc;
				setAttr ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".parameter") $parameter;

				pointConstraint ($fitJoints[$i]+"PointOnCurveXform"+$y+$side) $joint;
				parent ($joint+"_pointConstraint1") ConstraintSystem;	
				tangentConstraint -weight 1 -aimVector $b 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("Twister"+$fitJoints[$i]+$y+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side) $joint;
				parent ($joint+"_tangentConstraint1") ConstraintSystem;
				}
			}
		}

//Advanced BendyJoints (attached to parent)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointUpBendyJoints[$i])
			{
			if (!$fitJointBendyJoints[$i])//e.g. wrist
				asConstraintToFKIK "parent" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("Bend"+$fitJointParent[$i]+"Locator"+"4"+$parentSide);
			if ($fitJointBendyJoints[$i])//e.g. elbow
				parent ("Bend"+$fitJointParent[$i]+"Locator"+"4"+$parentSide) ("Bend"+$fitJoints[$i]+"1"+$side);
			}

		//twisty BendyJoints
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			if (!$fitJointBendyJoints[$i])
				continue;
			//startTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1X");
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2X") (1-(1/($fitJointTwistJoints[$i]+0.00))*$y);
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputX") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[3]");
			//midTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"2"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Y");
			float $hf=(1.0/$fitJointTwistJoints[$i])*$y*2;
			if ($y>$fitJointTwistJoints[$i]/2) $hf=2-$hf;
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Y") $hf;
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputY") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[4]");
			//endTwister
			if (`objExists ("Bend"+$fitJointChild[$i]+"1"+$childSide+".rx")`)
				{
				connectAttr ("Bend"+$fitJointChild[$i]+"1"+$childSide+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Z");
				setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Z") ((1/($fitJointTwistJoints[$i]+0.00))*$y);
				connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputZ") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[5]");
				}
			}
		}

//Advanced distribution of twistJoints (non-BendyJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointTwistJoints[$i])
			continue;

		//Seem to work.Nope, makes foot unasable with stretchy leg
//		setAttr ($fitJoints[$i]+"Part"+"1"+$side+".segmentScaleCompensate") 0;

		//if there`s no ("FKX"+$fitJointChild[$i]+$childSide), the skip Advanced distribution
		if (!`objExists ("FKX"+$fitJointChild[$i]+$childSide)`)
			continue;

		string $contraintTo="FKX"+$fitJointChild[$i]+$childSide;
		if ($fitJointIK[$i]!="")
			{
			$contraintTo=("FKIKMix"+$fitJointChild[$i]+$childSide);
			createNode -n $contraintTo -p TwistSystem transform;
			if (`objExists $contraintTo`)
				asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJointChild[$i]+$childSide) ("IKX"+$fitJointChild[$i]+$childSide) $contraintTo;
			}

		if (!$fitJointBendyJoints[$i] && `objExists $contraintTo`)
			{
			for ($y=1;$y<$fitJointTwistJoints[$i]+1;$y++)
				{
				$tempString=`pointConstraint $contraintTo ($fitJoints[$i]+$side) ($fitJoints[$i]+"Part"+$y+$side)`;
				$constraint=$tempString[0];
				parent $constraint ConstraintSystem;
				setAttr ($constraint+"."+$contraintTo+"W0") ($y/($fitJointTwistJoints[$i]+1.0));
				setAttr ($constraint+"."+$fitJoints[$i]+$side+"W1") (1-($y/($fitJointTwistJoints[$i]+1.0)));
				}
			}
		}


//volume (Squash Scaling) - `IK setup` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if (`asIsMayaLT`)
			continue;

		$ikHandle = ("IK"+$fitJointIK[$i]+$side);
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			$ikHandle = ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 $ikHandle;
		createNode -n ("volume"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ($ikHandle+".volume") ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
		createNode -n ("multWithStretchy"+$fitJointIK[$i]+$side) multiplyDivide;
		connectAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input1X");
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input2X");
		createNode -n ("volume1Over"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".operation") 2;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");
		else
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");			
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".input1X") 1;
		createNode -n ("volumepow"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".operation") 3;
		connectAttr ("volume1Over"+$fitJointIK[$i]+$side+".outputX") ("volumepow"+$fitJointIK[$i]+$side+".input1X");
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".input2X") 0.5;
		createNode -n ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side) blendTwoAttr;
		connectAttr ("multWithStretchy"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".attributesBlender");
		setAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[0]") 1;
		connectAttr ("volumepow"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[1]");
		}

//volume (Squash Scaling) - `Connect to scale` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJoints[$i]=="Root")
			continue;
		if ($isIKEnd[$i])
			continue;

		if (`asIsMayaLT`)
			continue;

		string $volumeOutPlug="volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output";
		if (`objExists ("IKScaler"+$fitJoints[$i]+$side)`)
			{
			createNode -n ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side) plusMinusAverage;
			createNode -n ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side) plusMinusAverage;
			connectAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output") ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[0]");
			setAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[1]") -1;
			setAttr ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[1]") 1;

			createNode -n ("IKSquashDistributer"+$fitJoints[$i]+$side) multiplyDivide;
			connectAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".output1D") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input1X");
			connectAttr ("IKScaler"+$fitJoints[$i]+$side+".scalerWeight") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input2X");

			connectAttr ("IKSquashDistributer"+$fitJoints[$i]+$side+".outputX") ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[0]");
			$volumeOutPlug="IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".output1D";
			}

		if (`objExists ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side)`)//splineIkScaling
			{
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Y");
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Z");
			}
		else
			{
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1.color1G");
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1.color1B");
			}
		}

//Advanced Attach
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointsAttachTo[$i]=="")
			continue;

		if (`objExists closestSampler`)
			delete closestSampler;
		createNode -n closestSampler closestPointOnMesh;
		connectAttr -f ($fitJointsAttachTo[$i]+".outMesh") closestSampler.inMesh;
		float $temp[]=`xform -q -ws -t $fitJoints[$i]`;
		setAttr closestSampler.inPosition ($temp[0]*$b) $temp[1] $temp[2];
		int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
		delete closestSampler;
		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		string $offsetParent=$tempString[0];
		createNode -n ("FKAttach"+$fitJoints[$i]+$side) transform;
		createNode -n ("FKAttachOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAttachOffset"+$fitJoints[$i]+$side) $offsetParent 1 1 0 0;
		select -r ($fitJointsAttachTo[$i]+".f["+$closestFaceIndex+"]");
		select -add ("FKAttach"+$fitJoints[$i]+$side);
		doCreatePointOnPolyConstraintArgList 1 { "0","0","0","1","","1" };
//		cMuscleSurfAttachSetup();
//		$tempString=`listRelatives -c grpSurfAttachRIG`;
//		rename $tempString[`size($tempString)`-1] ("FKAttach"+$fitJoints[$i]+$side);
//		setAttr ("FKAttach"+$fitJoints[$i]+$side+"Shape.v") 0;
		parent ("FKAttach"+$fitJoints[$i]+$side) $offsetParent;
//		$tempString=`listRelatives -c grpSurfAttachRIG`;
//		if (!size($tempString))
//			delete grpSurfAttachRIG;
		parent ("FKAttachOffset"+$fitJoints[$i]+$side) ("FKAttach"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAttachOffset"+$fitJoints[$i]+$side);
		}

//Advanced Wheel
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointsWheel[$i])
			continue;

		if (!`objExists WheelSystem`)
			{
			createNode -n WheelSystem -p MotionSystem transform;
			setAttr -l 1 WheelSystem.inheritsTransform 0;
			}

		xform -os -t 0 -0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[0]");
		xform -os -t 0 0 -1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[1]");
		xform -os -t 0 0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[2]");
		xform -os -t 0 1.108194 0  ("FK"+$fitJoints[$i]+$side+"Shape.cv[3]");
		xform -os -t 0 0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[4]");
		xform -os -t 0 0 1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[5]");
		xform -os -t 0 -0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[6]");
		xform -os -t 0 -1.108194 0 ("FK"+$fitJoints[$i]+$side+"Shape.cv[7]");

		$temp=`xform -q -ws -t $fitJoints[$i]`;
		float $diameter=$temp[1]*2;
//		float $scaleFactor= $diameter * 1.1054;// 1.1054->nurbs
		float $scaleFactor=$diameter/2.0;
		xform -ws -s $scaleFactor $scaleFactor $scaleFactor ("FK"+$fitJoints[$i]+$side+"Shape.cv[0:999]");
		addAttr -k 1 -ln "diameter" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 1 -ln "autoRoll" -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 1 ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosX" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosY" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosZ" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);

		createNode -n ("prevPosOffset"+$fitJoints[$i]+$side) -p WheelSystem transform;
		createNode -n ("prevPos"+$fitJoints[$i]+$side) -p ("prevPosOffset"+$fitJoints[$i]+$side) transform;
		createNode -n ("prevPosAngler"+$fitJoints[$i]+$side) -p ("prevPos"+$fitJoints[$i]+$side) transform;
		createNode -n ("nowPos"+$fitJoints[$i]+$side) -p WheelSystem transform;
		pointConstraint ("FK"+$fitJoints[$i]+$side) ("nowPos"+$fitJoints[$i]+$side);
		asAlign ("prevPosOffset"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side) 1 0 0 0;
		$temp=`xform -q -ws -ro ("FK"+$fitJoints[$i]+$side)`;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rz") 90;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rx") $temp[1];
		duplicate -n ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		parent ("prevPosSteer"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side);
		orientConstraint ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "vector" -worldUpVector 0 1 0 ("FK"+$fitJoints[$i]+$side) ("prevPos"+$fitJoints[$i]+$side);


		string $exp="";
		$exp+="float $diameter = FK"+$fitJoints[$i]+$side+".diameter;\n";
		$exp+="float $autoRoll = FK"+$fitJoints[$i]+$side+".autoRoll;\n";
		$exp+="float $sideAngle=prevPosAngler"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $prevPosX=FK"+$fitJoints[$i]+$side+".prevPosX;\n";
		$exp+="float $prevPosY=FK"+$fitJoints[$i]+$side+".prevPosY;\n";
		$exp+="float $prevPosZ=FK"+$fitJoints[$i]+$side+".prevPosZ;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateX=$prevPosX;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateY=$prevPosY;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateZ=$prevPosZ;\n";
		$exp+="float $nowPosX=nowPos"+$fitJoints[$i]+$side+".translateX;\n";
		$exp+="float $nowPosY=nowPos"+$fitJoints[$i]+$side+".translateY;\n";
		$exp+="float $nowPosZ=nowPos"+$fitJoints[$i]+$side+".translateZ;\n";
		$exp+="float $distance=`mag<<$nowPosX-$prevPosX,$nowPosY-$prevPosY,$nowPosZ-$prevPosZ>>`;\n";
		$exp+="float $curRotX=FKX"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $piD = 3.14 * $diameter;\n";
		$exp+="FKX"+$fitJoints[$i]+$side+".rotateX=$curRotX+($distance/$piD)*360 * $autoRoll * "+($b*-1)+" * sin(deg_to_rad($sideAngle));\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosX=$nowPosX;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosY=$nowPosY;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosZ=$nowPosZ;\n";

		expression -n ($fitJoints[$i]+"WheelExpression"+$side) -s $exp -o ("FKX"+$fitJoints[$i]+$side) -ae 1 -uc all ;

		}


connectAttr -f jointLayer.drawInfo FKOffsetRoot_M.drawOverride;

//Custom controller shapes
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
		$sca=`xform -q -r -s $fitJoints[$i]`;

		//Head 
		if (`gmatch $fitJoints[$i] "*Head*"` && $fitJointChild[$i]!="")
			{
			$pos2=`xform -q -ws -t $fitJointChild[$i]`;
			xform -r -s 2 2 2 ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			xform -r -ws -t ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
//			xform -s (1/$sca[0]) (1/$sca[1]) (1/$sca[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");//restore uniform scale first
//			float $frontAxisScale=`getAttr ($fitJoints[$i]+".s"+$U)`;
//			xform -s $frontAxisScale $frontAxisScale $frontAxisScale ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			}
		//IKLegs
		if (`gmatch $fitJointLabel[$i] "*Foot*"` && `objExists ("IK"+$fitJointIK[$i]+$side)`)
			{
			//First find $toesEnd
			$toesEnd="";
			$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
			for ($y=0;$y<size($tempString);$y++)
				{
				$childLabel=`asLabel $tempString[$y]`;
				if (`gmatch $childLabel "*ToesEnd*"`)
					$toesEnd=$tempString[$y];
				}
			int $numCVs=`getAttr ("IK"+$fitJointIK[$i]+$side+".spans")`+`getAttr ("IK"+$fitJointIK[$i]+$side+".degree")`;
			if ($toesEnd!="")
				for ($y=0;$y<$numCVs;$y++)
					{
					$temp=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]")`;
					$temp2=`xform -q -ws -t ("IKX"+$fitJoints[$i]+$side)`;
					$temp3=`xform -q -ws -t ($toesEnd+$side)`;
					if ($temp[1]<$temp2[1])
						{
						xform -ws -t $temp[0] 0 $temp[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						if ($temp[2]>$temp2[2])
							xform -ws -t $temp[0] 0 $temp3[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						}
					}
			$temp=`xform -q -ws -t ($fitJoints[$i]+$side)`;
			rotate -r -p $temp[0] $temp[1] $temp[2] -ws 0 ($footRotX[$i]*$b) 0 ("IK"+$fitJointIK[$i]+$side+".cv[0:99]");
			}
		}

//Default System values
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		if (`gmatch $fitJointLabel[$i] "*Foot*"`)
			{
			//Legs in IK
			setAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") 10;
			//Legs have pole follow
			setAttr ("Pole"+$fitJointIK[$i]+$side+".follow") 10;
			}
		if (`gmatch $fitJointIK[$i] "*Spline*"`)
			{
			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".fixedEnd") 0;
			//IK tail stiffness, start = 5 & end= 0, and follow=10 for first
			setAttr ("IK"+$fitJointIK[$i]+"1"+$side+".stiff") 5;
			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stiff") 0;
			if (`attributeExists follow ("IK"+$fitJointIK[$i]+"1"+$side)`)
				setAttr ("IK"+$fitJointIK[$i]+"1"+$side+".follow") 10;
			}
		}

delete "iconsGroup";

//Remove endJoints from DeformSet
string $deformJoints[]=`listRelatives -type joint -ad "DeformationSystem"`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $deformJoints[$i]`;
	if ($tempString[0]=="")
		sets -rm DeformSet $deformJoints[$i];
	}

//delete $fitJointNonDef
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointNonDef[$i])
			delete ($fitJoints[$i]+$side);
		}

//Remove tempInbetweeners
for ($i=0;$i<size($fitJoints);$i++)
	if (`attributeExists tempInbetweener $fitJoints[$i]`)
		{
		$tempString=`listRelatives -c $fitJoints[$i]`;
		$tempString2=`listRelatives -p $fitJoints[$i]`;
		parent $tempString[0] $tempString2[0];
		delete $fitJoints[$i];
		}

//buildPose
createNode -n "buildPose" dagPose;
select `sets -q ("ControlSet")`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	int $kT=0;
	int $kR=0;
	int $kS=0;
	if (`getAttr -k ($controlSetMembers[$i]+".tx")`) $kT=1;
	if (`getAttr -k ($controlSetMembers[$i]+".rx")`) $kR=1;
	if (`getAttr -k ($controlSetMembers[$i]+".sx")`) $kS=1;
	if ($kT || $kR || $kS)
		$setAttrCmd+="xform -os ";
	if ($kT)
		{
		$temp=`xform -q -os -t $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-t "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kR)
		{
		$temp=`xform -q -os -ro $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-ro "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kS)
		{
		$temp=`xform -q -r -os -s $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-s "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kT || $kR || $kS)
		$setAttrCmd+=$controlSetMembers[$i]+";";
	$tempString=`listAttr -k -shortNames -ud $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
if (!`attributeExists udAttr buildPose`)
	addAttr -ln udAttr -dt "string"  buildPose;
setAttr -type "string" buildPose.udAttr $setAttrCmd;

//Ensure mirrored controls
//asMirrorControlCurves 0 ControlSet;

//drivingSystems
$userAttrs=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	{
	if (!`gmatch $userAttrs[$i] "drivingSystem_*"`)
		continue;
	string $ds=`substitute "drivingSystem_" $userAttrs[$i] ""`;
	int $numChar=size($ds);
	string $dsObjName=`substring $ds 1 ($numChar-2)`;
	string $dsSide=`substring $ds ($numChar-1) 99`;
	string $sdks[]=`listConnections ("FitSkeleton."+$userAttrs[$i])`;
	string $sdkPlugs[]=`listConnections -p 1 ("FitSkeleton."+$userAttrs[$i])`;
//	$sdks=`sort $sdks`;
//	$sdkPlugs=`sort $sdkPlugs`;
	for ($y=0;$y<size($sdks);$y++)
		{
		tokenize $sdkPlugs[$y] "." $tempString;
		string $dsAttrName=$tempString[1];

		tokenize $sdks[$y] "_" $tempString;
		string $drivenObj=`substring $tempString[0] 5 99`+"_"+$tempString[1];
		if (!`objExists $drivenObj`)
			continue;
		string $drivenAttr=$tempString[2];
		if (`gmatch $drivenAttr "*[0-9]"`)
			{
			$numChar=size($drivenAttr);
			$drivenAttr=`substring $drivenAttr 1 ($numChar-1)`;
			}

		string $controllerName=$dsObjName+$dsSide;
		if (!`objExists $controllerName`)
			asCreateDrivingSystemController $controllerName {$drivenObj};
		string $sdkXform=`asCreateSDKXform $drivenObj`;
		if (`attributeExists $drivenAttr $sdkXform`)
			connectAttr -f ($sdks[$y]+".output") ($sdkXform+"."+$drivenAttr);
		else
			warning ("failed: connectAttr -f "+$sdks[$y]+".output "+$sdkXform+"."+$drivenAttr+";");
		if (!`attributeExists $dsAttrName $ds`)
			{
			string $addAttrCmd="addAttr -k 1 -ln "+$dsAttrName+" -at \"float\"  ";
			if (`addAttr -q -hasMinValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($sdks[$y]+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasMaxValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($sdks[$y]+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMinValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($sdks[$y]+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMaxValue ($sdks[$y]+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($sdks[$y]+"."+$dsAttrName)`+" ";
			$addAttrCmd+=$ds;
			eval ($addAttrCmd);
			setAttr -type "string" buildPose.udAttr (`getAttr buildPose.udAttr`+";setAttr "+$ds+"."+$dsAttrName+" 0;");
			}
		if (`attributeExists $dsAttrName $ds`)
			connectAttr -f ($ds+"."+$dsAttrName) ($sdks[$y]+".input");
		}
	}
asOptimizeDrivingSystemControllers;

//Run
if (`attributeExists "run" FitSkeleton`)
	{
	string $run=`getAttr FitSkeleton.run`;
	catch (`eval ($run)`);
	}

//version
addAttr -ln version -at double Main;
setAttr -l 1 Main.version `asGetScriptVersion`;

//Allset
string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;
select $allAfter;
select -d $allSame;
select -ne -d "Sets" "Geometry";
select -d `ls -type ikSolver -type ikSystem`;
sets -add AllSet `ls -sl`;
select -cl;
sets -rm AllSet `listRelatives -ad FitSkeleton`;
asUpdateButtonEnables;
print "// Build Complete\n";
}
